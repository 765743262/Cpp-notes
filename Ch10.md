# Chapter 10 Objects and Classes

In this chapter you'll learn about the following:

* Procedual and object-oriented programming
* The concept of classes
* How to define and implement a class
* Public and private class
* Class data members
* Class methods (also called class function members)
* Creating and using class objects
* Class constructors and destructors
* `const` member functions
* The `this` pointer
* Creating arrays of objects
* Class scope
* Abstract data types

The following are the most important OOP features:

* Abstraction
* Encapsulation and data hiding
* Polymorphism
* Inheritance
* Reusability of code

## Procedual and Object-Oriented Programming

With a procedual approach, you first concentrate on the procedures you will follow and then think about how to represent the data.

With an OOP approach, you concentrate on the object as the user perceives it, thinking about the data you need to describe the object and the operations that will describe the user's interaction with the data.

## Abstraction and Classes

In OOP, you abstract the essential operational features of a problem and express a solution in those terms.

### What Is a Type?

Specifying a basic type does three things:

* It determines how much memory is needed for a data object.
* It determines how the bits in the memory are interpreted.
* It determines **what operations, or methods, can be performed using the data object**.

One important part of our thinking is **how we define things**. And the thing "type", is well and completely defined with these three pieces.

### Classes in C++

A _class_ is a C++ vehicle for **tranlating an abstraction to user-defined type**. It combines data representation and methods for manipulating that data into one neat package.

Generally, a class specification has two parts:

* A _class declaration_, which describes he data component, in terms of data members and the public interface, in terms of member functions, termed _methods_.
* The _class method definitions_, which describe how certain class member functions are implemented.

Typically, C++ programmers place the interface, in the form of a class definition, in a header file and place the implementation, in the form of code for the class methods, in a source code file.

Listing 10.1 presents the first stage, a tentative class declaration for a class called `Stock`.

```
// Listing 10.1
#ifndef STOCK00_H_
#define STOCK00_H_

#include <string>

class Stock
{
private:
	std::string company;
	long shares;
	double share_val;
	double total_val;
	void set_tot() { total_val = shares * share_val; }
public:
	void acquire(const std::string & co, long n, double pr);
	void buy(long num, double price);
	void sell(long num, double price);
	void update(double price);
	void show();
};	// note semicolon at the end

#endif
```


The C++ keyword `class` identifies the code in Listing 10.1 as **defining the design of a class**. The syntax identifies `Stock` as the type name for this new class. This declaration enables you to declare variables, called _objects_, or _instances_, **of the `Stock` type**. For example, the following declarations create two `Stock` objects called `sally` and `solly`:

```
Stock sally;
Stock solly;
```

Notice that the information you decided to store appears in the form of class data members, such as _company_ and _shares_. Similarly, the desired operations appear as class function members (or methods), such as `sell()` and `update()`.

A member funciton can be defined in place---for example, `set_tot()`---or it can be represented by prototypes, like the other member functions in this class. The full definitions for the other member functions come later in the implementation file, but the prototypes suffice to describe the function interfaces.

The binding of data and methods into a single unit is the most striking feature of the class. Because of this design, creating a `Stock` object automatically establishes the rules governing how that object can be used.

### Access Control

THe keywords `private` and `public` describes _access control_ for class members. Any program that uses an object of a particular class can access the public portions directly. A program can access the private members of an object _only_ by using the public member functions.

For example, the only way to alter the `shares` member of the `Stock` class is to use the `Stock` member functions. The public member functions provide interface between object and program.

This insulation of data from direct access by a program is called _data hiding_.

A class design attempts to separate the public interface from the specifics of implementation. The public interface represents the abstraction component of the design. Gathering the implementation details together and separating them from the abstraction is called _encapsulation_. 

### OOP and C++

Actually you can use OOP with any language, like C. But C++ includes features specifically intended to implement the OOP aproach:

* First, placing the data representation and the function prototypes into a single class declaration instead of keeping them separate unifles the description by placing everything in one class declaration.

* Second, making the data representation private enforces the stricture that **data is accessed only by authorized functions.** In C this is not the case.

Note that data hiding not only prevents you from accessing data directly, but it also absolves you from needing to know how the data is represented. Some value may be stored as variable, or may be calculated when needed, but both approach share the same interface.

#### Member Access Control: Public or Private?

You can declare class members, whether they are data items or member functions, either in the public or the private section of a class. Normally, data items go into the private section. The member functions that constitute the class interface go into the public section. You can also place member functions in the private section. Typically, you use private member functions to handle implementation details that don't form part of the public interface.

You don't have to use the keyword `private` in class declaration because that is the default access control for class objects.

#### Classes and Structures

In fact, C++ extends to structures the same features classes have. **The only difference is that the default access type for a structure is `public`, whereas the default type for a class is `private`.** C++ programmers commonly use classes to implement class description while restricting structures to representing **pure data objects** (often called _plain-old data_ structures, or _POD_ structures.)

### Implementing Class Member Functions

Member function definitions are much like regular function definitions. Each has a function header and a function body. But they also have two special characteristics:

* When you define a member function, you use the **scope-resolution operator** (`::`) to identify the class to which the function belongs.
* Class methods can access the `private` components of the class.

First, the function header for a member function uses he scope-resolution operator (`::`) to indicate to which class the function belongs. For example, the header for `update()` member function looks like this:

```
void Stock::update(double price);
```

The scope-resolution operator resolves the identity of the class to which a method definition applies. We say the identifier `update()` has _class scope_. **Other member functions of the `Stock` class can, if necessary, use the `update()` method without using the scope-resolution operator.** Using `update()` outside the class declaration and method difinitions, requires special measures.

`Stock::update()` is called the _qualified name_ of the function. 

The second characteristic of the method is that a method can access the private members of a class. For example, the `show()` method can use code like this:

```
std::cout << "Company: " << company
		  << "  Shares:" << shares << endl
		  << "  Share Price: $" << share_val
		  << "  Total Worth: $" << total_val << endl;
```

Here, `company`, `shares`, and so on are private data members of the `Stock` class. 

With these two points in mind, we can implement the class methods as shown in Listing 10.2.

```
// Listing 10.2

#include <iostream>
#include "test.hpp"

void Stock::acquire(const std::string & co, long n, double pr)
{
	company = co;
	if (n < 0)
	{
		std::cout << "Number of shares can't be negative; "
				  << company << " shares set to 0.\n";
				  shares = 0;
	}
	else
		shares = n;
	share_val = pr;
	set_tot();
}

void Stock::buy(long num, double price)
{
	if (num < 0)
	{
		std::cout << "Number of shares purchased can't be negative. "
				  << "Transaction is aborted.\n";
	}
	else
	{
		shares += num;
		share_val = price;
		set_tot();
	}
}

void Stock::sell(long num, double price)
{
	using std::cout;
	if (num < 0)
	{
		cout << "Number of shares sold can't be negative. "
			 << "Transaction is aborted.\n";
	}
	else if (num > shares)
	{
		cout << "You can't sell more than you have! "
			 << "Transaction is aborted.\n";
	}
	else
	{
		shares -= num;
		share_val = price;
		set_tot();
	}
}

void Stock::update(double price)
{
	share_val = price;
	set_tot();
}

void Stock::show()
{
	std::cout << "Company: " << company
			  << "	Shares: " << shares << '\n'
			  << "	Share Price: $" << share_val << '\n'
              << "    Total Worth: $" << total_val << '\n';
}
```



#### Inline Methods

Any function with a definition in the class declaration **automatically becomes an inline function**. Thus, `Stock::set_tot()` is an inline function. Note, **you don't even need the `inline` qualifier.**

You can define a member function outside the class declaration and still make it inline. To do so, you just use the `inline` qulifier **in the class implementation section**:

```
class Stock
{
private:
	...
	void set_tot(); // definition kept separate
public:
	...
};

inline void Stock::set_tot()
{
	total_val = shares * share_val;
}
```

Note the definition of inline function must **immediately follow the class declaration**, in the same header file. We must do this bacause the special rules for inline functions require that **they be defined in each file in which they are used.**

#### Which Object Does a Method Use

Suppose you created two `Stock` objects:

```
Stock kate, joe;
```

In order to invoke a member function, you use the **membership operator** as with structures and structure members:

```
kate.show();
joe.show();
```

The first call invokes `show()` as a member of the `kate` object. This means the method interprets `shares` as `kate.shares` and `share_val` as `kate.share_val`, respectively.

> Note
> When you call a member function, it uses the data members of the particular object used to invoke the member function.

Each new object you create contains storage for its own internal variables, the class members. But all objects of the same class share the same set of class methods, with just one copy of each method. That is, `kate.show()` and `joe.show()` **both execute the same block of code.** They just apply the code to different data.

Calling a member function is what some OOP languages term _sending a message_. Thus, sending the same message to two different objects invokes the same method but applies it to two different objects.

### Using Classes

The C++ goal is to make using classes as similar as possible to using the basic, built-in types. For example, you can

* Create a class object by declaring a class variable
* Using `new` to allocate an object of a class type.
* Pass objects as arguments, return them as function return values
* Assign one object to another

C++ also provides facilities for initializing objects, teaching `cin` and `cout` to recognize objects, and even providing automatic type conversions between objects of similar classes. It will be a while before you can do all those things. But let's start now with the simpler properties. Listing 10.3 provides a program to use the inter face and implementation files.

```
// Listing 10.3

#include <iostream>
#include "test.hpp"

int main(void)
{
	Stock fluffy_the_cat;
	fluffy_the_cat.acquire("NanoSmart", 20, 12.50);
	fluffy_the_cat.show();
	fluffy_the_cat.buy(15, 18.125);
	fluffy_the_cat.sell(400, 20.00);
	fluffy_the_cat.show();
	fluffy_the_cat.buy(300000, 40.125);
	fluffy_the_cat.show();
	fluffy_the_cat.sell(300000, 0.125);
	fluffy_the_cat.show();

	return 0;
}
```

##### The Client/Server Model

* _Client_: a program that uses the class.
* _Server_: the class declaration, including class methods.

The client uses the server through the publicly defined interface only.

The client programmer's only responsibility, is to know that interface. **That is, the client only knows the fact that "I can define an object of a set" and "I can make tranformation on this set" without having to know how the object is defined, and how the transformation is implemented.**

The server's responsibility, or the server's designer's responsibility, is to see that the server reliably and accurately performs **according to the interface**. Any changes the server designer makes to the class design should be to details of implementation, not to the interface.

### Changing the Implementation

If you want to refine your implementation, you are supposed to make sure that the changes should not affect other parts of the client program. For example, you may change the formatting like this:

```
std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
std::cout.precision(3);
```

These format changes just mentioned stay in place until changed again, so they could affect subsequent output in the client program. Therefore, the polite thing for `show()` to do is to reset the formating information to the state that existed before `show()` was called. This can be done, as in Listing 8.8, using return values for the setting statements:

```
std::streamsize prec = std::cout.precision(3);	
...
std::cout.precision(prec);

// store original flags
std::ios_base::fmtflags orig = std::cout.setf(std::ios_base::fiex);
...
// reset to stored values 
std::cout.setf(orig, std::ios_base::floatfield);
```

Putting this information to use, we can replace the `show()` definition in the implementation file with this:

```
void Stock::show()
{
	using std::cout;
	using std::ios_base;
	// set format to #.###
	ios_base::fmtflags orig =
		cout.setf(ios_base::fixed, ios_base::floatfield);
	std::streamsize prec = cout.precision(3);

	cout << "Company: " << company
		 << "	Shares: " << shares << '\n';
	cout << "	Share Price: $" << share_val;
	// set format to #.##
	cout.precision(2);
	cout << "	Total worth: $" << total_val << '\n';

	// restore original format
	cout.setf(orig, ios_base::floatfield);
	cout.precision(prec);
}
```

### Reviewing Our Story to Date

**First Step** :Provide a class declaration'

* contains data members and function members
* has a private section, where members declared in this section can only be accessed through the member functions.
* has a public section, where members can be accessed directly by a program using class objects.

Typically, data members go into the private section and member functions go into the public section, so a typical class declaration has this form:

```
class className
{
private:
	data member declarations
public:
	member function prototypes
};
```

The contents of the public section constitutes the abstract part of the design, the public _interface_. Encapsulating data in the private section protests the integrity of the data and is called _data hiding_.

**Second Step** : Implement the class member functions

You can provide definition instead of a function prototype in the class definition or **immediately** define the function after the class declaration. Both these ways make the definition inline.

The usual practice is to provide the function definitions seperately. In that case, the scope-resolution operator is needed to identify to which class a member function belongs. A function header would look like this:

```
char * Bozo::Retort();
```

In other words, `Retort()` is not just a type `char *` function; it is a type `char *` function that belongs to the `Bozo` class. The full, or _qualified_ name of the function is `Bozo::Retort()`.

The name `Retort` has class scope, so the scope-resolution operator is needed to qualify the name when it is used outside the class declaration and a class method.

**Third Step**: Create an object

Because a class is a user-defined type, you can create an object just like this:

```
Bozo bozetta;
```

You invoke a class member function or method, by using a class object:

```
bozetta.Retort();
```

Whenever the code for that function refers to a particular data member, the function uses the value that member has in the `bozetta` object.

## Class Constructors and Destructors

You can initialize a structure like this:

```
struct thing
{
	char *pn;
	int m;
}
thing amabob = {"wodget", -23};
```

But you can't do this with class

```
Stock hot = {"Suikie's Autos, Inc.", 200, 20.25}; 	// NO! compile error
```

The reason you can't initialzize a `Stock` object this way is because the data parts have private access status, which means a program cannot access the data members directly.

C++ provides for special member functions, called _class constructors_ for constructing new objects and assigning values to their data members.

C++ provides a name for these member functions and a syntax for using them, and you provide the mothod definition. The name is the **same as the class name**. For example, a possible constructor for the `Stock` class is a member function called `Stock()`. A constructor has **no declared type**.

### Declaring and Defining Constructors

A `Stock` object has three values to be provided from the outside world, so you should give the constructor three arguments. Possibly, you may want to provide just the `company` member value and set other values to zero by default arguments. Thus the prototype would look like this:

```
Stock(const string & co, long n = 0, double pr = 0);
```

Note the constructor **has no return type**. The protyotype goes into the **public section** of the class declaration.

Here's one definition for the constructor:

```
Stock::Stock(const string & co, long n, double pr)
{
	company = co;

	if (n < 0)
	{
		std::cerr << "Number of shares can't be negative; "
				  << company << " shares set to 0.\n";
		shares = 0;
	}
	else
		shares = n;
	share_val = pr;
	set_tot();
}
```

Note this is the same code that the `acquire()` function used earlier in this chapter. The difference is that in this case, a program **automatically invokes the constructor when it declares an object.**

##### Member Names and Parameter Names

Often those new to constructors try to use the class member names as parameter names in the constructor, as in the example:

```
Stock::Stock(const string & company, long shares, double share_val)
{
	...
}
```

This is wrong. You'll end up with confusing code like this:

```
shares = shares
```

One common coding practice to help avoid such confusion is to use an `m_` prefix to identify data member names:

```
class Stock
{
private:
	string m_company;
	long m_shares;
	...
}
```

Another common practice is to use an underbar suffix for member names:

	class Stock
	{
	private:
		string company_;
		long shares_;
	}

### Using Constructors

C++ provides two ways to initialize an object by using a constructor. The first is to call the constructor explicitly:

```
Stock food = Stock("World Cabbage", 250, 1.25);
```

The second way is to call th constructor implicitly:

```
Stock garment("Furry Mason", 50, 2.5);
```

This mroe compact form is equivalent to the explicit call.

C++ uses a class constructor **whenever** you create an objecct of that class, evne when **you use `new` for dynamic memory allocation**. Here's how to use the constructor with `new`:

```
Stock * pstock = new Stock("Electroshock Games", 18, 19.0);
```

This statement creates a `Stock` object and initialize it to the value provided, and assign its address to the `pstock` pointer.

**You can't use an object to invoke a constructor** because until the constructor finishes its work of making the object, there is no object. **Rather than invoked by an object, the constructor is used to create the object**.

### Default Constructors

A _default constructor_ is a constructor that is used to create an object when you don't provide explicit initialization values. That is, it'a constructor used for declarations like this:

```
Stock fluffy_the_cat;
```

In this case, a default constructor is used.

If you failed to provide any constructors, C++ automatically supplies a default constructor that does nothing. For the `Stock` class, the default constructor would look like this:

```	
Stock::Stock() {};
```

The effect is that the object is created with its members uninitialized.

The compiler provides this default default constructor **only if** you don't define any constructor. If you provide any nondefault constructor, and don't provide your own version of a default constructor, then a declaration like this becomes an error:

```
Stock stock1;
```

If you provide a nondefault constructor and wish to create an object without explicit initialization, you must define your own default constructor. This is a constructor that **takes no argument**. You can define a default constructor in two ways. One way is to provide default values for **all** the arguments to the existing constructor:

```
Stock(const string & co = "Error", int n = 0, double pr = 0.0);
```

The second is to **use function overloading** to define a second constructor, one that has no arguments:

```
Stock();
```

You can have **only one default constructor**, so be sure you **don't do both.** You should usually initialize objects in order to ensure all members begin with known, reasonable values. Thus, a user-defined default constructor typically provides implicit initialization for all member values. For example, this is how you might define one for the `Stock` class:

```
Stock::Stock()
{
	company = "No name";
	shares = 0;
	share_val = 0.0;
	total_val = 0.0;
}
```

##### Tip

**When you design a class, you should usually provide a default constructor that implicitly initializes all class members**.

After you've used either method (no arguments or default values for all arguments) to create the default constructor, you can declare objects without initializing them explicitly:

```
Stock first;					// calls default implicitly
Stock first = Stock();			// calls it explicitly
Stock * prelief = new Stock;	// calls it implicitly
```

However, **you shouldn't be misled by the implicit form of the nondefault constructor**:

```
Stock second(); // declares a funciton
```

**This will declare a new function that returns a `Stock` object.**

So when you implicitly call the default constructor, you don't use parentheses.

### Destructors

A _destructor_ is a special member function which clean up all debris when the object expires. For example, if your constructor uses `new` to allocate memory, the destructor should use `delete` to free that memory.

Like a constructor, a destructor has a special name: It is formed from the class name preceded by a tilde (~). Thus, the destructor for the `Stock` class is called `~Clock()`. Also like a constructor, a destructor can have no return value. Unlike a constructor, a destructor **must have no arguments**. Thus, the prototype for a `Stock` destructor must be this:
​
```
~Stock();
```

Because a `Stock` destructor has no vital duties, you can code it as a do-nothing function, or add something to it:

```
Stock::~Stock()
{
	std::cout << "Bye, " << company << "!\n";
}
```

If you don't provide any destructor, the compiler will **generate an implicit, do-nothing destructor**.

The compiler decide on when a destrutor should by called. Normally your code **shouldn't explicitly call a destructor**. There are three cases that a destructor will be called:

* If you create an automatic storage class object, its destructor is called when the program exits the block of code in which the object is defined.

* If you create a static storage class object, its destructor is called when the program terminates

* If the object is created by using `new`, its destrutor is called when you use `delete`, to free the momery.

Finally, a program can create temporary objects to carry out certain operations. In that case, the destructor is called when it has finished using it.

### Improving the `Stock` Class


#### The Header File
Listing 10.4 shows the header file for the stock program.


```C++
// Listing 10.4
#ifndef STOCK10_H_
#define STOCK10_H_

#include <string>

class Stock
{
private:
    std::string company;
    long shares;
    double share_val;
    double total_val;
    void set_tot() { total_val = shares * share_val; }
public:
    // two constructors
    Stock();
    Stock(const std::string & co, long n = 0, double pr = 0.0);
    // destructor
    ~Stock();
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show();
};
#endif 
```

Listing 10.4 shows the header files. Note we need to place the prototype of our constructor and destructor in the class declaration like this:

```C++
Stock();
Stock(const std::string & co, long n = 0, double pr = 0.0);
~Stock();
```

#### The Implementation File

Listing 10.5 provides the method definitions for the stock program.


```C++
// Listing 10.5
#include <iostream>
#include "a.hpp"


// constructors
// default
Stock::Stock()
{
    std::cout << "Default constructor called\n";
    company = "no name";
    shares = 0;
    share_val = 0.0;
    total_val = 0.0;
}

Stock::Stock(const std::string & co, long n, double pr)
{
    std::cout << "Constructor using " << co << " called\n";
    company = co;

    if (n < 0)
    {
        std::cout << "Number of shares can't be negative; "
                  << company << " shares set to 0.\n";
        shares = 0;
    }
    else
    {
        shares = n;
    }
    share_val = pr;
    set_tot();
}

// class destructor
Stock::~Stock()
{
    std::cout << "Bye, " << company << "!\n";
}

// Using scope-resolution operator to identify the class

void Stock::buy(long num, double price)
{
    if (num < 0)
    {
        std::cout << "Number of shares purchased can't be negative. "
                  << "Transaction is aborted.\n";
    }
    else
    {
        shares += num;
        share_val = price;
        set_tot();
    }
}

void Stock::sell(long num, double price)
{
    using std::cout;
    if (num < 0)
    {
        cout << "Number of shars sold can't be negative. "
             << "Transaction is aborted.\n";
    }
    else if (num > shares)
    {
        cout << "You can't sell more than you have! "
             << "Transaction is aborted.\n";
    }

    else
    {
        shares -= num;
        share_val = price;
        set_tot();
    }
}

void Stock::update(double price)
{
    share_val = price;
    set_tot();
}

void Stock::show()
{
    using std::cout;
    using std::ios_base;
    ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield);
    std::streamsize prec = cout.precision(3);
    std::cout << "Company: " << company
              << "  Shares: " << shares << '\n'
              << "  Share Price: $" << share_val
              << "  Total Worth: $" << total_val << '\n';

    cout.setf(orig, ios_base::floatfield);
    cout.precision(prec);
}   
```


#### A Client File

Listing 10.6 provides a short program for testing the new methods in the stock program.


```C++
// Listing 10.6
#include <iostream>
#include "a.hpp"

int main(void)
{
	{
		using std::cout;
		cout << "Using constructors to create new objects\n";
		Stock stock1("NanoSmart", 12, 20.0);
		stock1.show();
		Stock stock2 = Stock("Boffo Objects", 2, 2.0);
		stock2.show();

		cout << "Assigning stock1 to stock2:\n";
		stock2 = stock1;
		cout << "Listing stock1 and stock2:\n";
		stock1.show();
		stock2.show();

		cout << "Using a constructor to reset an object\n";
		stock1 = Stock("Nifty Foods", 10, 50.0);
		cout << "Revised stock1:\n";
		stock1.show();
		cout << "Done\n";
	}

	return 0;
}
```

Listing 10.6 illustrate some very important properties.

The extra brace is use to make the message in the destructor appear before the window close.

Note the two syntax to initialize an object:

```C++
Stock stock1("NonaSmart", 12, 12,0)
```

and

```C++
Stock stock2 = Stock ("Boffo Objects", 2, 2.0);
```

The C++ Standard gives a compiler a couple ways to execute the second syntax. One is to make it behave exacly like the first syntax. The second way is to **create a temporary object** that is then copied to `stock2`. **Then the temporary object is discarded, and call the desctructor.**

**In this case, if destructor does something like displaying some message, the message will appear.**

The compiler may dispose of the temporary object immediately, or wait longer, in which case the destructor message will be displayed later.

The following statement illustrates that you can assign one object to another of the same type:

```C++
stock2 = stock1;
```

By default C++ copies the content of each **data member** of the source object ot the corresponding data member of the target object.

You can use the constructor for more than initializing a new object. For example:

```C++
stock1 = Stock("Nifty Foods", 10, 50.0);
```

The `stock1` object already exists. Therefore, instead of initializing `stock1`, this statement assigns new values to the object. It does so by having the constructor **create a new, temporary object** and then copying the contents of the new object to `stock1`, and then dispose of the temporary immediately or later.

When the `main()` function terminates, the two object is deleted. And **the last object created is the first deleted**. The destructor is called accordingly.

Note in both cases of initialization of a new object or assigning new values to an object, a temporary object might be created. But there is a fundamental difference between the following two statements:

```C++
Stock stock2 = Stock ("Boffo Object", 2, 2.0);
stock1 = Stock("Nifty Foods", 10, 50.0);
```

**The first statement may or may not create a temporary object. The second statement always causes the creation of a temporary object before assignment occers.**


> Tip
> If you can set object values either through initilization or by assignment, choose initilization. It is usually more efficient.

#### C++11 List Initialization

With C++ 11, you can the list-initialization syntax with classes, providing the brace contents match the argument list of a constructor:

```C++
Stock hot_tip = {"Derivatives Plus Plus", 100, 45.0};
Stock jock {"Sport Age Storage, Inc"};
Stock temp {};
```

The third declaration matches the default constructor, so `temp` is contructed using it.

#### `const` Member Functions

Consider the following code snippet

```C++
const Stock land = Stock("Kludgehorn Properties");
land.show();
```

With current C++, the compiler should object to the second line, because there is no guarantee that the `show()` method won't modify the invoking object, which, because it is `const` should not be altered.

You can place the `const` keyword after the function parentheses to indicate that the function promises not to modify the invoking object. Thus, the `show()` declaration should look like this:

```C++
void show() const;		// promises not to change invokiing object
```

Similarly, the beginning of the function definition should look like this:

```C++
void Stock::show() const 	// promises not to change invoking object
```

Class functions declared and defined this way are called `const` member functions. Just as you shoule use `const` references and pointers as formal function arguments whenever appropiate, **you should make class methods `const` whenever they don't modify the invoking object.**

### Constructors and Destructors in Review

#### Constructor

A _constructor_ is a special class member function that's called **whenever an object of that class is created**.

A class has the name as its class, but through funciton overloading, you can have more than one constructor with the same name but different signatures.

A constructor has no return type.

Your initialization should match the constructor's argument list. Suppose the `Bozo` class has the following prototype for a class constructor:

```C++
Bozo(const char * fname, const char * lname);
```

In this case, you can use it to initialize new objects as follows:

```C++
Bozo bozetta = Bozo("Bozatta", "Biggens");
Bozo fufu("Fufu", "O'Dweeb");
Bozo *pc = new Bozo("Popo", "Le Peu");
```

All the three are typical syntax of initialization.

A new point: if a constructor has just one argument, you can initialize the object like this:

```C++
Bozo tubby = 32;
```

Chapter 11 mentions a way to turn off this feature because it can lead to unpleasant surprises.

You can use constructors to assign new value to an object like this:

```
funny = Bozo("l", "f");
```

In this case a temporary object will be created with constructor, and then be destroyed with a call of destructor immediately or later.
#### Default Constructor

A default constructor has no arguments. Whenever an object is created without providing initialization like:

```C++
Bozo tubby;
Bozo funny = Bozo();
```

A default constructor must be needed.

There are two ways to create a default constructor, one is declare a constructor with no arguments, and the other is to provide all default argument for a constructor like:

```C++
Bozo();
Bozo(const char * fname = "Zhixuan", const char * lname = "Lin");
```

If no construtor is provided, the compiler will provide a default version of default constructor that does nothing.

But if you provide any constructor, the compiler will no longer do such thing. In this case, if you fail to provide a default constructor, the statements like this:

```C++
Bozo error;
Bozo error = Bozo();
```

will be an error.

#### Destructor

A program invokes a destructor when an object is destroyed. The destrucor has no return type and no arguments, and its name is the class name preceded by a tilde. For example, the `Bozo` class destructor has the following prototype:

```C++
~Bozo();
```

Class destructors that use `delete` become necessary when class constructors use  `new`.

## Knowing Your Objects: The `this` Pointer

So far each class member function has dealt with but a single object: the object that invokes it.

Suppose you want a method to compare two holdings' value. First, you will need a way to access `total_val` directly. Because `total_val` is a private member, you can provide a methods to return that value. Typically, you use inline code for this, as in the following example:

```C++
class Stock
{
private:
	...
	double total_val;
	...
public:
	double total() const { return total_val; };
	...
};
```

Note method `total()` is followed by a `const`, indicating that it will not alter values.

However, you can take a different approach, one that helps you learn about the `this` pointer. To compare two objects, you will need to define a member function like this:

```
const Stock & topval(const Stock & s) const;
```

This function accesses one object implicitly and one object explicitly, and it returns a reference to one of those two objects. The `const` in parentheses states that the function won't modify the explicitly accessed object, and the `const` that follows the parentheses states that the function won't modify the implicitly access object.

Because the function returns a reference to one of the two `const` objects, the return type has to be a `const` reference.

Meanwhile, there's still the implementation of `topval()` to attend to. It raises a slight problem. Here's a partial implementation that highlights the problem:

```
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
		return s;			// argument object
	else
		return ????;		// invoking object
}
```

The problem is, what should you return? How do you refer to the invoking object in the method it invoked?

The answer is the `this` pointer. The `this` pointer points to the object used to invoke a member function (Basically, `this` is passed as a hidden argument to the method).

**Each member function, including constructors and destructors, has a `this` pointer.** If a method needs to refer to the invoking object as a whole, it can use the expression `*this`.

**Using the `const` qulifier after the function argument parentheses qulifies `this` as being a pointer to `const`.** In this case, you can't use `this` to change the object's value.

Then the code for the comparing function would look like this:

```
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
		return s;		// argument object
	else
		return *this;	// invoking object
}
```

The fact that the return type is a reference means that the returned object is the object itself rather than a copy passed by the return mechanism.

Listing 10.7 shows the new header file.

```
// Listing 10.7
#ifndef STOCK20_H_
#define STOCK20_H_
#include <string>

class Stock
{
private:
    std::string company;
    int shares;
    double share_val;
    double total_val;
    void set_tot() { total_val = shares * share_val; }
public:
    Stock();
    Stock(const string & co, long n = 0, price = 0.0);
    ~Stock();
    void buy(long num, double price);
    void sell(long num, double price);
    void update(double price);
    void show() const;
    const Stock & topval(const Stock & s) const;
};
```

Notice how we code the prototype and definition of the constructors and destructor. Note the `const` following `show()` and `topval()`.

Listing 10.8 presents the revised class methods file, It includes the new `topval()` method. Also now that you've seen how the constructors and destructors work, Listing 10.8 replaces them with silent versions

```
// Listing 10.8

#include <iostream>
#include "test.hpp"

// constructors
Stock::Stock()		// default constructors
{
	company = "no name";
	shares = 0;
	share_val = 0.0;
	total_val = 0.0;
}

Stock::Stock(const std::string & co, long n, double pr)
{
	company = co;

	if (n < 0)
	{
		std::cout << "Number of shares can't be negative; "
				  << company << " shares set to 0.\n";
		shares = 0;
	}
	else
		shares = n;
	share_val = pr;
	set_tot();
}

// class destructor
Stock::~Stock()		// quiet class destructor
{
}

void Stock::buy(long num, double price)
{
	if (num < 0)
	{
		std::cout << "Number of shares purchased can't be negative. "
				  << "Transaction is aborted.\n";
	}
	else
	{
		shares += num;
		share_val = price;
		set_tot();
	}
}

void Stock::sell(long num, double price)
{
	using std::cout;
	if (num < 0)
	{
		cout << "Number of shares sold can't be negative. "
			 << "Transaction is aborted.\n";
	}
	else if (num > shares)
	{
		cout << "You can't sell more than you have! "
			 << "Transaction is aborted.\n";
	}
	else
	{
		shares -= num;
		share_val = price;
		set_tot();
	}
}

void Stock::update(double price)
{
	share_val = price;
	set_tot();
}

void Stock::show() const
{
	using std::cout;
	using std::ios_base;
	// set format to #.###
	ios_base::fmtflags orig =
		cout.setf(ios_base::fixed, ios_base::floatfield);
	std::streamsize prec = cout.precision(3);

	cout << "Company: " << company
		 << "	Shares: " << shares << '\n';
	cout << "	Share Price: $" << share_val;
	// set format to #.##
	cout.precision(2);
	cout << "	Total worth: $" << total_val << '\n';

	// restore original format
	cout.setf(orig, ios_base::floatfield);
	cout.precision(prec);
}

const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
		return s;
	else
		return *this;
}
```

## An Array of Objects

You declare an array of objects the same way you declare an array of any standard types:

```C++
Stock mystuff[4];
```

Recall that a program **always calls the default class constructor when it creates class objects that aren't explicitly intitialized.** This declaration requires either the class explicitly define no constructors at all, in which case the implicit do-nothing default constructor is used, or, as in this case, that an explicit default constructor be defined. Each element---`mystuff[0]`, `mystuff[1]`, and so on---is a `Stock` object and thus can be used with the `Stock` methods.

You can use a constructor to intialize the array elements. In that case, you have to **call the constructor for each individual element**:

```C++
const int STKS = 4;
Stock stocks[STKS] = 
{
	Stock("NanoSmart", 12.5, 20),
	Stock("Baffo Objects", 200, 2.0),
	Stock("Monolithic", 130, 3.25),
	Stock("Fleep Enterprises", 60, 6.5)
};
```

If the class has more than one constructor, you can use different constructors for different elements:

```C++
const int STKS = 10;
Stock stocks[STKS] =
{
	Stock("NanoSmart", 12.5, 20),
	Stock(),
	Stock("Momolithic Obelisks", 120, 3.25),
};
```

Because this declaration only partially initializes the array, the remaining seven members are initilized using the default construcstor.

Listing 10.9 applies these principles to a short program that initializes four array elements, displays their contents, and tests the elements to find the one with the highest total value.

```C++
// Listing 10.9
#include <iostream>
#include "test.hpp"

const int STKS = 4;
int main(void)
{
	Stock stocks[STKS] =
	{
		Stock("NanoSmart", 12, 20.0),
		Stock("Boffo Objects", 200, 2.0),
		Stock("Monolithic Obelisks", 130, 3.25),
		Stock("Fleep Enterprises", 60, 6.5)
	};
	std::cout << "Sock holdings:\n";
	int st;
	for (st = 0; st < STKS; st++)
		stocks[st].show();
	const Stock * top = &stocks[0];
    for (st = 1; st < STKS; st++)
		top = &top->topval(stocks[st]);
	std::cout << "\nMost valuable holding:\n";
	top->show();
	return 0;
}

```

Note the piece of code used to find the stock with the highest total value:

```C++
const Stock * top = &stocks[0];
for (st = 1; st < STKS; st++)
	top = &top->topval(stock[st]);
```

**This code uses `top->topval(stock[st])`, where `top` is a point-to-`Stock`.**

The following is how original Unix implementation use a C++ front-end `cfront` to converted C++ programs to C programs. A C++ method definition like

```C++
void Stock::show() const
{
	cout << "Company: " << company
		 << "  Shares: " << shares << '\n'
		 << "  Share Price: $" << share_val
		 << "  Total Worth: $" << total_val << '\n';
}
```

to the following C-style definition:

```C++
void show(const Stock * this)
{
	cout << "Company: " << this->company
		 << "  Shares: " << this->shares << '\n';
		 << "  Share Price: $" << this->share_val
		 << "  Total Worth: $" << this->total_val << '\n';
}
```


## Class Scope

C++ classes introduce a new kind of scope: class scope. All names defined in a class have _class scope_. Thus, **you can use the same class member names in different classes without conflict**.

Also class scope means you can't directly access members of a class from the outside world. This is true even for public function memebers. That is, to invoke a public member function, you have to use an object:

```
Stock sleeper("Exclusive Ore", 100, 0.25);
sleeper.show();
```

Similarly, you have to use the scope-resolution operator when you define member functions:

```
void Stock::update(double price)
{
	...
}
```

Within a class declaration **or a member function definition** you can use an _unqulified name_. A constructor name is recognized when it is called because its name is the same as the class name. Otherwise, **you must use the direct membership operator (.), the indirect membership operator (->), or the scope-resolution operator(::), depending on the context**. The following code fragment illustrates how identifiers with class scope can be accessed.

```C++
class Ik
{
private:
	int fuss; 		// fuss has class scope
public:
	Ik(int f = 0) { fuss = f; } // fuss is in scope
	void ViewIk() const; // ViewIk has class scope
};

void Ik::ViewIk const // Ik:: places ViewIk into Ik scope
{
	cout << fuss << endl;	// fuss in scope within class methods
}
...
int main(void)
{
	Ik * pik = new Ik;
	Ik ee = Ik(8); // constructor in scope because has class name
	ee.ViewIk(); // class object brings ViewIk into scope
	pik->ViewIk(); // pointer-to-Ik brings ViewIk into scope
}
```

### Class Scope Constants

Suppose you would like to define a constant in a class. You may think the following would be a solution:

```C++
class Bakery
{
private:
	const int Months = 12;		// declares a constant? FAILS
	double costs[Month];
	...
};
```

**This won't work** because declaring a class describes what an object looks like but doesn't create an object. Hence, until you create an object, **there's no place to store a value**.
There are, however, a couple ways to achieve essentially the same desired effect.

First, you can declare an enumeration within a class that provides **symbolic names** for integer constants. An enumeration given in a class declaration has class scope. so you can use enumerations to provide class scope symbolic names for integer constants. That is, you can start off the `Bakery` declaration this way:

```
​class Bakery
{
private:

enum {Months = 12};
double costs[Months];
...

}
```

Note that declaring an emumeration in this fashion **does not create a class data member**. That is, each individual object does **not** carry an enumeration in it. Rather, `Len` is just a symbolic name that the **compiler** replaces with `30` when it encounters it in code in class scope.

Incidentally, for many implementations, the `ios_base` class does something similar in its public section; that's the source of identifiers such as `ios_base::fixed`. Here `fixed` is typically an enumerator defined in the `ios_base` class.

C++ has a second way of defining a constant within a class---using the keyword `static`:

```
class Bakery
{
private:
	static const int Months = 12;
	double costs[Months];
	...
};
```

This creates a single constant called  `Months` that is stored with other static variable **rather than in an object**. Thus, there is only one `Month` constant shared by all `Bakery` objects. In C++ 98 you can use this technique only for declaring static constants with integral and enumeration values. C++11 removes that restriction.

### Scoped Enumerations (C++11)

Suppose you were working on a project involving eggs and T-shirts. You might try something like this:

```
enum egg {Small, Medium, Large, Jumbo};
enum t_shirt {Small, Medium, Large, Xlarge};
```

This won't fly because the `egg Small` and the `t_shirt Small` would both be in the same scope. C++ provides a new form of enumeration that avoids this problem be **having class scope for its enumerators**. The declarations for this form look like this:

```
enum class egg {Small, Medium, Large, Jumbo};
enum class t_shirt {Small, Medium, Large, Xlarge};
```

Alternatively, you can use the keyword `struct` instead of class. In either case, you now need to use the `enum` name to qualify the enumerator:

```C++
egg choice = egg::Large;
t_shirt Floyd = t_shirt::Large;
```

Now that the enumerators have **class scope**, enumerators from different `enum` definitions no longer have potential name conflicts.

C++11 also tightens up type security for scoped enumerations. Regular enumerations get converted to integer types automatically in some situation, such as assignment to an `int` variale or being used in a comparison expression. but **scoped enumerations have no implicit conversions to integer types**:

```C++
enum egg_old {Small, Medium, Large, Jumbo};
enum class t_shirt {Small, Medium, Large, Xlarge};
egg_old one = Medium;
t_shirt rolf = t_shirt::Large;
int king = one;
int ring = rolf; // not allowed
if (king < Jumbo); // allowed
if (king < t_shirt::Medium) // not allowed
```

But you can do an explicit conversion if you feel you have to:

```C++
int Frode = int(t_shirt::Small);
```


Enumerations are represented by some underlying integer type, and under C++98 that choice was implementation-dependent. C++11 removes that dependency for **scoped enumerations**. By default, the underlying type for C++11 scoped enumerations is `int`. Furthermore, there's a syntax for indicating a different choice:

```
enum class : short pizza {Small, Medium, Large, XLarge};
```

The `: short` specifies the underlying type to be `short`. The underlying type has to be an integer type. Under C++11, you can also use this syntax to indicate the underlying type for an unscoped enumeration, but if you don't choose the type, the choice the compiler makes is implementation-dependent.

## Program Exercise

Common mistakes: forgeting `const` forgeting using class name to precede definition header.

