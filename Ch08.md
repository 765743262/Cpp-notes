# Chapter 8

## Content

* Inline functions
* Reference variables
* Pass argument by reference
* Default arguments
* Function overloading
* Function templates
* Function templates specializations

## Inline Functions

The difference between normal and inline functions is how compiler incorporates them:

* Normal functions:

	The program will jump to the function's address and then jump back.

	This includes:

	* Reach call
	* Stores memory address of instructions *following* the call
	* **Copy function arguments** to the stacks
	* Jump to the address of function and execute
	* Jump back.

* Inline functions:
	
	The compiler put the compiled code in the program. So we do not need to jump back and forth.

**A disavantage:**

Comes with a memory penalty if an inline function is called at several locations.

To use inline, you must take at least two actions:

* Preface the function declaration with the keyword inline
* Preface the function definition with the keyword inline.

C's macros are not real functions. **Always** convert a macro to an inline function if you can.

## Reference Variables

### Creating a Reference Variable

"**Reference**" is a type. So "**reference variable**" makes sense.

The main use is as a formal argument.

**Declaration:**
		
	int rats;
	int & rodents = rats;

Note you place "&" just as how you will place a "*".

**NOTE: YOU MUST INITIALIZE A REFERENCE VARIABLE WHEN YOU DECLARE IT**, code like

	int rat;
	int & rodent;
	rodent = rat;

isn't allowed.

### References as Function Parameters

* **Passing by reference**:
  
  Allows a called function to access variables in the calling function.

* Passing by value:
  
  Just make a copy of that variable.

A function using reference as arguments may look like this:

	void swap(int & a, int & b);

And to use, you use:
	
	int first, second;
	swap(first, second);

Note passing by value and passing by reference may look identical. The **only** way to distinguish them is to look at the prototype or the definition.

### Reference Properties and Oddities

Functions that pass by value can use many kinds of actual argument like expressions. But this is not the case for contemporary C++.

But in early years of C++, 

	refcude(x + 3.);

is allowed. This will create a temporary, nameless variable with the value of x + 3.0. Then ra becomes a reference to that variable.

#### Temporary Variables, Reference Arguments, and const

Currently, a temporary variable can be permitted **only when the argument is a const reference.**

Provided that the reference parameter is a const (**and only in this case the following two applies**):

* When the actual argument is the corret type but not lvalue. **Non-const variable IS of correct type**
* When the actual argument is the wrong type, but it's of a type that can be converted to correct type

**Note:**

* Lvalue: all variables with an address. Const variables are non-modifiable lvalue.
* Non-lvalue: literal constants, expressions.

Consider codes:

	double side = 3.0;
	long edge = 5L;
	double refcude(double & d);

	double(side);
	double(edge);
	double(side + 10.0);

The latter two are the cases. But note double(side) is a exact match.

Note what compiler do: create a temporary and anonymous variable and **makes ra refer to it**.

The reason why **only this is okey for constant reference** is non-const reference is for modification, but a temporary variable cannot achieve that.

So in short, temporary variable is created when parameter is const reference and the argument isn't an lvalue or of the wrong type.

* refcube(a_long_variable);
* refcube(3.0 + x);

Const: const parameter accepts both non-const and const argument as exact match.

### Using References with a Structure

Suppose a structure definition:

	struct free_throws
	{
		std::string name;
		int made;
		int attempts;
		float percent;
	};

Then a function using a reference could be prototyped as follows:
	
	void set_pc(free_throws & ft);

Note we replace built-int types like int with "free_throws".

We can return a reference to the structure: 

	free_throws & accumulate(free_throw & target, const free_throw & source);

In the return statement, we just return the variable we want to refer to. In this case
the function call can be use as if it were the variable it refer to like:

	display(accumulate(a, b));

or

	accumulate(a, b) = k;
	accumulate(a, b).member
	accumulate(accumulate(a, b), c);

### Why Return a Reference?

This is similar to the difference between passing by value and passing by reference.

Consider
	
	dup = accumulate(team, five);

If accumulate() returns a structre, this could involve copying the entire structure. This is inefficient.

**Note: a function that returns a reference is actually an alias for the referred-to variable.**

### Being Careful About What a Return Reference Refers To

**NEVER return a reference to a temporary variable.**

There are two ways to avoid this:

1. Return a reference that was passed as an argument to the function.
2. Use new to create new storage.

One example of the second way:

	const free_throw & clone(free_throws & ft)
	{
		free_throw * ft = new free_throw;

		*pt = ft;
		return *pt;
	}

Note *pt is a lvalue so it can be assign to a reference variable.

Then you can use this function like:

	free_throw & jolly = clone(three);

**Remeber to use delete to free momery allocated.**

### Why Use const with a Reference Return?

Regular return types are _rvalues. Non-const reference return types are modifiable lvalues. Const reference are non-modifiable lvalues.

Also note in the prototype, first argument isn't const but the second is.

### Using References with a Class Object

**The usual C++ practice for passing class objects to a function is to use references.**

Look at an example:

**Listing 8.7 strquote.cpp**

	#include <iostream>
	#include <string>
	// Because we use string in the prototype, this is necessary
	using namespace std;
	string version1(const string &s1, const string &s2);
	// Return string reference such that you can use function as a string variable
	const string & version2(string & s1, const string & s2);
	const string & version3(string & s1, const string & s2);

	int main(void)
	{
	    string input;
	    string copy;
	    string result;

	    cout << "Enter a string: ";
	    // Getline will discard the newline character
	    getline(cin, input);
	    copy = input;
	    cout << "Your string as entered: " << input << endl;
	    result = version1(input, "***");
	    cout << "Your string enhanced: " << result << endl;
	    cout << "Your original string: " << input << endl;

	    result = version2(input, "###");

	    cout << "Your string enhanced: " << result << endl;
	    cout << "Your original string: " << input << endl;

	    cout << "Resetting original string.\n";
	    input = copy;
	    result = version3(input, "@@@");
	    cout << "Your string enhanced: " << result << endl;
	    cout << "Your original string: " << input << endl;

	    return 0;
	}

	string version1(const string & s1, const string & s2)
	{
	    string temp;

	    temp = s2 + s1 + s2;

	    // This is save because we actually return a copy of temp
	    return temp;
	}

	const string & version2(string & s1, const string & s2)
	{
	    // s1 is changed
	    s1 = s2 + s1 + s2;
	    // Safe bacause s1 exists in the calling routine
	    return s1;
	}

	const string & version3(string & s1, const string & s2)
	{
	    string temp;

	    temp = s2  + s1 + s2;

	    // Unsafe to return reference to local variable
	    return temp;
	}

We can use

	string version4(string s1, string s2);

instead but using references is more efficient.

The return type of version 1 is string. But if we return a string &, it will be an error.

### Passing a C-Style String Argument to a string Object Reference Parameter

You may notice in _version1()_ both formal parameters are type _const string &_, but the actual arguments are type _string_ and _const char *_.

Note, "fdsfaf" is always a C-style not string object.

So two things are going on here:

1. String class defines a char *-to-string conversion, which make it possible to ** initialize a string object to a C-style string like

	string greeting = "Hi";

2. Because of the property of const reference formal parameter, the type doesn't match but can be converted. Then the program **created a temporary string variable and converted the C-style string.**

   Thus, **a const string & type can hangdle a char * or const char * in this function.

The convenient outcome of this is that if the formal parameter is type const string &, the actual argument used in the function call can be a string object or a C-style string.

### Another Object Lesson: Objects, Inheritance, and References

You may have notice that the ofstream type can use ostream methods. The alnguage feature that makes it possible is _inheritance_. In this case

* _ostream_ is a _base class_;
* _ofstream_ is a derived class_

We say **a derived class inherits the base class methods**, which means that an ofstream object can use base class features such as precision() and setf() formating methods.

Another aspect of inheritance is that **a base class _references_ can refer to a derived class object without requiring a type cast**. (Because they have the same structure)

The pratical upshot of this is that you can define a function having a base class **reference parameter**(note must be reference), and that function can be used with base class objects and also with derived objects. 

For example, **a function with a type ostream & parameter can accept an ostream object, such as cout, or an ofstream object.**

Listing 8.8

	
In this example, we see os parameter, which is type ostream &, can refer to an ostream object such as cout and to an ofstream object such as fout. And methods can be used for both types.

#### Some Methods

* _setf()_ is a method of ostream class which allows you to set various _formatting states_. The method call _setf(ios_base::fixed) places an object in the mode of using _fixed decimal-point notation_ .
	
  Fixed are designed to specify mode to handle floating numbers. There are three mode:

  * Default(automaticly)
  * Fixed
  * Scientific

  And fixed mode always come along with a precision setting.

* setf(ios_base::showpoint) is also for floating types. It places an object in the mode of showing a trailing decimal point even if the following digits are zeros, like 
	
	19.

* **Providing the object is in _fixed_ mode, precision method can be used to specified the number of figures to be shown to the right of the decimal.

* The _width()_ calls sets _field width_ for the next output action. This setting holds for displaying one value only.

**Summary**: formatting regarding floating numbers holds forever, like setf(ios_base::fixed/showpoint), and precision. But width() holds for one display only.

The file_it() function uses an interseting pair of method call:

	ios_base::fmtflags initial;
	initial = os.setf(ios_base::fixed);
	...
	os.setf(initial);

The setf() method returns a copy of all the formatting settings in effect **before** the call is made. **ios_base::fmtflags is a name for the type needed to store this information.** Then it can be used as an argument to setf() to reset all formatting settings.

One final point: **each object stores its own formatting settings.** That's why we use _objectname.method()_

### When to Use Reference Arguments

There are two main reasons:

* To allow you to alter a data object in the calling funciton
* To speed up a program by passing a reference instead of an entire data object.

#### Making Choices

* Passing data without modification
	* Built-in data object is small, pass by value
	* Otherwise a const must be used

	  Array: const pointer

	  Good-sized structure: const pointer of reference

	  Class object: reference.

* A function modifies data in the calling function:
	* Built-in data: pointer **bacause this make the intention more clear**
	*  Array: const pointer

	   Structure: reference of pointer

	   class object: reference










