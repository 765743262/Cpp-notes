# Chapter 11 Working with Classes

In this chapter you will learn about the following:

* Operator overloading
* Friend functions
* Overloading the  `<<` operator for output
* State members
* Using `rand()` to generate random values
* Automatic conversions and type casts for classes
* Class conversion functions

## Operator Overloading

_Operator overloading_ is an example of C++ polymorphism.

C++ lets you to extend operator overloading to user-defined types. The compiler **uses the number and type of operands to determine which definition of addition to use**.

You can define a class that represents arrays and that overloads the `+` operator so that you can do this:

```C++
evening = sam + janet;
```

The simple addition conceals the mechanics and emphasizes **what is essential**.

To overload an operator, you use a speicial function form called an _operator function_. **An operator function has the following form, where `_op_` is the symbol being overloaded**:

``` C++
opearator_op_(argument-list)
```

For example, `operator+()` overloads the `+` operator. **The `op` has to be valid C++ operator; you can't just make up a new symbol like @**. But the `operator[]()` function  would overload the `[]` operator because `[]` is the array-indexing operator.

Suppose you define an `operator+()` member function, then statement like

```C++
district2 = sid + sara;
```

may be replaced by

```C++
district2 = sid.operator+(sara);
```

## Time on Our Hands: Devoloping an Operator Overloading Example

Suppose you need a class to perform time addtion, you may have the following class declaration and method definition:

Listing 11.2


``` C++
class Time
{
private:
	int hours;
	int minutes;
public:
	Time();
	Time(int h, int m = 0);
	
	Time Sum(const Time & t) const;
	Time operator+(const Time & t) const;
	void Show() const;
};

Time::Time()
{
	hours = minutes = 0;
}

// default values should not occur here
Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

// Time Time::Sum(const Time & t) const
Time Time::operator+(const Time & t) const
{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}

void Time::Show() const
{
	std::cout << hours << " hours, " << minutes << " minutes";
}
```

Note we define a regular method version  `Time Sum(const Time & t) const` and an TIme operator version `Time operator+(const Time & t) const`. **Both these functions have exactly same pass-by-value return type, one argument, and the same code**.

Note the return type eas `Time` rather than `Time &` because **`sum` object is a local variable and is destroyed when the function terminates**. Using a `Time` return type means the program constructs a _copy_ of `sum` before destroying it.

You can invoke the `operator+()` method by using the same syntax that `Sum()` uses:

```C++
total = coding.operator+(fixing);
```

or use operator notation

```C++
total = coding + fixing;
```

Note that with the operator notation, **the object to the left of the operator is the invoking object and the object to the right is the one passed as an argument.**

The compiler uses the operand types to figure out what to do:

```C++
int a, b, c;
Time A, B, C;
c = a + b;
C = A + B;
```

You can add more than two objects:

```C++
t4 = t1 + t2 + t3;
```

**In this case, the statement is translated into**:

```C++
t1.operator+(t2.operator+(t2));
```

### Overloading Restrications

Overloaded operator (with some exceptions) **don't necessarily have to be member functions**. However, **at least one operands has to be a user-defined type**. Let's take a closer look at the limits:

* You can't create new operator symbols like `**`.
* The overloaded operator must have at least one operand that is user-defined type.
* You can't use an operator in a manner that violates the syntax rules for the original operator. For example, **you can't overload the modulus operator (%) so that it can be used with a single operand**.
* You cannot overload the following operators:

  ```C++
  sizeof
  .
  .*
  ::
  ?:
  typeid
  const_cast
  dynamic_cast
  reinterpre_cast
  static_cast
  ```

* Most of the operators in Table 11.1 can be overloaded by using **either member or nonmember functions**. However, you can use **_only_ member functions to overload the following operators**:

  ```C++
  =
  ()
  []
  ->
  ```

  Table 11.1 is omiited.

In addition to these formal restrictions, you should use sensible retraint in overloading operators. For example, you shouldn't use * operator so that is swaps the data member of two  `Time` object. Nothing in the notation would suggest what the operator did, so it would better to define a class method with an explanotory name such as `Swap()`.

### More Overloaded Operators

We introduce subtraction and multiplication by a factor:

```C++
Time operator-(const Time & t) const;
Time operator*(double n) const;

Time Time::operator-(const Time & t) const
{
	Time diff;
	int tot1, tot2;
	tot1 = t.minutes + 60 * t.hours;
	tot2 = minutes + 60 * hours;
	diff.minutes = (tot2 - tot1) % 60;
	diff.hours = (tot2 - tot1) / 60;
	return diff;
}
Time Time::operator*(double n) const
{
	Time result;
	long totalminutes = hours * mult * 60 + minutes * mult;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
```

## Introducing Friends

Friends comes in three varieties:

* Friend functions
* Friend classes
* Friend member functions

By makeing a function **a friend to a class**, you allow the function the same access privileges that a member function of the class has. We will only look at the friend functions in this chapter.

The overloaded multiplication operator is that it combines two different types. That cause a problem. You cannont handle the following statement:

```C++
A = 2.75 * B;
```

`2.75` is not a type `Time` object. The compiler cannot replace the expression with a member function call.

One way around this difficulty is to tell everyone that you can onle write `B * 2.75`. This is a **server-friendly, cliend-beware** solution, and that's not what OOP is about.

Because operators can be overloaded using either member of nonmember functions, we consider using a nonmember function:

```C++
Time operator*(double m, const Time & t);
```

This will make the left operand the first argument of the operator function and the right operand the second argument of the function. But it raises a new problem: **nonmember functions can't directly access private data in a class.** There is a special catagory of nonmember functions, called _friends_, that can access private members of a class.

### Creating Friends

* Step 1: Place a prototype **in the class declaration and prefix the declaration with the keyword `friend`:

  ```C++
  friend Time operator*(double m, const Time & t);
  ```

  The prototype has two implications:

  * Although the `operator*()` function is declare in the class declaration, **it is not a member function and isn't invoked by using the membership operator**.
  * Although the `operator*()` functions is not a member function, **it has the same access rights as a member function.**

* Step 2: Write the function definition. Because it is not a member function, **you don't use the `Time::` qulifier**. Also **you don't use the keyword `friend`:

  ```C++
  Time operator*(double m, const Time & t)
  {
      Time result;
      long totalminutes = t.hours * mult * 60 + t.minutes * mult;
      result.hours = totalminutes / 60;
      result.minutes = totalminutes % 60;
      return result;
  }
  ```

With this declaration and definition, the statement:

```C++
A = 2.75 * B;
```

translates to the following:

```C++
A = operator*(2.74, B);
```

In short, **a friend function to a class is a nonmember function that has the same access right as a membe function.**

The friends function doesn't deviate from the OOP approach because only a class declaration can decide which functions are friends, so the class declaration still controls which functions access private data. In short, **class methods and friends are simply two different mechanisms for expressing a class interface**.

Actually, you can write this particular friend function as a non-friend function:

```C++
Time operator*(double m, const Time & t)
{
	return t * m;
}
```

There are reasons two make this version a friend:

* A friend version ties the function in as part of the official class interface.
* If you later find a need for the function to access private data, you only have to alter the definition rather than the prototype.

### A Common Kind of Friend: Overloading the << Operator

You can overloaded the `<<` operator so that you can use it with cout to display an object's contents like:

```C++
cout << trip;
```

Actually << is already heavily overloaded. `ostream` class includes an overloaded `operator<<()` definition for each of the basic types.

One way to teach `cout` to recognize a `Time` object is to add a new function operator definition to the `ostream` class declaration. But that's a dangerous idea. Instead, use the `Time` class declaration to teach the `Time` class how to use `cout`.

#### The First Version of Overloading <<

To teach the `Time` class to use `cout`, **you must use a friend function**. That's because if you use a `Time` member function to overload <<, **the `Time` object would come first. That means you would have to sue the << operator this way:

```C++
trip << cout
```

which is confusing.

By using a friend function, you can overloaded the operator this way:

```C++
void operator<<(ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
}
```

This lets you use

```C++
cout << trip;
```

> ##### Friend or No Friend?
> You should note that `operator<<()` function is a friend to the `Time` class but not a friend to the `ostream` class. That's because it accessed individual members of the `Time` object but only uses the `ostream` object as a whole. It accesses private `Time` object members directly, but it does not directly access private `ostream` object members.

Note that the function **must use the `ostream` reference `os` as its first argument. Because it needs to manipulate the object itself rather that a copy. The second argument is reference for efficiency.

> ##### What? You Don't Know of Any Other `ostream` Object?

> Another `ostream` object is `cerr`, which routes output to the standard error system. Also, `os` can refer to a `ofstream` object.

#### The Second Version of Overloading <<

The second version allow you to combine the redefined << operator with the ones `cout` normally uses:

```C++
cout << "Trip time: " <<  trip << " (Tuesday)\n";
```

By making the operator function return an `ostream` reference:

```C++
ostream & opearator<<(ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
	return os;
}
```

The fact that the return type is `ostream &` and the return value is `os` means the function's return value is just the object passed to it. Thus, you can do:

```C++
cout << "Trip time: " << trip << " (Tuesday)\n";
```

As a point of interest, this version of `operator<<()` also can be used for file output:

```C++
#include <fstream>
...
ofstream fout;
fout.open("savetime.txt");
Time trip(12, 40);
fout << trip;
```

> ##### Tip

> In general, to overload the << operator to display an object of class `c_name`, you use a friend function with a definition in this form:

```C++
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ... ;
	return os;
}
```

The following code illustrate friend version of `operator*()` and `operator<<()`:

Listing 11.10

```C++
class Time
{
private:
	int hours;
	int minutes;
public:
	Time();
	Time(int h, int m = 0);
	Time operator+(const Time & t) const;
	Time operator-(const Time & t) const;
	Time operator*(double m) const;
	friend operator*(double m, const Time & t) { return t * m};
	friend ostream & operator<<(std::ostream & os, const Time & t);
}

std::ostream & operator<<(std::ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
	return os;
}
```

Note we make `operator*()` inline because it's simple.

## Overloaded Operators: Member Versus Nonmember Functions

For many operators, you have a choice between using member functions or non-member functional.

A nonmember version of an overloaded operator function requires as many formal parameters as the operator has operands. A member version requires **one fewer parameter** because one operand is passed implicitly as the invoking object.

For some operators like `[]`, the member function is the only valid choice. Otherwise it often doesn't make much difference. Depending on the class design, the nonmember function may have an advantage especially if you defined type conversions for the class.

## More Overloading: A Vector Class

Please refer to Listing 11.13.

Listing 11.13 (partial)

```C++
#ifndef vetc_hpp
#define vetc_hpp

#include <iostream>
namespace VECTOR
{
	class Vector
	{
	public:
		enum Mode {RECT, POL};
	private:
		double x;
		double y;
		double mag;
		double ang;
		Mode mode;
		void set_mag();
		void set_ang();
		void set_x();
		void set_y();
	public:
		Vector();
		Vector(double n1, double n2, Mode form = RECT);
		void reset(double n1, double n2, Mode form = RECT);
		~Vector();
		double xval() const {return x;}
		double yval() const {return y;}
		double magval() const {return mag;}
		double angval() const {return ang;}
		void polar_mode();
		void rect_mode();
	// operator overloading
		Vector operator+(const Vector & b) const;
		Vector operator-(const Vector & b) const;
		Vector operator-() const;
		Vector operator*(double n) const;
	// friends
		friend Vector operator * (doublen , const Vector & a);
		friend std::ostream & operater<<(std::ostream & os, const Vector & v);

	};
}

#endif /* vetc_hpp */

//
//  vetc.cpp
//  Listing 11.13
//
//  Created by lin on 04/09/2017.
//  Copyright © 2017 lin. All rights reserved.
//

#include "vetc.hpp"
#include <cmath>
#include "vect.h"
using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VEVTOR
{
	const double Rad_todeg = 45.0 / atan(1.0)

	void Vector::set_mag()
	{
		mag = sqrt(x * x + y * y);
	}

	void Vector::set_ang()
	{
		if (x == 0 && y == 0)
			ang = 0.0;
		else
			ang = atan2(y, x);
	}

	void Vector::set_x()
	{
		x = mag * cos(ang);
	}

	void Vector::set_y()
	{
		y = mag * sin(ang);
	}

	Vector::Vector()
	{
		x = y = mag = ang = 0.0;
		mdoe = RECT;
	}

	Vector::Vector(double n1, double n2, Mode form)
	{
		mode = form;
		if (form = RECT)
		{
			x = n1;
			y = n2;
			set_mag();
			set_ang();
		}
		else if (form = POL)
		{
			mag = n1;
			ang = n2 / Rad_to_deg;
			set_x();
			set_y();
		}
		else
		{
			cout << "Incorrect 3rd argument to Vector() -- ";
			cout << "vecotr set to 0\n";
			x = y = mag = ang = 0.0;
			mode = RECT;
		}
	}

	void Vector::reset(double n1, double n2, Mode form)
	{
		mode = form;
		if (form = RECT)
		{
			x = n1;
			y = n2;
			set_mag();
			set_ang();
		}
		else if (form = POL)
		{
			mag = n1;
			ang = n2 / Rad_to_deg;
			set_x();
			set_y();
		}
		else
		{
			cout << "Incorrect 3rd argument to Vector() -- ";
			cout << "vecotr set to 0\n";
			x = y = mag = ang = 0.0;
			mode = RECT;
		}
	}

	Vector::~Vector()
	{
	}

	void Vector::polar_mode()
	{
		mode = POL;
	}

	void Vector::rect_mode()
	{
		mode = RECT;
	}

	Vector Vector::operator+(const Vector & b) const
	{
		return Vector(x + b.x, y + b.y);
	}

	Vector Vector::operator-(const Vector & b)
	{
		return Vector(x - b.x, y - b.y);
	}

	Vector Vector::operator-() const
	{
		return Vector(-x, -y);
	}

	Vector Vector::operator*(double n) const
	{
		return Vector(x * n, y * n);
	}

	Vector operator*(double n, const Vector & a)
	{
		return a * n;
	}

	std::ostream & operator<<(std::ostream & os, const Vector & v)
	{
		if (v.mode == Vector::RECT)
			os << "(x, y) = (" << v.x << ", " << v.y << ")";
		else if (v.mode == Vector::POL)
		{
			os << "(m, a) = (" << v.mag << v.ang * Rad_to_deg << ")";
		}
		else
			os << "Vector object mode is invalid";
		return os;
	}

}

```

Features:

* **Has two representation for a vector at the same time**
* Puts the whole class in a namespace `VECTOR`
* Uses `enum` to create two constants (RECT and POL)
* Public portion appear first and last
* `set` series functions are all `const`

Note the `reset()` method isn't needed. It can be replaced with constructor like:

```C++
shove = Vector(100, 300);
```

But this will create and assign a temporary object, which is not so effiecient.

We'll look at some of the features in more detail.
### Using a State Member

The Vector class uses a _state member_ called `mode` to control which form the constructor, the `reset()` method, and he overloaded `operator<<()` function use with the enumerations `RECT` and `POL`.

The identifier has class scope. The fully qualified name is `VECTOR::Vector::POL`.

Note that the constructor delivers a warning if something other than `RECT` or `POL` is specified. But actually, an integer like 2 can't implicitly be converted to an `enum` type.

**Because `operator<<()` is a friend function and **not part of the class scope**, it has to use `Vector::RECT` insead of `RECT`.

> ##### Multiple Representations and Classes

> Quantities that have different, but equivalent, representations are common. First, you can store multiple representations in one object. Second, **you can writed the class functions so that assigning values for one representation automatically assigns values fo the other representation.**

### Overloading Operators for the `Vector` Class

Adding two vectors is very simple. So **you might be tempted to use this code**:

```C++
Vector Vector::operator+(const Vector & b) const
{
	Vector sum;
	sum.x = x + b.x;
	sum.y = y + b.y;
	return sum;
}
```

First note **we can access private members in b because it's in the same class.

This would be fine if the object stores only the x and y components. But this version fails to set the polar values. You could fix this by adding more code:

```C++
Vector Vector::operator+(const Vector & b) const
{
	Vector sum;
	sum.x = x + b.x;
	sum.y = y + b.y;
	sum.set_mag();
	sum.set_mag();
	return sum;
}
```

But **it is much simpler and more reliable to let a constructor do the work:

```C++
Vector Vector::operator+(const Vector & b)
{
	return Vector(x + b.x, y + b.y);
}
```

This way, you guaranteed that the new `Vector` object is created according to the **standard rules you lay down in the constructor**.

> ##### Tip

> **If a method needs to compute a new class object, you should see if you can sue a class constructor to do the work. Not only does that save you trouble, it ensures that the new object is constructed in the proper fashion.**

#### Mutiplication

As with overloaded addition, the code lets a constructor create the correct `Vector` object from the new x and y components:

```C++
Vector Vector::operator*(double n) const
{
	return Vector(n * x, n * y);
}
```

And as in the `Time` example, you can use an inline friend function to handle `double` times `Vector`:

Vector operator*(double n, const Vector & a)
{
	return a * n;
}

#### More Refinement: Overloading an Overloaded Operator

You can define both binary and unary versions of the `-` operator because C++ provides both binary and unary versions of that operator to begin with:

```C++
Vector operator-(const Vector & b) const;
Vector Vector::operator-(const Vector & b) const 
{
	return Vector(x - b.x, y - b.y);
}

Vector operator-() const;
Vector Vector::operator-() const
{
	return Vector(-x, -y);
}

> ##### Note

> **You can overload the same operator many times as long as each operator function has a distinct signature and as long as each operator function has the same number of operands as the corresponding built-in C++ operator.**

### An Implementation Comment

You have two ways to implement these two representations, but the public interface doesn't depend on this. 

Storing the data means that the object occupies more memory and the code has to be careful to update both datas. But data look-up is faster.

Which is better depends on how often these two representations are used. **You would choose one implementation in one program and the second implementation in another, yet retain the same user interface for both.**

### Taking the `Vector` Class on a Random Walk

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "vect.hpp"
int main(void)
{
	using namespace std;
	using VECTOR::Vector;
	srand(time(0));
	double direction;
	Vector step;
	Vector result(0.0, 0.0);
	unsigned long steps = 0;
	double target;
	double dstep;
	cout << "Enter target distance (q to quit): ";
	while (cin >> target)
	{
		cout << "Enter step length: ";
		if (!(cin >> dstep))
			break;
		while (result.magval() < target)
		{
			direction = rand() % 360;
			step.reset (dstep, direction, Vector::POL);
			result = result + step;
			steps++;
		}
		cout << "After " << steps << " steps, the subject "
			"has the following location:\n";
		cout << result << endl;
		result.polar_mode();
		cout << " or\n" << result << endl;
		cout << "Average outwatd distance step = "
		<< result.magval() / steps << endl;
		steps = 0;
		result.reset(0.0, 0.0);
		cout << "Enter target distance (q to quit): ";
	}

	cout << "Bye!\n";
	cin.clear();
	while (cin.get() != '\n')
		continue;
	return 0;
}
```

The program uses the `result` to keep track of the walker's progress. On each cycle of the inner loop, the program sets the `step` vector to a new direction and adds it to the current `result` vector.

**Incidentally, the following statement has the effect of placing `result` in the `RECT` mode, regardless of the initial mode of `result` and `step`:

```C++
result = result + step;
```

The addition operator creates and returns a **new vector that holds the sum of two arguments.** The function creates the vector by using the default constructor, which creates vectors in `RECT` mode. 

By default, **assignment assigns each member variable individually, so `RECT` is assigned to `result.mode`.**

If you would prefer some other behavior, such as `result` retaining its original mode, you can override default assignment by **defining an assginment operator for the class**.

### Automatic Conversion and Type Casts for Classess

**All conversion is based on constructor**.

An implicit conversion may occur when:

* Initialization
* Assignment
* Passing arguments
* Returning a value
* **When any of the preceding situations use a built-in type that can unambiguously be converted to type `double`

An explicit conversion occur when you explicit indicate the type cast.

**A constructor and only a constructor that _can_ be used with just one argument works as a conversion instruction** like:

```C++
Stonewt(double lbs);
Stonewt(int stn, double lbs = 0);
```

As you can see, constructor with two arguments can be used to convert types as long as it provides a default value for the second parameter. But function like

```C++
Stonewt(int stn, double lbs = 0);
```

cannot serve as a convertor.

Provided such a constructor, you can do following _implicit conversions_:

* Initialization:

	Stonewt mycat = 19.6;

* Assignment:

	Stonewt mycat;
	mycat = 19.6

* Passing arguments:
	
	Stonewt test(Stonewt s);
	test(19.6);

* Returning value:

	Stonewt test(Stonewt s)
	{
		return 19.6;
	}

* Double conversion:

	Stonewt = 90;

**In all these cases, the compiler looks for a `Stonewt(double)` constructor to convert the `double` to desired `Stonewt` type.**

**Failing to find that convertor (the last case), the compiler looks for a constructor with some other built-in types to which an `double` can be converted**. This works only if there is an unambiguous choice. That is, if the class also defined a `Stonewt(long)`, the compiler would reject these statements.

An explicit conversion (type cast) has following forms:

Stonewt myCat;
myCat = Stonewt(19.6);
myCat = (Stonewt) 19.6;

The automatic conversion isn't always desirable because it can led to unexpected conversions. C++ add a new keyword `explicit` to turn off the automatic aspect. You can declare the constructor this way:

```C++
explicit Stonewt(double lbs);
```

This turns off implicit conversions such as the five cases above. But explicit conversions are still valid.

Let's look at an example:

```C++
Listing 11.16

class Stonewt
{
private:
	enum {Lbs_per_stn = 14};
	int stone;
	double pds_left;
	double pounds;
public:
	Stonewt(double lbs);
	Stonewt(int stn, double lbs);
	Stonewt();
	~Stonewt();
	void show_lbs() const;
	void show_stn() const;
};

Stonewt::Stonewt(double lbs)
{
	stone = int (lbs) / Lbs_per_stn;
	pds_left = int (lbs) % Lbs_per_stn + lbs - int(lbs);
	pounds = lbs;
}

Stonewt::Stonewt(int stn, double lbs)
{
	stone = stn;
	pds_left = lbs;
	pounds = stn * Lbs_per_stn + lbs;
}

Stonewt::Stonewt()
{
	stone = pounds = pds_left = 0;
}

Stonewt::~Stonewt()
{
}

// const is necessary for member function
void Stonewt::show_stn() const
{
	cout << stone << " stone, " << pds_left << " pounds\n";
}

void Stonewt::show_lbs() const
{
	cout << pounds << " pounds\n";
}

int main() 
{
	Stonewt incognito = 275;
	Stonewt wolfe(285.7);
	Stonewt taft(21, 8);

	cout << "The celebrity weighted ";
	incognito.show_stn();
	cout << "The detective weighted ";
	wolfe.show_stn();
	cout << "The president weighted ";
	taft.show_lbs();
	incognito = 276.8;
	taft = 325;
	cout << "After dinner, the celebrity weighted ";
	taft.show_lbs();
	cout << "After dinner, the President weighted ";
	taft.show_lbs();
	display(taft, 2);
	cout << "The wrestler weighted even more.\n";
	display(422, 2);
	cout << "No stone left unearned\n";
    return 0;
}

```

Note that when a constructor has a single argument, you can use the following form when initializing a class object:

```C++
Stonewt incognito = 275;
```

This is equivalent to the other two forms shown earlier:

```C++
Stonewt incognito(275);
Stonewt incognito = Stonewt(275);
```

Note the assignments:

```C++
incognito = 276.8;
taft = 325;
```

Because it uses the constructor, this assignment **also sets the `stone` and `pds_left` members of the class.** And the second assignment converts a type `int` value to type `double` and then uses `Stone(double)` to set all three member values in the process.

### Conversion Functions

We've introduce how to convert a number to a `Stonewt` object. We can do the reverse like:

```C++
Stonewt wolfe(285.7);
double host = wolfe;
```

We do this not by using construtors. **Constructors only provide for **converting another type to the class type**. To do the reverse, we have to use a special form of a C++ **operator function called a _conversion function_**.

By using this operator function, you can do the same explicit and implicit conversion like:

```C++
Stonewt wolfe(285.7);
double host = double (wolfe);
double thinker = (double) wolfe;

Stonewtwells(20, 3);
double star = wells; // implicit use of conversion function
```

The compiler, noting that the different types, **looks to see if you've defined a conversion function that matches this description.**

To convert a type `typeName`, you use a conversion function in this form:

```C++
operator typename();
```

Note the following points:

* The conversion function **must be a class method. (like constructors)** 
* The conversion function **must not specify a return type. (like constructors)**
* The conversion function **must have no arguments (like member unary operators)**

For example, a function to convert to type `double` would have this prototype:

```C++
operator double();
```

The `typename` part tells the conversion the type to which to convert, so no return type is needed. The fact that the function is a class method means it has to be invoked by a particular class object, and tells the function which value to convert. Thus, the function doesn't need argument.

Listing 11.19

```C++
operator int() const;
operator double() const;

Stonewt::operator int() const
{
	return int (pounds + 0.5);
}

Stonewt::operator double() const
{
	return pounds;
}
```

Note the `int` conversion definition rounds to the nearest integer rather than truncating.

#### Applying Type Conversions Automatically

Suppose you've defined a conversion function:

```C++
operator double();
```

Then the following statement works:

```C++
cout << poppins;
```

But if you define both `operator double()` and `operator int()`, this will be an error because nothing in the statement indicates what type to use.

In the following example, the first statement works but the second does not for the same reason:

```C++
double a = poppins
long gone = poppins
```

In C++98, the keyword `explicit` **doesn't work with conversion functions**, but C++11 removes that limitation. Now, you can declare a conversion operator as explicit:

```C++
class Stonewt
{
	...
	explicit operator int() const;
	explicit operator double() const;
}
```

Another approach is to replace a conversion function with a regular nonconversion function like:

```C++
int Stonewt::Stone_to_Int() {return int (pounds + 0.5); }
```

In summary, C++ provides the following type conversions for classes:

* **A class constructor** that has but **a single argument** serves as an instruction for converting a value of **the argument type to the class type**. Using `explicit` in the constructor declaration eliminates implicit conversions.

* A special **class member operator function** called a _conversion function_ serves as an instruction for converting _a class object to some other type**. The conversion is a **class member**, has **no declared return type**, has **no arguments**, and is called `operator typeName()`, where `typeName` is the type to which the object is to be converted.

### Conversions and Friends

You can use either a member function or a friend function to overload addition, **but not both**:

```C++
Stonewt Stonewt++operator+(const Stonewt & st) const
{
	return sum(pounds + st.pounds);
} 
```

Or

```C++
Stonewt operator+(const Stonewt & st1, const Stonewt & st2)
{
	return sum(st1.pounds + st2.pounds);
}
```

Suppose we have defined `Stonewt(double)` constructor, given `st` a Stonewt object, `do` a double value, consider the following two cases:

```C++
st + do; // case 1
do + st; // case 2
```

Case 1 will become:

```C++
st.operator+(do);
```

or

```C++
operator+(st, do);

Both will convert `do` to a `Stonewt` object.

By the way, **having an `operator double()` would create confusion** bacause that would create another option interpretation.

Now considering case 2. Member function doesn't work in this case, because only a class object can invoke a member function. **And conversion takes place for member function arguments, not for member function invokers.

The lesson here is that **defining addition as a friend makes it easier for a program to accomadate automatic type conversion**. **The reason is that both operands become function arguments, so function prototyping comes into play for both operands**.

#### Choices in Implementing Addition

Given that you want to add `double` to `Stonewt`, you have to choices.

First, as mentioned, is to define the following as a friend function and have the `Stonewt(double)` constructor handle conversions:

```C++
friend Stonewt operator+(const Stonewt &, const Stonewt &);
```

The second choice is to further overload the addition operator with functions that explicitly use one type `double` argument:

```C++
Stonewt operator+(double x) const;
friend Stonewt operator+(double x, const Stone & s);
```

Each has advantages. The first is more simple, but there will be added overhead in time and memory to invoke the conversion constructor, thus slower. The second makes for a longer program and more work on your part, but it runs a bit faster. Depending on the intensity of use of this addition, you can choose either of them.

## Program Exercises

<< opeator overloading often needs a state member.

Arithmatic operator overloading often return by value rather than by reference.

Enumerators for state is often place in public portion

Functions in class declaration:

* Regular members
* Regular friends
* Constructors
* Destructor
* Operator function: member/friend
* Conversion functions
* I/O

Note: all method(other that friend) implementation header needs ::.

Don't use `friend` keyword in implementation file.
