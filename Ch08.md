# Chapter 8

In this chapter you will learn about the following:

* Inline functions
* Reference variables
* Pass argument by reference
* Default arguments
* Function overloading
* Function templates
* Function templates specializations

## Inline Functions

The difference between normal and **inline functions** is how compiler incorporates them into a program:

* Normal functions:

  The program will jump to the function's address and then jump back.

  This includes:

  * Reach call
  * Stores memory address of instructions *following* the call
  * **Copy function arguments** to the stacks
  * Jump to the address of function and execute
  * Jump back.

* Inline functions:

  The compiler put the compiled code in the program. So we do not need to jump back and forth.


**A disavantage:**

Comes with a memory penalty if an inline function is called at several locations.

To use inline, you must take at least two actions:

* Preface the function declaration with the keyword inline
* Preface the function definition with the keyword inline.

C's macros are not real functions. **Always** convert a macro to an inline function if you can. The following program shows this:

```
#include <iostream>

inline double square(double x) { return x * x; }

int main(void)
{
	using namespace std;
	double a, b;
	double c = 13.0;

	a = square(5.0);
	b = square(4.5 + 7.5);
	cout << "a = " << a << ", b = " << b << "\n";
	cout << "c = " << c;
	cout << ", c squared = " << square(c++) << "\n";
	cout << "Now c = " << c << "\n";
	return 0;
}
```

If you use marco instead, you will get a different result. The problem is macros do pure text substitutions, however `inline` functions behave exactly like real functions.

## Reference Variables

A **reference** is a name that acts as an lias, or an alternative name, for a **previously defined variable**. The main use is for a reference variable is as a formal argument to a function. This way, the function **works with the original data instead of with a copy**.

### Creating a Reference Variable

To make `rodents` an alternative name for the variable `rats`, you could do the following:
​
```
int rats;
int & rodents = rats;
```

Here, `int &` means reference-to-`int`. Note you place `&` just as how you will place a `*` in a pointer declaration. The reference declaration allows you to use `rats` and `rodents` interchangably; both refer to the **same value** and the **same memory location**. Listing 8.2 illustrates the truth of this claim.

```
#include <iostream>

int main(void)
{
	using namespace std;
	int rats = 101;
	int & rodents = rats;	// rodents is a reference

	cout << "rats = " << rats;
	cout << ", rodents = " << rodents << endl;
	rodents++;		// manipulating the same data
	cout << "rats = " << rats;
	cout << ", rodents = " << rodents << endl;

// the same address
	cout << "rats address = " << &rats;
	cout << ", rodents address = " << &rodents << endl;
	return 0;
}
```

As you will see, both `rats` and `rodents` have the same value and the same address. Incrementing `rodents` by one affects both variables. More precisely, the `rodent++` operation increments a single variable for which there are two names.

A reference looks a lot like a pointer. There are differences, though. For one, **it is necessary to initialize the reference when you declare it; you can't declare the reference and then assign it a value later the way you can with a pointer.** Code like

```
int rat;
int & rodent;
rodent = rat;		// No, you can't do this
```

is not allowed. Also, **you cannot change the variable a reference refers to**. In this sense, it is like a `const` pointer (not pointer-to-`const`). Let's say `bunnies` is an `int` variable. Consider the following code:

```
rodents = bunnies;
```

This only changes the value of the variable that `rodents` refers to, which is `rats`. But `rodents` still refers to `rats`.

### References as Function Parameters

Most often, references are used as function parameters, making a variable name in a function an alias for a variable in the calling program. This method of passing arguments is called **passing by reference**.

* **Passing by reference**:

  Allows a called function to access variables in the calling function.

* Passing by value:

  Just make a copy of that variable.

A function using reference as arguments may look like this:

```
void swap(int & a, int & b);
```

To pass references as arguments, you use:
​	
```
int first, second;
swap(first, second);
```

Earlier, I said you should initializa a reference variable when you define it. And this is true with passing by refernce:  function call **initializes its parameter with argument values from the function call**.i 

Note passing by value and passing by reference look identical. The **only** way to distinguish them is to look at the prototype or the definition. Compare the reference version with the following pointer version of `swap` in a function call:

```
swap(&a, &b);
```

This makes the intention clear.

### Reference Properties and Oddities

Listing 8.5 illustrate an important point.

```
#include <iostream>
double cube(double a);
double refcube(double & ra);
int main(void)
{
	using namespace std;
	double x = 3.0;

	cout << cube(x);
	cout << " = cube of " << x << endl;
	cout << refcube(x);
	cout << " = cube of " << x << endl;
	return 0;
}

double cube(double a)
{
	a *= a * a;
	return a;
}

double refcube(double & ra)
{
	ra *= ra * ra;
	return ra;
}
```

The `refcube()` will modify the value of `x` in `main()`. You may ask is it possible to use a `const` reference like

```
double refcube(const double &ra);
```

This is not possible with the code in this example because the compiler will find that it tries to alter the value of `ra` and issue an error. So if you like to write code like `ra *= ra * ra` you must pass the argument by value.

Functions that pass by value can use many kinds of actual argument like expressions. For example, all the following calls are valid:

```
double z = cube(x + 2.0);
z = cube(8.0);
int k = 10;
z = cube(k);
```

Suppose you have an another function with a reference argument:

```
double recube(double & ra);
```

Then a function call like `recube(x + 3.0)` doesn't appear to make sense because the expression `x + 3.0` is not a variable. This will cause an error in contemporary C++.

However in some cases, this is allowed. More specifically, in this cases, a temporary, nameless variable with the value of x + 3.0 will be created. Then `x` becomes a reference to that variable.

#### Temporary Variables, Reference Arguments, and const

Currently, a temporary variable can be created **only if the argument is a const reference.** Let's look at the cases in which C++ does generate temporary variables and why that makes sense.

Provided that the reference parameter is a `const`, the compiler generates a temporary variable in two kinds of situations+

* When the actual argument is the corret type but not lvalue. But note, non-`const` varaibles, if the basic type matches, is of  the correct type.
* When the actual argument is of the wrong type, but it's a type that can be converted to correct type.

Lvalue are all variables that can be referenced by address. `const` variables would be considered lvalues **because they can be accessed by address**. But the regular variable can be further characterized as being a **modifiable lvalue** and the `const` variable as a **non-modifiable lvalue**. Non-lvalue includes literal constants and expressions with multiple terms.

Now return to our example. Suppose you redefine `refcube()` so that it has a constant reference argument:

```
double refcube(const double & ra)
{
	return ra * ra * ra;
}
```


```C++
double side = 3.0;
long edge = 5L;

double c1 =refcube(side);			// ra refers to side
double c2 = refcube(edge);			// ra refers to a  temporary variable

double c3 = refcube(side + 10.0);	// ra refers to a temporary variable
```

In this example, `side` is an exact match to `ra`, so no temporary variable is created and `ra` refers to `side`. The following two statements are the two cases in which a temporary, anonymous variables will be created, and `ra` is refered to them.

Why this is allowed only for `const` arguments? Basically, it is assumed that the intent of functions with non-`const` reference arguments is to modify variables passed as arguments. Situations that create temporary variables thwart that purpose.

Now think about the `refcube()` function. Its intent is merely to use passed values, not to modify them, so temporary variables cause no harm and make the function more **general** in the sorts of arguments it can handle. Therefore, if the declaration states that a reference is `const`, C++ generates temporary varialbes when necessary. In essence, a C++ with a `const` reference formal argument and a nonmatching actual argument **mimics the traditional passing by value behaviour**, guaranteeing that the original data is unalterd and using a temporary variable to hold that value.


> **Note**
> If a function call argument is not an `lvalue` or does not match the type of the corresponding `const` reference parameter, C++ creates an anonymous variable of the correct type, assigns the value of the function call argument to the anonymous variable, and has the parameter refer to that variable.

> Use `const` When You Can
> There are three strong reasons to declare arguments as references to constant data:
> * Using `const` protects you against programming errors that inadvertently alter data.
> * Using `const` allows a function to process both `const` and non-`const` actual arguments, whereas a function that omits `const` in the prototype only can accept non-`const` data
> * Using a `const` reference allows the function to generate and use a temporary variable appropriately
> You should declare formal reference arguments as `const` whenever it's appropriate to do so.

### Using References with a Structure

References work wonderfully with structures and classes. Indeed, **references were introduced primarily for use with these types, not for use with the basic built-int type**.

Suppose we have the following definition of a structure:

```
struct free_throws
{
	std::string name;
	int made;
	int attempts;
	float percent;
};
```

Then a function using a reference could be prototyped as follows:
​
```	
void set_pc(free_throws & ft);	// use a reference to a structure
```

If the intent is that the function doesn't alter the structure, use `const`:

```
void display(const free_throws & ft);	// don't allow changes to structure
```

The program in Listing 8.6 does exactly these things. It also adds an interesting twist by having a function return a reference to the structure.

```
#include <iostream>
#include <string>
struct free_throws
{
	std::string name;
	int made;
	int attempts;
	float percent;
};

void display(const free_throws & ft);
void set_pc(free_throws & ft);
free_throws & accumulate(free_throws & target, const free_throws & source);

int main(void)
{
	free_throws one = {"one", 13, 14};
	free_throws two = {"two", 10, 16};
	free_throws three = {"three", 7, 9};
	free_throws four = {"four", 5, 9};
	free_throws five = {"five", 6, 14};
	free_throws team = {"team", 0, 0};

	free_throws dup;

	set_pc(one);
	display(one);
	accumulate(team, one);
	display(team);
// use return value as argument
	display(accumulate(team, two));
	accumulate(accumulate(team, three), four);
	display(team);
// use return value in assignment
	dup = accumulate(team, five);
	std::cout << "Displaying team:\n";
	display(team);
	std::cout << "Displaying dup after assignment:\n";
	display(dup);
	set_pc(four);
	accumulate(dup, five) = four;
	std::cout << "Displaying dup after ill-advised assignment:\n";
	display(dup);
	return 0;
}

void display(const free_throws & ft)
{
	using std::cout;
	cout << "Name: " << ft.name << '\n';
	cout << "  Made: " << ft.made << "\t";
	cout << "Attempts: " << ft.attempts << '\t';
	cout << "Percent: " << ft.percent << '\n';
}

void set_pc(free_throws & ft)
{
	if (ft.attempts != 0)
		ft.percent = 100.0f * float(ft.made) / float(ft.attempts);
	else
		ft.percent = 0;
}

free_throws & accumulate(free_throws & target, const free_throws & source)
{
	target.attempts += source.attempts;
	target.made += source.made;
	set_pc(target);
	return target;
}
```

We can also return a reference to a structure: 

```
free_throws & accumulate(free_throws & target, const free_throws & source)
{
	target.attempts += source.attempts;
	target.made += source.made;
	set_pc(target);
	return target;
}
```

Note that the actual return statement looks like this:

```
return target;
```

Nothing in this statement indicates that a reference is being returned. That information comes from the function header (and also from the prototype). If the return type were declared `free_throws` instead of `free_throw &`, the same return statement would return a copy of `target`. But the return type is a reference, so that means the return value is a reference to `target`.

If the return type is a reference, the function call can be use as if it were the variable it refers to. All the following statements are valid:

```
display(accumulate(a, b));
accumulate(a, b) = k;
accumulate(a, b).member
accumulate(accumulate(a, b), c);
```

### Why Return a Reference?

This is similar to the difference between passing by value and passing by reference. Consider the follwing:
​	
```
dup = accumulate(team, five);
```

If `accumulate()` returns by value, this could involve copying the entire structure to a temporary location and them copying the copy to `dup`. But with a reference return value, `team` is copied directly to `dup`, a more efficient approach.

> **Note**
> A function that returns a reference is actually an alias for the referred-to variable.

### Being Careful About What a Return Reference Refers To

**NEVER return a reference to a temporary variable.**

There are two ways to avoid this:

1. Return a reference that was passed as an argument to the function.
2. Use new to create new storage.

One example of the second way:

```
const free_throw & clone(free_throws & ft)
{
	free_throw * ft = new free_throw;
	*pt = ft;
	return *pt;
}
```

Note `pt` is a lvalue so it can be assigned to a reference variable.

Then you can use this function like:

	free_throw & jolly = clone(three);

**Remeber to use delete to free momery allocated.**

### Why Use `const` with a Reference Return?

Recall that we can do the following:

```
accumulate(dup, five) = four;
```

Why does this statement compile? Assignment requires a modifiable lvalue on the left. In this case, the function returned a reference to `dup`, which is a modifiable lvalue.

Regular return types, on the other hand are **rvalues**, values, values can't be accessed by address. But why? It's because the return value, you'll recall, resides in a temporary memory location that doesn't necessarily persist even until the next statement.

Suppose you want to use a reference return value, but don't want to permit behavior such as assigning a value to `accumulate()`, just make the return type a `const` reference:

```
const free_throws accumulate(free_throws & target, const free_throws & souce);
```

The return type now is `const`, hence a nonmodifiable lvalue. Therefore, the assignment no longer is allowed:

```
accumulate(dup, five) = four;
```

Then since the reference is `const`, you can no longer pass it to a function with a non-`const` argument. But you could still pass it as a `const` reference, and of course you can still use `accumulate()` on the right side of an assignment statement.

### Using References with a Class Object

**The usual C++ practice for passing class objects to a function is to use references.** For instance, you would use reference parameters for functions taking objects of the `string`, `ostream`, `istream`, `ofstream` and `ifstream` classes as arguments.

Let's look at an example that uses the `string` class and illustrates some different design choices, some of them are bad.

```
#include <iostream>
#include <string>
// Because we use string in the prototype, this is necessary
using namespace std;
string version1(const string &s1, const string &s2);
// Return string reference such that you can use function as a string variable
const string & version2(string & s1, const string & s2);
const string & version3(string & s1, const string & s2);

int main(void)
{
    string input;
    string copy;
    string result;

    cout << "Enter a string: ";
    // Getline will discard the newline character
    getline(cin, input);
    copy = input;
    cout << "Your string as entered: " << input << endl;
    result = version1(input, "***");
    cout << "Your string enhanced: " << result << endl;
    cout << "Your original string: " << input << endl;

    result = version2(input, "###");

    cout << "Your string enhanced: " << result << endl;
    cout << "Your original string: " << input << endl;

    cout << "Resetting original string.\n";
    input = copy;
    result = version3(input, "@@@");
    cout << "Your string enhanced: " << result << endl;
    cout << "Your original string: " << input << endl;

    return 0;
}

string version1(const string & s1, const string & s2)
{
    string temp;

    temp = s2 + s1 + s2;

    // This is save because we actually return a copy of temp
    return temp;
}

const string & version2(string & s1, const string & s2)
{
    // s1 is changed
    s1 = s2 + s1 + s2;
    // Safe bacause s1 exists in the calling routine
    return s1;
}

const string & version3(string & s1, const string & s2)
{
    string temp;

    temp = s2  + s1 + s2;

    // Unsafe to return reference to local variable
    return temp;
}
```


### Passing a C-Style String Argument to a String Object Reference Parameter

You may notice in `version1()` both formal parameters are type `const string &`, but the actual arguments are type `string` and `const char *`. Two things are going on here:

1. The `string` class defines a `char *`-to-`string` conversion, which make it possible to **initialize a `string` object to a C-style string**  like

```C++
string greeting = "Hi";
```

2. Because of the property of `const` reference as formal parameter, the type doesn't match but can be converted. Then the program **created a temporary string variable and converted the C-style string.**

Thus, a `const string &` type can handle both `char *` and `const char *` in this function.

The convenient outcome of this is that if the formal parameter is type `const string &`, the actual argument used in the function call can be a `string` object or a C-style string.

### Another Object Lesson: Objects, Inheritance, and References

You may have notice that the `ofstream` type can use `ostream methods`. The language feature that makes it possible is _inheritance_. In brief, `ostream` is termed a base class and `ofstream` is termed a **derived** class. We say **a derived class inherits the base class methods**, which means that an ofstream object can use base class features such as `precision()` and `setf()` formating methods.

Another aspect of inheritance is that **a base class _references_ can refer to a derived class object without requiring a type cast**. (Because they have the same structure) The pratical upshot of this is that you can define a function having a base class **reference parameter**(note must be reference), and that function can be used with base class objects and also with derived objects. 

For example, **a function with a type `ostream &` parameter can accept an ostream object, such as `cout`, or an `ofstream` object.**

Listing 8.8 demonstrates this point by using the same function to write data to a file and to display the data onscreen; only the function call argument is changed. The program also uses some formatting methods, which, as promised, work equally well with `cout` and with `ofstream` objects.

```
#include <iostream>
#include <fstream>
#include <cstdlib>
using namespace std;

void file_it(ostream & os, double fo, const double fe[], int n);
const int LIMIT = 5;
int main(void)
{
	ofstream fout;
	const char * fn = "ep-data.txt";
	fout.open(fn);
	if (!fout.is_open())
	{
		cout << "Can't open " << fn << ". Bye.\n";
		exit(EXIT_FAILURE);
	}
	double objective;
	cout << "Enter the focal length of your "
		 << "telescope objective in mm: ";
	cin >> objective;
	double eps[LIMIT];
	cout << "Enter the focal lengths, in mm, of " << LIMIT
		 << "eyepieces:\n";
	for (int i = 0; i < LIMIT; i++)
	{
		cout << "Eyepieces #" << i + 1 << ": ";
		cin >> eps[i];
	}
	file_it(fout, objective, eps, LIMIT);
	file_it(cout, objective, eps, LIMIT);
	cout << "Done\n";
	return 0;
}

void file_it(ostream & os, double fo, const double fe[], int n)
{
	ios_base::fmtflags initial;
	initial = os.setf(ios_base::fixed);
	os.precision(0);
	os << "Focal length of objective: " << fo << " mm\n";
	os.setf(ios::showpoint);
	os.precision(1);
	os.width(12);
	os << "f.l. eyepiece";
	os.width(15);
	os << "magnification" << endl;
	for (int i = 0; i < n; i++)
	{
		os.width(12);
		os << fe[i];
		os.width(15);
		os << int (fo/fe[i] + 0.5) << endl;
	}
	os.setf(initial);
}
```


In this example, we see that the `os` parameter, which is type `ostream &`, can refer to an `ostream` object such as `cout` and to an `ofstream` object such as `fout`. The program also illustrates how `ostream` formatting methods can be used for both types. Let's example these methods.

* `setf()` is a method of the `ostream` class which allows you to set various formatting states. The method call `setf(ios_base::fixed)` places an object in the mode of using fixed decimal-point notation. The E-notaion will not be used. The fixed mode always comes along with a precision setting. 

* `setf(ios_base::showpoint)` is also for floating types. It places an object in the mode of showing a trailing decimal point **even if the following digits are zeros**.

* **Providing the object is in _fixed_ mode**, the `precision()` method can be used to specified the number of figures to be shown to the right of the decimal.

* The `width()` calls sets _field width_ for the next output action. This setting holds for displaying one value only.

**Summary**: formatting regarding floating numbers holds forever, like `setf(ios_base::fixed/showpoint)`, and `precision()`. But `width()` holds for one display only.

The `file_it()` function uses an interseting pair of method call:

```
ios_base::fmtflags initial;
initial = os.setf(ios_base::fixed);
...
os.setf(initial);
```

The `setf()` method returns a copy of all the formatting settings in effect **before** the call was made. **`ios_base::fmtflags` is a name for the type needed to store this information.** Then it can be used as an argument to `setf()` to reset all formatting settings.

One final point: **each object stores its own formatting settings.** That's why we use `objectname.method()`.

### When to Use Reference Arguments

There are two main reasons for using reference arguments:

* To allow you to alter a data object in the calling funciton
* To speed up a program by passing a reference instead of an entire data object.

The second reason is the most important for large data objects, such as structure and class objects. These two reasons are the same reasons you might have for using a pointer argument. So when should you use a reference? Use a pointer? Pass by value? The following are some guidelines.

#### Making Choices

A function uses passed data without modifying it+

* If the data object is small, such as a built-int data type or a small structure, pass it by value.

* Otherwise a `const` must be used:

	* Array: use a  pointer-to-`const` because that's your only choice.

	* Good-sized structure: use a `const` pointer of a `const` reference

	* Class object: use a `const` reference. The sematics of class design often require using a reference, which is the main reason C++ added this feature. Thus, **the standard way to pass class object arguments is by reference**.

A function modifies data in the calling function:

* If the data object is a built-int type, use a pointer **bacause this makes the intention clear.**

* Array: use your only choice: a pointer

* Structure: use a reference or a pointer

* Class object: use a reference

## Default Arguments

A _default argument_ is a **value** that's used automatically if you **omit the corresponding actual argument** from a function call. For example, if you set up `void wow(int n)` so that `n` has a default value of `1`, the function call `wow()` is the same as `wow(1)`. This gives you flexibility in how you use a function.

You must use the prototype to establish a default value. The method is to assign a value to the argument in the prototype:

```
char * left(const char * str, int n = 1);
```

A default value is an initialization value. If you omit `n` in the function call, `n` will be initialized to `1`.

When you use a function with an argument list, you must add defaults from right to left. That is, you can't provide a default value for a particular argument unless you also provide defaults for all the arguments to its right:

```
int harpo(int n, int m = 4, int j = 5);		// valid
int chico(int n, int m = 1, int p);		// invalid
```

For example, the `harpo()` prototype permits calls with one, two, or three arguments:

```
beeps = harpo(2);		// same as harpo(2, 4, 5)
beeps = harpo(1, 8);	// same as harpo(1, 8, 5)
beeps = harpo(8, 7, 6); // no default argumetns used
```

Listing 8.9 puts default arguments to use. Function `left()` returns a pointer to the first `n` characters in a string. Note that only the prototype indicates the default. The function definition is the same as it would be without default arguments.

Listing 8.9 left.cpp

```c++
#include <iostream>
const int ArSize = 80;
char * left(const char * str, int n = 1);
int main(void)
{
	using namespace std;
	char sample[ArSize];
	cout << "Enter a string:\n";
	cin.get(sample, ArSize);
	char * ps = left(sample, 4);
	cout << ps << endl;
	delete [] ps;
	ps = left(sample);
	cout << ps << endl;
	delete [] ps;
	return 0;
}

char * left(const char * str, int n)
{
	if (n < 0)
		n = 0;
	char * p = new char [n + 1];
	int i;
	for (i = 0; i < n && str[i]; i++)
		p[i] = str[i];
	while (i <= n)
		p[i++] = '\0';
	return p;
}
```

Note in this program, we use `cin.get(sample, ARSIZE)` to read a C-style string, which will discard the newline. Also we use `delete [] ps`.

## Function Overloading

_Function polymorphism_, also called _function overloading_ lets you use multiple functions with the same name. The word _Polymorphism_ means having many forms, so _function polymorphism_ lets a function have many forms. Similarly, the expression _function overloading_ means you can attach more that one function to the same name, thus overloading the name.

The key to function overloading is a function's argument list, also called the **function signature**. If two functions use **the same number** and **same types** of arguements in the **same order**, they have the same signature. The variable name doesn't matter. C++ enables you to define two functions by the same name, provided that the functions have different signatures. For example, you can define a set of `print()` functions with the following prototypes:

```
void print(const char * str, int width);	// #1
void print(double d, int width);			// #2
void print(long l, int width);				// #3
void print(int i, int width);				// #4
void print(const char * str);				// #5
```

When you then use a `print()` function, the compiler matches your use to the prototype that has the same signature:

```
print("Pancakes", 15);		// use #1
print("Syrup");				// use #5
print(1999.0, 10);			// use #2
print(1999, 12);			// use #4
print(1999L, 15);			// use #3
```

When you use overloaded functions, you need to be sure you use the proper argument types in the function call. For example, consider the following statements+

```
unsigned int year = 3210;
print(year, 6);
```

It doesn't match any of the functions. A lack of a matching prototype doesn't automatically rule out using one of the functions because C++ will try to use standard type conversions to force match. But in earlier code there are three prototypes that take a number as the first argument, providing three different choices for converting `year`. Faced with this ambiguous situation, C++ rejects the function call as an error.

Particularly, the compiler considers a reference to a type and the type itself to be the same signature. So you cannot overload a function name like

```
double cube(double x);
double cube(double & x);	// no allowed
```

The function-matching does discriminate between `const` and non-`const` varaibles. Consider the following prototypes:

```
double dribble(char * bits);
double dribble(const char * bits);
void dabble(char * bits);
boid drivel(const char * bits);
```

Here's what various function calls would match:

```
const char p1[20] = "How's the weather?";	// const char *
char p2[20] = "How's business?";			// char *
dribble(p1);		// dribble(const char *)
dribble(p2);		// dribble(char *)
dabble(p1);			// no match
dabble(p2);			// debble(char *)
drivel(p1);			// drivel(const char *)
drivel(p2);			// drivel(const char *)
```

The `dribble()` function has two prototypes---one for `const` and one for regular pointers---and the compielr selects one or the other, depending on whether the actual argument is `const`. And you can see a difference in behaviour between `drivel()` and `dabbel()`. The reason is that it's valid to assign a non-`const` value to a `const` variable, but not vice versa.

Keep in mind that the signature, **not the function (return) type**, enables function overloading. For example, the following two declarations are incompatible:

```
long gronk(int n, float n);
double gronk(int n, float m);
```

You can have different return types, but only if the signatures are also different+

```
long gronk(int n, float m):
double gronk(float n, float m);
```


### Overloading Reference Parameters

Consider the following three prototypes:

```
void sink(double & r1); 		// matches modifiable lvalue;
void sank(const double & r2); 	// matches const or modifiable lvalue, rvalue
void sunk(double && r3); 		// matches rvalue
```

Note how `r2` can match the same sort of arguments that `r1` and `r3` match. This raises the question of what happends when you overload a function on these three types of parameters. The answer is that the more exact match is make:

```
void staff(double & rs);			// matches modifiable lvalue
void staff(const double & rcs);		// matches rvalue, const lvalue
void stove(double & r1);			// matches modifiable lvalue
void stove(const double & r2);		// matches const lvalue
void stove(double && r3);			// matches rvalue
```

This allows you to customize the behaviour of a function based on the lvalue, `const`, or rvalue nature of the argument:

```
double x = 55.5;
const double y = 32.0;
stove[x];				// calls stove(double &)
stove[y];				// calls stove(const double &)
stove(x + y);			// calls stove(double && r3)
```


### When to Use Function Overloading

You might find function overloading fascinating, but you shouldn't overuse it. You should reserve function overloading for functions that perform the basically the same task but with different forms of data.

Also you might want to check whether you can accomplish the same end by using default arguments. For example, you could replace the single, string-oriented `left()` function with wo overloaded functions:

```
char * left(const char * str, unsigned n);
char * left(const char * str);
```
But using the single function with a default argument is simpler. However, if you require different types of arguments, default arguments are of no avail, so in that case, you should use functio n overlaoding.

### What is Name Decoration?

The compiler will encrypt function name based on the signature, which is known as name decoration.

## Function Templates

A _function templates_ is a generic function description. It defines a function to handle a _generic type_ for which a specific type, such as `int` or `double`, can be substituted. By **passing a type as a parameter** to a template, you cause the compiler to generate a function for the particular type. This process is sometimes called _generic programming_.

You can set up a swapping template like this:

```
template <typename T>
void Swap(T & a, T & b)
{
	T temp;
	temp = a;
	a = b;
	b = temp;
}
```

The first line specifies that you are setting up a template and that you're naming the arbitrary type `T`. 
The keywords _template_ and _typename_ are obligatory, but in regular function we can choose whatever we like. The type name (`T`, in this example) is your choice.

The template doesn't create any function. Instead, it provides the compiler with directions about how to define a function. If you want a function to swap `int`s, the compiler **creates a function** following the template description, substituting `int` for `T`. 

You can also use `class` instead of `typename`. There are no other choices.

The let the compiler know that you need a particular form of swap function, you just use a function called `Swap()` in your program. The compiler checks the argument types you use and the **generates the corresponding function**. Listing 8.11 shows how this works. Note the program follows the usual pattern for ordinary functions, **with a template function prototype near the top of the file and the template funciton definition following `main()`.

```c++
#include <iostream>
// Template header with space
template <typename T>
void Swap(T &a, T &b); // Prototype

int main(void)
{
    // Because we are using cout
    using namespace std;
    int i = 10;
    int j = 20;

    cout << "i, j = " << i << ", " << j << ".\n";
    cout << "Using compiler-generated int swapper:\n";
    // Send signature (int, int) to template
    Swap(i, j);
    cout << "Now i, j = " << i << ", " << j << ".\n";

    double x = 24.5;
    double y = 81.7;
    cout << "x, y = " << x << ", " << y << ".\n";
    cout << "Using compiler-generated double swapper:\n";
    // Send signature (int, int) to template
    Swap(x, y);
    cout << "Now x, y = " << x << ", " << y << ".\n";
    return 0;
}

template <typename T>
void Swap(T &a, T &b)
{
    T temp;
    temp = a;
    a = b;
    b = temp;
}
```

Note that function templates don't make executable programs any shorter. You still wind up with two separate function definitions. **And the final code doesn't contain any templates; it just contains the actual functions generated.**

### Overloaded Templates

You use templates when you need functions that apply the same algorithm to a variety of types, as in Listing 8.11. It might be, however, that not all types would use the same algorithm. To handle this possibility, you can overload template definitions, just as you overload regular definitions. As with ordinary overloading, overloaded templates need **distinct function signatures**. For example, Listing 8.12 adds new swapping template---one for swapping elements of two arrays. The original template has the signature `(T &, T &)`, whereas the new template has the signature `(T [], T [], int)`.

Listing 8.12

```c++
#include <iostream>
template <typename T>
void Swap(T & a, T & b);

template <typename T>
void Swap(T * a, T * b, int n);

void Show(int a[]);
const int Lim = 8;
int main(void)
{
	using namespace std;
	int i = 10, j = 20;
	cout << "i, j = " << i << ", " << j << ".\n";
	cout << "Using compiler-generated int swapper:\n";
	Swap(i, j);
	cout << "Now i, j = " << i << ", " << j << ".\n";

	int d1[Lim] = {0,7,0,4,1,7,7,6};
	int d2[Lim] = {0,7,2,0,1,9,6,9};
	cout << "Original arrays:\n";
	Show(d1);
	Show(d2);
	Swap(d1, d2, Lim);
	cout << "Swapped arrays:\n";
	Show(d1);
	Show(d2);

	return 0;
}

template <typename T>
void Swap(T & a, T & b)
{
	T temp = a;
	a = b;
	b = temp;
}

template <typename T>
void Swap(T * a, T * b, int n)
{
	for (int i = 0; i < n; i++)
	{
		T temp = a[i];
		a[i] = b[i];
		b[i] = temp;
	}
}

void Show(int a[])
{
	using namespace std;
	cout << a[0] << a[1] << "/";
	cout << a[2] << a[3] << "/";
	for (int i = 4; i < Lim; i++)
		cout << a[i];
	cout << endl;
}
```


### Explicit Specialization

In the example above, we assumed that some operations for type `T` is defined. But this is not always true, especially for user-defined types.

You can supply a specialized function definition, called _explicit specialization_. **If the compiler finds a specilized definition that exactly matches a function call, it uses that defintion without looking for templates.**


#### Third-Generation Specialization (ISO/ANSI C++ Standard)

After some youthful experimentation with other approaches, the C++ 98 Standard settled on this approach:

* For a **given function name**, you can have a non-template function, a template function, and an explicit specialization template function, along with overloaded versions of all of these.
* The prototype and definition for an exaplicit specilization should be preceded by `template <>` and should mention the specialized type by name.
* A specialization overrides the regular template, and a non-template function overrides both.

Here's how prototypes for swapping type `job` structures would look for these three forms:

```
// non template function prototype
void Swap(job &, job &);

// template prototype
template <typename T>
void Swap(T &, T &);

// explicit specialization for the job type
template <> 
void Swap<job>(job &, job &);
```

As mentioned previously, if more than one of these prototypes is present, the compiler chooses non template version over explicit specializations and template versions, and it chooses an explicit specialization over a version generated from a template.

The `<job>` int `Swap<job>` is optional. Thus, the prototype can also be written this way

```
template <typename T>
void Swap(job & a, job & b);
```

Listing 8.13 illustrates how explicit specialization workds.

```
#include <iostream>

template <typename T>
void Swap(T & a, T & b);

struct job
{
	char name[40];
	double salary;
	int floor;
};

// explicit specialization
template <>
void Swap<job>(job & j1, job & j2);
void Show(const job & j);

int main(void)
{
    using namespace std;
	cout.precision(2);
	cout.setf(ios_base::fixed, ios_base::floatfield);
	int i = 10, j = 20;
	cout << "i, j = " << i << ", " << j << ".\n";
	cout << "Using compiler-generated int swapper:\n";
	Swap(i, j);
	cout << "Now i, j = " << i << ", " << ".\n";

	job sue = {"Susan Yaffee", 73000.60, 7};
	job sidney = {"Sidney Taffee", 78060.72, 9};
	cout << "Before job swapping:\n";
	Show(sue);
	Show(sidney);
	Swap(sue, sidney);
	cout << "After job swapping:\n";
	Show(sue);
	Show(sidney);

	return 0;
}

template <typename T>
void Swap(T & a, T & b)
{
	T temp = a;
	a = b;
	b = temp;
}

template <>
void Swap<job>(job & j1, job & j2)
{
	double t1 = j1.salary;
	j1.salary = j2.salary;
	j2.salary = t1;
	int t2 = j1.floor;
	j1.floor = j2.floor;
	j2.floor = t2;
}
void Show(const job & j)
{
	using namespace std;
	cout << j.name << ": $" << j.salary
		 << " on floor " << j.floor << endl;
}
```

Like a template, an explicit specializtion needs a prototype and a definition.

### Initializations and Specilizations

When the compiler uses the template to generate a function definition for a particular type, the result is termed an _instantiation_ of the template. For example, in Listing 8.13, the function call `Swap(i, j)` causes the compiler to generate an instantiation of `Swap()`. This type of instantiation is termed _implicit instantiation_.

Now C++ allows for **explicit instantiation**. The syntax is to declare the particular variety you want, using the `<>` notation to indicate the type and prefixing the declaration with the keyword `template`:

```
template void Swap<int>(int, int);
```

Contrast the explicit instantiation and explicit specialization, which uses declarations:

```
template <> 
void Swap<int>(int &, int &);
template <> 
void Swap(int &, int &);
```

The differences the last two means "**Don't use the general `Swap()` template to generate a function definition**. Instead, use a separate, specialized function definition explicitly defined for the int type." **And explicit specialization prototype have to be coupled with their own definitions.**

Another difference is one uses `<>` after `template` whereas the other omits it.

> **Caution**

> **Caution**
> It is an error to try to use both an explicit instantiation and an explicit specialization for the same types in the same file, or, more generally, the same translation unit.

Explicit instantiation can also be created by using the function in a program. For instance, consider the following:

```
template <class T>
T Add(T a, T b)
{
	return a + b;
}
...
int m = 6;
double x = 10.2;
cout << Add<double>(x, m) << endl;	// explicit instantiation
```

The template would fail to match the function call `Add(x, m)` (an attempt for implicit instantiation) because the template expects both arguments to be same. But using `Add<double>(x, m)` forces the type `double` instantiation, and the argument `m` is type cast to type `double` to match the second parameter of the `Add<double>(double, double)` function.

Implicit instantiations, explicit instantiations, and explicit specializations collectively are termed _specilizations_. What they have in common is that they represent a function defintion that uses specific types rather that one that is a generic description.

## Which Function Version Does the Compiler Pick?

The process is called _overload resolution_. Let's take just a broad look at how the process works:

* Phase 1: Assemble a list of function having the same name.

* Phase 2: Assemble a list of viable functions. These are functions with the correct number of arguments and for which there is an implicit conversion sequence, which includes the case of an exact match.

* Phase 3: Determine whether there is a best viable function. If so, you use that function. Otherwise, the function call is an error.

Consider a case with just one function argument---for example, the following call:

```
may('B');
```
First, the compiler rounds up the suspects, which are the functions and templates that have the name `may()`. Then, it finds those that can be called with one argument. For example, the following pass muster because they have the same name and can be used with one argument:

```
void may(int);					// #1
float may(float, float = 3);	// #2
void may(char);					// #3
char * may(const char *);		// #4
char may(const char &);			// #5
template<class T>				
void may(const T &);			// #6
tempalte<class T>				
void may(T *);					// #7
```

Two of these candidates (#4 and #7) are not viable. That leaves five viable functions, each of which could be used if it were the only function declared.

Next, the compiler has to determine which of the viable functions if best. In general, the ranking from best to worst is this:

1. Exact match, with regular functions outranking templates
2. Conversion by promotion
3. Conversion by standard convertion
4. User-defined conversion

For example, #1 is better than #2 because `char`-to-`int` is a promotion. #3, #5 and #6 are better than either #1 or #2 because they are exact matches. Both #3 and #5 are better than #6 because #6 is a template. This analysis raises a couple questions. What is an exact match? And what happens if you get two of them? Usually, as is the case with this example, two exact matches are an error; but a couple special cases are exceptions to this rule.

**Following text only deals with the cases of exact matches.**

### Exact Matches and Best Matches

First, C++ allows some "trivial conversion" when making an exact match. For example, a `reference` to non-`reference` or the reverse. The most important here is it allows trivial conversions from non-`const` pointers and references to `const` pointers and references. Suppose you have the following function code:

```
struct blot {int a; char b[10];};
blot = intk = {26, "spots"};
...
recycle(ink);
```

In that case, all the following prototypes would be exact match:

```
void recycle(blot);
void recycle(const blot);
void recycle(blot &);
void recycle(const blot &);
```

Sometimes there can be overload resolution even if two functions are an exact match.

First, pointers and references to non-`const` are preferentially matched to non-`const` pointer and reference paramters. That is, if only #3 and #4 were available in the example, #3 would be chosen. However, this descrimination between `const` and non-`const` applies just to data referred to by pointers and references. That is, if only #1 and #2 were available, you would get an ambiguity error.

Another case in which one exact match is better than another is when one function is a non template function and the other isn't. In that case, the non template is considered better than a template, including explicit specialization.

If you wind up with two exact matches that both happen to be template funtions, the template function that is the more specialized, if either, is the better function. For example, an explicit specialization is chosen over one generated implicitly from the template pattern:

```
template <class Type>
void recycle(Type t);
template <>
void recycle<blot>(blot & t);
...
blot ink = {25, "spots"}:
...
recycle(ink);		// use specialization
```

The term **most specialized** doesn't necessarily imply an explicit speicalization. It also indicates that fewer conversions take place. For example, consider the following two templates:

```
template <class Type>
void recycle(Type t);	//#1
template <class Type>
void recycle(Type * t);
```

And the function call:

```
recycle(&ink);
```

It matches both template, but #2 is considered the more specialized because it expects the right "pointer level" the type lies.


### Making Your Own Choices

You can lead the compiler to make the choice you want by suitably writing the function call.

```c++
#include <iostream>

template <class Type>
Type lesser(Type a, Type b)
{
	return a < b ? a : b;
}

int lesser(int a, int b)
{
	a = a < 0 ? -a : a;
	b = b < 0 ? -b : b;
	return a < b ? a : b;
}

int main(void)
{
	using namespace std;
	int m = 20;
	int n = -30;
	double x = 15.5;
	double y = 25.9;

	cout << lesser(m, n) << endl;			// use #2
	cout << lesser(x, y) << endl;			// use #1 with double
	cout << lesser<>(m, n) << endl;			// use #1 with int
	cout << lesser<int>(x, y) << endl;		// use #1 with int

	return 0;
}
```
The angle brackets in `lesser<>(m, n)` indicates that the compiler should choose a template function. And `lesser<int>(x, y)` is a request for an explicit instantiation using `int` for `Type`.

### Template Funcion Evolution

When you write a template function, it's not always possible in C++98 to know what type to use in a declaration. Consider the partial example:
```
template <class T1, class T2>
void ft(T1 x, T2 y)
{
	...
	?type? xpy = x + y;
	../
}
```

The type of `xpy` is unknown. C++11 solution is a new keyword: `decltype`. It can be use this way:

```
int x;
decltype(x) y;
```
Then you can do the following:

```
decltype(x + y) xpy = x + y;
```

What is in the parenthesis can be an expression, function or variable.

If the thing in the parenthesis is an lvalue and is further parenthesized, `xpy` would be a reference.

If you need more than one declaration, you can use `typedef` with `decltype`.

#### Alternative Function Syntax (C++11 Trailing Return Type)

## Chpater Review

Note default argument isn't need in the definiton.

















