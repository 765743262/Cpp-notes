# Chapter 13: Class Inheritance

In this chapter you'll learn about the following:

* Inheritance as an _is-a_ relationship
* How to publicly derive one class from another
* Protected access
* Constructor member initializer lists
* Upcasting and downcasting
* Virtual member functions
* Early (static) binding and late (dynamic) binding
* Abstract base classes
* Pure virtual functions
* When and how to use public inheritance

C++ provides a better method than direct code modification for extending and modifying classes. This method, called _class inheritance_, lets you derive new classes form old ones. Here are some things you can do with inheritance:

* You can add functionality to an existing class.
* You can add to the data the a class repersents.
* You can modify how a class method behaves.

If you purchase a class library that provides only the header files and the compiled code for class methods, you can still derive new classes based on the library classes.

## Beginning with a Simple Base Class

When one class inherits from another, the original class is called a **base class**, and the inheriting class is called a **derived class**. Let's begin with a base class, shown in Listing 13.1 and 13.2.

```C++
// Listing 13.1
class TableTennisPlayer
{
private:
	string firstname;
	string lastname;
	bool hasTable;
public:
	TableTennisPlayer(const string & fn = "none", const string & ln = "none", bool ht = false);

	void Name() const;
	bool HasTable() const { return hasTable;}
	void ResetTable(bool v);
};
```

Listing 13.2

```C++
TableTennisPlayer::TableTennisPlayer (const string & fn, const string & ln, bool ht) : firstname(fn), lastname(ln), hasTable(ht) {}

void TableTennisPlayer::Name() const
{
	std::cout << lastname << ", " << firstname;
}
```

The constructor uses member initializer list syntax. For an object like `firstname`, the copy constructor will be called.

### Deriving a Class

The first step is to have the `RatedPlayer` class declaration show that it derives from the `TableTennisPlayer` class:

```C++
class RatedPlayer : public TableTennisPlayer
{
	...
};
```

The colon indicates that the `RatedPlayer` class is based on the `TableTennisPlayer` class.

The particular heading indicates that `TableTennisPlayer` is a _public base class_; This is termed _public derivation_. With public derivation, the **public members** of the base class become public members of the derived class. The private portions of a base class become part of the derived class, but they can be accessed **only** through public and protected methods of the base class.

A derived class has the following properties:

* An object of the derived type has stored within it the data members of the base type. (The derived class inherits the base-class implementation)
* An object of the derived type can use the methods of the base type. (The derived class inherits the base-class interface)

What needs to be added to these inherited features:

* A derived class needs its **own constructors**.
* A derived class can add additional data members and member functions as needed.

In this particular case, the class needs one more data member to hold the `ratings` value. It should also have a method for retrieving the rating and a method for resetting the rating. So the class declaration could look like this:

```C++
class RatedPlayer : public TableTennisPlayer
{
public:
	RatedPlayer(unsigned int r = 0, const string & fn = "noen",
				const string & ln = "none", bool ht = false);
	RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
	unsigned int Rating() const { return rating; }
	void ResetRating(unsigned int r) { rating = r; }
private:
	unsigned int rating;	
};
```

The constructors have to provide data for the new members and for the inherited members. The first constructor uses a separate formal parameter for each member, and the second `RatePlayer` constructor uses a `TableTennisPlayer` parameter, which bundles three items into a single unit.

### Constructors: Access Considerations

A derived class does **not** have direct access to the private members of the base class; it has to work through the base-class methods. In particular, the derived-class constructors have to **use the base-class constructors**.

When a program constructs a derived-class object, it first constructs the base-class object. The base-class object should be constructed **before** the program enters the body of the derived-class constructor. C++ uses the member initializer list syntax to accomplish this:

```C++
RatedPlayer::RatedPlayer(unsigned int r, const string & fn, const string & ln, bool ht) 
: TableTennisPlayer(fn, ln, ht)
{
	rating = r;
}
```

The following part is the member intializer list:

```C++
: TableTennisPlayer(fn, ln, ht)
```

This calls the `TableTennisPlayer` constructor.

The base-class object **must** be created first. So if you omit calling a base-class constructor, the program **uses the default base-class constructor.** The following code calls the default constructor:

```C++
RatedPlayer::RatedPlayer(unsigned int r, const string & fn, const string & ln, bool ht) // : TableTennisPlayer()
{
	rating = r;
}
```

Unless you want the default constructor to be used, you should explicitly provide the correct base-class constructor call. Now let's look at code for the second constructor:

```C++
RatedPlayer::RatedPlayer(unsigned int r, const TableTenniesPlayer & tp)
	: TableTennisPlayer(tp)
{
	rating = r;
}
```

This invokes the base-class copy constructor. The base class didn't define a copy constructor, so the compiler automatically generates a copy constructor that dose memberwise copying. In this case, this is fine.

You may, if you like, also use the member initializer list syntax for members of the derived class. In that case, you **use the member name instead of the class name in the list**:

```C++
RatedPlayer::RatedPlayer(unsigned int r, const TableTenniesPlayer & tp)
	: TableTennisPlayer(tp), rating(r) { }
```


These are the key points about constructors for derived class:

* The base-class object is constructed first
* The derived-class constructor should pass base-class information to a base-class constructor via a member initializer list.
* The derived-class constructor should initialize the data members that were added to the derived class.

This example doesn't provide explicit destructors, so the implicit destructors are sued.  Destroying an object occurs in the opposite order used to construct an object. That is, the body of the derived-class is executed first, and then **the base-class destructor is called automatically**.

> **Note**

> When creating a derived-class object, a program first **calls the base-class constructor** and then calls the derived-class constructor. The base-class constructor is responsible for intializing the inherited data members. The derived-class constructor is responsible for initializing any added data members. A derived-class constructor **always** calls a base-class constructor. You can use the **initializer list syntax** to indicate _which_ base-class constructor to use. Otherwise, the default base-class construcotr is used.

> When an object of a derived class expires, the program **first calls the derived-class destructor** and then calls the base-class destructor.

> **Member Initializer Lists**

> A **constructor** for a derived class can use the **initializer list** mechanism to pass values along to a base-class constructor. Consider this example:

```C++
derived::derived(type1 x, type2 y) : base(x, y)	// initializer list
{
	...
}
```

> Except for the case of virtual base classes, a class can pass values back only to its **immediate base class**. If you don't supply a base-class constructor in a member initializer list, the program uses the default base-class constructor. The member initializer list syntax can be used only in constructors.

### Using a Derived Class

Listing 13.4 places both class declarations in the same header file.

```C++
// Listing 13.4
#ifndef TEST_HPP_
#define TEST_HPP_
#include <string>

using std::string;
class TableTennisPlayer
{
public:
	TableTennisPlayer(const string & fn = "none",
					  const string & ln = "none", bool ht = false);
	void Name() const;
	bool HasTable() const { return hasTable; }
	void ResetTable(bool v) { hasTable = v; }
private:
    string firstname;
    string lastname;
    bool hasTable;
};

class RatedPlayer : public TableTennisPlayer
{
public:
	RatedPlayer(unsigned int r = 0, const string & fn = "none",
				const string & ln = "none", bool ht = false);
	RatedPlayer(unsigned int r, const TableTennisPlayer & tp);
	unsigned int Rating() const { return rating; }
	void ResetRating(unsigned int r) { rating = r; }
private:
	unsigned int rating;
};

#endif
```

Listing 13.5 provides the method definitions for both classes.

```C++
// Lisitng 13.5
#include <iostream>
#include "test.hpp"

TableTennisPlayer::TableTennisPlayer(const string & fn, 
									 const string & ln, bool ht) 
	: firstname(fn), lastname(ln), hasTable(ht) {}

void TableTennisPlayer::Name() const
{
	std::cout << lastname << ", " << firstname;
}

RatedPlayer::RatedPlayer(unsigned int r, const string & fn,
						 const string & ln, bool ht) 
	: TableTennisPlayer(fn, ln, ht), rating(r) { }

RatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer & tp)
	: TableTennisPlayer(tp), rating(r) { }

```

Listing 13.6

```C++
#include <iostream>
#include <string>
#include "test.hpp"

int main(void)
{
	using std::cout;
	using std::endl;
	TableTennisPlayer player1("Tara", "Boomdea", false);
	RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
	rplayer1.Name();
	if (rplayer1.HasTable())
		cout << ": has a table.\n";
	else
		cout << ": doesn't have a table.\n";
	player1.Name();
	if (player1.HasTable())
		cout << ": has a table";
	else
		cout << ": doesn't have a table.\n";
	cout << "Name: ";
	rplayer1.Name();
	cout << "; Rating: " << rplayer1.Rating() << endl;
	RatedPlayer rplayer2(1212, player1);
	cout << "Name: ";
	rplayer2.Name();
	cout << "; Rating: " << rplayer2.Rating() << endl;

	return 0;
}
```

Notice that objects of both classes can use the `TableTennisPlayer` class `Name()` and `HasTable()` methods.

### Special Relationships Between Derived and Base Classes

A derived-class object can use base-class methods, provided that the methods are not private:

```C++
RatedPlayer rplayer1(1140, "Mallory", "Duck", true);
rplayer1.Name();
```

A base-class pointer or reference can point to or refer to a derived-class object without an explicit type cast.

```C++
RatePlayer rplayer(1140, "Mallory", "Duck", true);
TableTennisPlayer & rt = rplayer;
TableTennisPlayer * pi = &rplayer;
rt.Name();		// invoke Name() with reference
pt->Name();		// invoke Name() with pointer
```

However, you cannot do the reverse. That is, you can't assign base-class objects and addresses to derived-class references and pointers:

```C++
TableTennisPlayer player("Betsy", "Bloop", true);
RatedPlayer & rr = player;	// NOT ALLOWED!
RatedPlayer * pr = player;	// NOT ALLOWED!
```

Both these sets of rules make sense. You can use the base-class reference or pointer to invoke base-class methods for the derived-class object. Because the derived-class inherits the base-class methods, this causes no problems. But if you assign a base-class object to a derived-class reference, invoking derived-class methods for the base object would make no sense.

The fact that base-class references and pointers can refer to derived-class objects has some interesting consequences. One is that functions defined with base-class reference or pointer argument can be used with **either the base-class or derived-class objects**. For instance:

```C++
void Show(const TableTennisPlayer & rt)
{
	using std::cout;
	cout << "Name: ";
	rt.Name();
	cout << "\nTable: ";
	if (rt.HasTable())
		cout << "yes\n";
	else
		cout << "no\n";
}
```

Thus, you can use `Show()` with either a `TableTennisPlayer` argument or a `RatedPlayer` argument:

```C++
TableTennisPlayer player1("Tara", "Boomdea", false);
RatedPlayer raplayer(1140, "Mallory", "Duck", true);
Show(player1);
Show(rplayer1);
```

The reference compatibility property also allows you to initialize a base-class object to a derived-class object, although somewhat indirectly. Suppose you have this code:

```C++
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer olaf2(olaf1);
```

The exact match for initializing `olaf2` would be a constructor with this prototype:

```C++
TableTennisPlayer(const RatedPlayer & );	// doesn't exist
```

The class definition don't include this constructor, but there is the implicit copy constructor:

```C++
// implicit copy constructor
TableTennisPlayer (const TableTennisPlayer & );
```

The reference argument can refer to a derived type.

Similarly, you can **assign** a derived-class object to a base-class object:

```C++
RatedPlayer olaf1(1840, "Olaf", "Loaf", true);
TableTennisPlayer winner;
winner = olaf1;	// assign derived to base object
```

## Inheritance: An _Is-a_ Relationship

C++ has three varieties of inheritance: public, protected, and private. Public inheritance is the most common form, and it models an _is-a_ relationship. This is a shorthand for saying that an object of a dericed class **should also be an object of the base class**.

**Anything you can do with a base-class object, you should be able to do with a derived-class**.

For example, a banana is a particular kind of fruit, you could derive a `Banana` class from the `Fruit` class. The new class inherit **all** the data members of the original class, so a `Banana` object would have members representing the weight and caloric content of a banana. The new `Banana` class also might add members that **apply particularly to bananas and not to fruit in gneneral**.

Public inheritance doesn't model a _has-a_ relationship, like the relationship between lunch and fruit. This is most easily modeled by including a `Fruit` object as a data member of a `Lunch` class.

_is-like_ relationship: a shark and a lawyer. 

_is-implemented-as-a_ relationship: a stack and an array. For example, array indexing is not a stack property. A proper approach would by to hide the array implementation by giving the stack a private `Array` object member.

_uses-a_ relationship: a printer and computer. You might devise friend functions or classes to handle communication.

## Polymorphic Public Inheritance

You can have multiple behaviors for a method, depending on the context. This is termed _polymorphic_. There are two key mechanisms for implementing polymorphic public inheritance:

* Redefining base-class methods in a derived class
* Using virtual methods.

Suppose you are asked to develop two classes for representing two checking account Brass checking account, and Brass Plus checking account. The second adds an overdraft protection feature. Apart from the information for a regular Brass Account, a Brass Plus account should include additional information:

* An upper limit to the overdraft protection
* An interset rate charged for overdraft loans
* The overdraft amount

And two operations need to be implemented differently:

* The withdrawing money operation has to incorporate overdraft protection
* The display operation has to show the additional information required.

### Developing the `Brass` and `BrassPlus` Classes

```C++
// Listing 13.7
#ifndef TEST_HPP_
#define TEST_HPP_
#include <string>

class Brass
{
public:
	Brass(const std::string & s = "Nullbody", long an = -1, double bal = 0.0);
	void Deposit(double amt);
	virtual void Withdraw(double amt);
	double Balance() const;
	virtual void ViewAcct() const;
	virtual ~Brass() {}
private:
	std::string fullName;
	long acctNum;
	double balance;
};

class BrassPlus : public Brass
{
public:
	BrassPlus(const std::string & s = "Nullbody", long an = -1, double bal = 0.0, double ml = 500, double r = 0.11125);
	BrassPlus(const Brass & ba, double ml = 500, double r = 0.11125);
	virtual void ViewAcct() const;
	virtual void Withdraw(double amt);
	void ResetMax(double m) { maxLoan = m;}
	void ResetRate(double r) {rate = r; }
	void ResetOwes() {owesBank = 0;}
private:
	double maxLoan;
	double rate;
	double owesBank;
};

#endif

```

There are several points to notice in Listing 13.7:

* The `BrassPlus` class adds three new private data members and three new public member functions to the `Brass` class
* Both the `Brass` class and the `BrassPlus` class declare the `ViewAcct()` and `Withdraw()` methods.
* The `Brass` class uses the new keyword `virtual` in declaring `ViewAcct()` and `Withdraw()`. These methods are termed _virtual methods_.
* The `Brass` class also declares a virtual destructor.

The second point in the list is how the declaration specify that methods are to **behave differenctly** for the derived class.

**The two prototype** indicates that there will be two separate method definitions. The qualified names for the base-class version will be `Brass::ViewAcct()` and that for the derived-class version is `BrassPlus::ViewAcct()`. A program will use the object to determine which version to use:

```C++
Brass dom("Dominic Banker", 11224, 4183.45);
BrassPlus dot("Dorothy Banker", 12118, 2592.00);
dom.ViewAcct();		// use Brass::ViewAcct()
dot.ViewAcct();		// use BrassPlus::ViewAcct()
```

Methods that behave the same for both classes such as `Deposit()` and `Balance()`, are declared in the base class.

The third point is more involved. Its **only** function is to determine which method is used if the method is invoked **by a reference or a pointer**. If you don't use the keyword `virtual`, the program chooses a method **based on the reference type or pointer type**. If you do use the keyword `virtual`, the program chooses a method based on **the type of object** the reference or pointer referes to.

Basically, it alters the type used to determine which version to use: the reference/pointer, or the object they refer to.

Consider the following code:

```C++
Brass & r1 = dom;
Brass & r2 = dom;
r1.ViewAcct();
r2.ViewAcct();
```

If `ViewAcct()` isn't declared virtual, the compiler look at the reference type, which is `Brass`, and use the `Brass::ViewAcct()`.

Otherwise, it looks at the type of object referred to, and use the corresponding version respectively.

It's the common practice to declare as virtual in the **base class** those methods that might be redefined in a derived class. When a method is declared virtual in a base class, it is **automatically** virtual in the derived class. But it's a good idea to document which functions are virtual by using the keyword `virtual` in the derived class.

> **Note**

> If you redefine a base-class method in a derived class, the usual practice is to declare the base-class method as virtual. This makes the program choose the method version **base on object type instead of the type of a reference or pointer**. It's also a usual practice to declare a virtual destructor for the base class.

#### Class Implementations

Note that the keyword `virtual` is used just in the method prototypes in the class declaration, **not in the method definitions**.

Listing 13.8

```C++
#include <iostream>
#include <string>
#include "test.hpp"

using std::cout;
using std::endl;
using std::string;

typedef std::ios_base::fmtflags format;
typedef std::streamsize precis;
format setFormat();
void restore(format f, precis p);

// Brass methods

Brass::Brass(const string & s, long an, double bal)
{
	fullName = s;
	acctNum = an;
	balance = bal;
}

void Brass::Deposit(double amt)
{
	if (amt < 0)
		cout << "Negative deposit not allowed; "
			 << "deposit is cancelled.\n";
	else
		balance += amt;
}

void Brass::Withdraw(double amt)
{
	format initialState = setFormat();
	precis prec = cout.precision(2);

	if (amt < 0)
		cout << "Withdrawal amount must be positive; "
			 << "withdrawal cancelled.\n";
	else if (amt <= balance)
		balance -= amt;
	else
		cout << "Withdrawal amount of $" << amt
			 << " exceeds your balance.\n"
			 << "Withdrawal cancelled.\n";
	restore(initialState, prec);
}

double Brass::Balance() const
{
	return balance;
}

void Brass::ViewAcct() const
{
	format initialState = setFormat();
	precis prec = cout.precision(2);
	cout << "Client: " << fullName << endl;
	cout << "Account Number: " << acctNum << endl;
	cout << "Balance: $" << balance << endl;
	restore(initialState, prec);
}

BrassPlus::BrassPlus(const string & s, long an, double bal, double ml, double r) : Brass(s, an, bal)
{
	maxLoan = ml;
	owesBank = 0.0;
	rate = r;
}

BrassPlus::BrassPlus(const Brass & ba, double ml, double r) : Brass(ba)
{
	maxLoan = ml;
	owesBank = 0.0;
	rate = r;
}

void BrassPlus::ViewAcct() const
{
	format initialState = setFormat();
	precis prec = cout.precision(2);

	Brass::ViewAcct();
	cout << "Maximum loan: $" << maxLoan << endl;
	cout << "Owed to bank: $" << owesBank << endl;
	cout.precision(3);
	cout << "Loan Rate: " << 100 * rate << "%\n";
	restore(initialState, prec);
}

void BrassPlus::Withdraw(double amt)
{
	format initialState = setFormat();
	precis prec = cout.precision(2);

	double bal = Balance();
	if (amt <= bal)
		Brass::Withdraw(amt);
	else if ( amt <= bal + maxLoan - owesBank)
	{
		double advance = amt - bal;
		owesBank += advance * (1.0 + rate);
		cout << "Bank advance: $" << advance << endl;
		cout << "Finance charge: $" << advance * rate << endl;
		Deposit(advance);
		Brass::Withdraw(amt);
	}
	else
		cout << "Credit limit exceeded. Transaction cancelled.\n";
	restore(initialState, prec);
}

format setFormat()
{
	return cout.setf(std::ios_base::fixed, std::ios_base::floatfield);
}

void restore(format f, precis p)
{
	cout.setf(f, std::ios_base::floatfield);
    cout.precision(p);
}
```

Keep in mind that the derived class does **not** have direct access to private base-class data; the derived class has to use **base-class public methods to access the data**. The means of access depends on the method.

The technique that derived-class constructors use to initialize base-class private data is the member initializer list syntax:

```C++
BrassPlus::BrassPlus(const string & s, long an, double bal, double ml, double r) : Brass(s, an, bal)
{
	maxLoan = ml;
	owesBank = 0.0;
	rate = r;
}

BrassPlus::BrassPlus(const Brass & ba, double ml, double r) : Brass(ba)		// use implicit copy constructor
{
	maxLoan = ml;
	owesBank = 0.0;
	rate = r;
}
```

Each of these constructors uses the member initializer list syntax to pass base-class information to a base-class constructor and then uses the construtor body to initialize the new data items added by the `BrassPlus` class.

Non-constructors **can't use the member initializer list syntax**. But a derived-classs method can call a public base-class method:

```C++
// redefine how ViewAcct() works
void BrassPlus::ViewAcct() const
{
...
	Brass::ViewAcct();	// display base portion
	cout << "Maximum loan: $" << maxLoan << endl;
	cout << "Owed to bank: $" << owesBank << endl;
	cout << "Loan Rate: " << 100 * rate << "%'n";
...
}
```

`BrassPlus::ViewAcct()` calls on the base-class method `Brass::ViewAcct()` to display the base-class data. **Using the scope-resolution operator** in a derived-class method to invoke a base-class method is a standard technique.

It's vital that the code use the scope-resolution operator. Suppose that, instead, you wrote the code this way:

```C++
void BrassPlus::ViewAcct() const
{
...
	ViewAcct();
...
}
```

If the code doesn't use the scope-resolution operator, the compiler assumes that `ViewAcct()` is `BrassPlus::ViewAcct()` and generate a recursive function.

Consider the `BrassPlus::Withdraw()` method:

```C+++
void BrassPlus::Withdraw(double amt) 
{
...
	double bal = Balance();
...
}
```

The code doesn't have to use the scope-resolution operator for `Balance()` because this method has not been redefined in the derived class.

#### Using the `Brass` and `BrassPlus` Classes



```C++
#include <iostream>
#include "test.hpp"
int main(void)
{
	using std::cout;
	using std::endl;
	Brass Piggy("Porcelot Pigg", 381299, 4000.00);
	BrassPlus Hoggy("Horatio Hogg", 38288, 3000.00);
	Piggy.ViewAcct();
	cout << endl;

	Hoggy.ViewAcct();
	cout << endl;
	cout << "Depositing $1000 into the Hogg Account:\n";
	Hoggy.Deposit(1000.00);
	cout << "New balance: $" << Hoggy.Balance() << endl;
	cout << "Withdrawing $4200 from the Pigg Account:\n";
	Hoggy.Withdraw(4200.00);
	Hoggy.ViewAcct();

	return 0;
}
```

#### Showing Virtual Method Behavior

Listing 13.9 doesn't involve the virtual method feature because the methods are invoked by objects, not pointers or references.

Suppose you would like to manage a mixture of `Brass` and `BrassPlus` accounts. You can't have a single array that holds a mixture of `Brass` and `BrassPlus` objects because each item in an array has to be the same type. **However, you can create an array of pointers-to-`Brass`**. In that case, every element is of the same type, but because of the public inheritance model, a pointer-to-`Brass` can point to either a `Brass` or a `BrassPlus` object. Listing 13.10 shows a simple example.

```C++
// Listing 13.10
#include <iostream>
#include <string>
#include "test.hpp"
const int CLIENTS = 4;

int main(void)
{
	using std::cout;
	using std::endl;
	using std::cin;

	Brass * p_clients[CLIENTS];
	std::string temp;
	long tempnum;
	double tempbal;
	char kind;

	for (int i = 0; i < CLIENTS; i++)
	{
		cout << "Enter client's name: ";
		getline(cin, temp);
		cout << "Enter client's account number: ";
		cin >> tempnum;
		cout << "Enter opening balance: $";
		cin >> tempbal;
		cout << "Enter 1 for Brass Account or "
			 << "2 for BrassPlus Account: ";
		while (cin >> kind && (kind != '1' && kind != '2'))
			cout << "Enter either 1 or 2: ";
		if (kind == '1')
			p_clients[i] = new Brass(temp, tempnum, tempbal);
		else
		{
			double tmax, trate;
			cout << "Enter the overdraft limit: $";
			cin >> tmax;
			cout << "Enter the interest rate "
				 << "as a decimal fraction: ";
			cin >> trate;
			p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate);
		}
		while (cin.get() != '\n')
			continue;
	}	

	cout << endl;
	for (int i = 0; i < CLIENTS; i++)
	{
		p_clients[i]->ViewAcct();
		cout << endl;
	}

	for (int i = 0; i < CLIENTS; i++)
	{
		delete p_clients[i];
	}

	cout << "Done.\n";
	return 0;
}
```

The polymorphic aspect is provided by the following code:

```C++
for (i = 0; i < CLIENTS; i++)
{
	p_clients[i]->ViewAcct();
	cout << endl;
}
```

If the array member points to a `Brass` object, `Brass::ViewAcct()` is invoked; if the array member points to a `BrassPlus` object, `Brass::ViewAcct()` is invoked. However, if `Brass::ViewAcct()` were not been declared as virtual, `Brass::ViewAcct()` would be invoked in all cases.

#### The Need for Virtual Destructors

The code in Listing 13.10 that uses `delete` to free the objects allocated by `new` illustrates why the base class should have a virtual destructor, even if no destructor appears to be needed. If the destructors are not virtual, then **just the corresponding to the pointer type is called.** If the destructors are virtual, the destructor corresponding to the object type is called.

## Static and Dynamic Binding

Interpreting **a function call** in the source code as executing a particular block of function code is termed _binding_ the function name.

Binding that takes place during compilation is called _static binding_ (or _early binding_). However, virtual functions make the job more difficult. The decision of which function to use can't be made at compile time because the compiler doesn't know which kind of object the user is going to choose to make. The compiler has to generate code that allows the correcct virtual method to be selected as the program runs; this is called _dynamic binding_ (or _late binding_).

### Pointer and Reference Type Compatibility

Dynamic binding in C++ is **associated with methods invoked by pointers and references**.

Converting a derived-class reference or pointer to base-class reference or pointer is called _upcasting_, and it is always allowed for public inheritance **without the need for an explicit type case.** Upcasting is transitive.

The opposite process, converting a base-class pointer or reference to a derived-class pointer or reference, is called _downcasting_. It is not allowed without an explicit type cast. The reason for this restriction is that the _is-a_ relationship is not, in general, symmetric. A derived class could add new data members, and the class member functions that used these data members wouldn't apply to the base class.

Upcasting also takes place for function calls with base-class references or pointers as parameters. Consider the following code fragment:

```
void fr(Brass & rb);	// uses rb.ViewAcct()
void fp(Brass * pb);	// uses pb->ViewAcct()
void fv(Brass b);		// uses b.ViewAcct()

int main()
{
	Brass b("Billy Bee", 123432, 10000.0);
	BrassPlus bp("Betty Beep", 232313, 12345.0);
	fr(b);		// uses Brass::ViewAcct()
	fr(bp);		// uses BrassPlus::ViewAcct()
	fp(b);		// uses Brass::ViewAcct()
	fp(bp);		// uses BrassPlus::ViewAcct()
	fv(b);		// uses Brass::ViewAcct()
	fv(bp);		// uses Brass::ViewAcct()
...
}
```

Consider the last two function calls. Passing by value is allowed because of the implict copy constructor. In this case, only the `Brass` component of a `BrassPlus` object to be passed to the `fv()` function.

### Virtual Member Functions and Dynamic Binding

Let's revisit the process of invoking a method with a reference or pionter:

```C++
BrassPlus ophelia;		// derived-class object
Brass * bp;				// base-class pointer
bp = &ophelia;			// Brass pointer to BrassPlus object
bp->ViewAcct();			// which version?
```

As discussed before, if `ViewAcct()` is not declared as virtual in the base class, `bp->View()` goes by the pointer type `(Brass * )` and invokes `Brass::ViewAcct()`. **The pointer type is known at compile time, so the compiler can bind `ViewAcct()` to `Brass::ViewAcct()` at compile time.**

In short, the compiler uses static binding for non-virtual methods.

But if `ViewAcct()` is declared as virtual in the base class, `bp->ViewAcct()` goes by the object type and invokes `BrassPlus::ViewAcct()`. In general, the object type might only be determined when the program is running. The compiler generate the code, which binds `ViewAcct()` to `Brass::ViewAcct()` or `BrassPlus::ViewAcct()`, depending on the object type, while the program executes.

In short, the compiler uses dynamic binding for virtual methods.

#### Why Two Kinds of Binding and Why Static Is the Default

There are two reasons: efficiency and a conceptual model.

First, let's consider efficiency. For a program to be able to make a runtime decision, it has to have some way to keeptrack of what sort of object a base-class pointer or reference refers to, and that entails some extra processing overhead. You should therefor go to virtual functions only if the program design needs them.

Next, let's consider the conceptual model. When you design a class, you may have member functions that you don't want redefined in derived classes. By making these function nonvirtual, you accomplish two things. First, you make it more effiecient. Second, **you announce that it is your intention that this function not be redefined.**

> ##### Tip

> If a method in a base class will be redefined in a derived class, you should make it virtual. If the method should not be redefined, you should make it nonvirtual.


#### How Virtual Functions Work

C++ specifys how virtual functions should behave, but it leaves the implementation up to the compiler writer.

The usual way compilers handle virtual functions is to add a hidden member to each object. The hidden member holds a pointer to an array of function addresses. Such an array is termed a _virtual funciton table_ (vtbl). Each object keeps its own virtual function table. When you call a virtual function, the program looks at the vtbl address stored in an object and goes to the corresponding table of function addresses.Thus, **we determine which virtual function to use not by the type of the pointer or reference, but by the information stored in the object**.

In short, using virtual functions has the following modest costs in memory and execution speed:

* Each object has its size increased by the amount needed to hold an address.
* For each class, the compiler creates a table of addresses of virtual functions
* For each function call, there's and extra step of going to a table to look up an address.

### Things to Know About Virtual Methods

We've already discussed the main points about virtual methods:
* Beginning a class method with the keyword `virtual` in a base class makes the function virtual for the base class and **all** classes derived the the base class.

* If a virtual method is invoked by using a reference to an object or by using a pointer to an object, the program uses **the method defined for the object** type rather than the method defined for the reference or pointer type. This is called _dynamic_, or late binding.

If you're defining a class that will be used as a base class for inheritance, you should declare as virtual functions the class methods that may have to be redefined in derived class.

#### Constructors

**Constructors can't be virtual.** Creating a derived object invokes a derived-class constructor, not a base-class constructor. **A derived class doesn't inherit the base-class constructors**, so usually there's not much point to making them virtual.

#### Destructors

**Destructors should be virtual unless a class isn't to be used as a base class**. Note that even if a base class doesn't require the services of an explicit destructor, you shouldn't rely on the default construtor. Instead, you should provide a virtual destructor, even if it has nothing to do: 

```C++
virtual ~BaseClass() { }
```

By the way, it's not an error for a class to have a virtual destructor even if it is not intended to be a base class. It's just a matter of efficiency.

> ##### Tip

> Normally, you should provide a base class with a virtual destructor even if the class doesn't need a destructor.


#### Friends

Friends can't be virtual functions because friends are not class members, and **only members can be virtual functions**.

#### No Redefinition

If a derived class fails to redefine a function (virtual or not), the class will introduce the base class version of the function. If a derived class is part of a long chain of derivations, it will use the most recently defined version of the function.

#### Redefinition Hides Methods

Suppose you create something like the following:

```C++
class Dwelling
{
public:
	virtual void showperks(int a) const;
...
};
class Hovel : public Dwelling
{
public:
	virtual void showperks() const;
..
};
```

This causes a problem. You might get a compiler warning similar to the following:

```
Warning: Hovel::showperks(void) hides Dwellling::showperks(int);
```

Or perhaps you won't get a warning. Either way, the code has the following implications:

```C++
Hovel trump;
trump.showperks();
trump.showlperks(5);
```

Rather than resulting in two overloaded versions of the function, this redefinition _hides_ the base class version that takes an `int` argument. In short, **redefining inherited methods is not a variation of overloading**. If you define a function in a derived class, it ides _all_ base-class methods of **the same name**, regardless of the argument signatures.

This fact of life leads to a couple rules of thumb. First, if you redefine an inherited method, you need to make sure you **match the original prototype exactly**. One relatively new exception to this rule is that a return type that is a reference to pointer to a base class can be replaced by a reference or pointer to the derived class.

This feature is termed _covariance of return type_ because the return type is allowed to vary in paralel with the class type:

```C++
class Dwelling
{
public:
// a base method
	virtual Dwelling & build(int n);
	...
};

class Hovel : public Dwelling
{
public:
// a derived method with a convariant return type
	virtual Hovel & build(int n);
};
```

Second, if the base class declaration is overloaded, you need to redefine **all** the base class versions in the derived class:

```C++
class Dwelling
{
public:
// three overloaded showperks()
	virtual void showperks(int a) const;
	virtual void showperks(double x) const;
	virtual void showperks() const;
	...
};

class Hovel : public Dwelling
{
public:
	virtual void showperks(int a) const;
	virtual void showperks(double x) const;
	virtual void showperks() const;
	...
};
```

If you redefine just one version, **the other two become hidden** and cannot be used by objects of the derived class. Note that if no change is needed, the redefinition can simply call the base-class version:

```C++
void Hovel::showperks() const {Dwelling::showperks();}
```

## Access Control: `protected`

There is one more access category, denoted with the keyword `protected`. The `protected` keyword is like `private` in that the outside world can access class members in a `protected` section only by using public class members.

The difference between `private` and `protected` comes into play only within the classes derived from the base class. **Members of a derived class can access protected members of a base class directly**, but they cannot directly access private members of the base class. So members in the protected category behave like private members as far as the outside world is concerned but behave like public members as far as derived classes are concerned.

For example, suppose the `Brass` class declared the `balance` member as protected:

```C++
class Brass
{
protected:
	double balance;
...
};
```

In this case, the `BrassPluss` class could access `balance` directly without using `Brass` methods:

```C++
void BrassPlus::Reset(double amt)
{
	balance = amt;
}
```

However it has a design defect. The `Brass` class was designed so that the `Deposit()` method and `Withdraw()` interface provides the only means for altering `balance`, ignoring the safaguards found in `Withdraw()`.

> ##### Caution

> You should prefer private to protected access control for class data members, and you should use base-class methods to provide classes access to base-class data.

However, protected access control can be quite useful for member functions, giving derived classes access to internal functions that are not available publicly.

## Abstract Base Classes

Sometimes applying the _is-a_ rule is not as simple as it might appear. Suppose you are developing a graphics program that support to represent circles and and ellipses. All circles are ellipses, so it is tempting to derive a `Circle` class from an `Ellipse` class.

Consider an `Ellipse` class:

```C++
class Ellipse
{
private:
	double x;
	double y;
	double a;
	double b;
	double ange;
	...
public:
	...
	void Move(int nx, ny) {x = nx; y = ny;}
	virtual double Area() const { return 3.14159 * a * b; }
	virtual void Rotate(double nang) { angle += nang;}
	virtual void Scale(oduble sa, double sb) { a *= sa; b += sb;}
};
```

Now suppose you derive a `Circle` class from the `Ellipse` class:

```C++
class Circle : public Ellipse
{
	...
};
```

The derivation is awkward. For example, a circle needs only a single value, its radius to describe its size and shape instead of having a semimajor axis and semiminor axis. Then you have redundant representation of the same information. The `angle` parameter and the `Rotate()` method don't really make sense for a circle, and **the `Scale()` method as it stands, can change a circle to a non-circle by scaling the two axes differently**. You can try fixing things with tricks, such as putting a redefined `Rotate()` method in the private section of the `Circle` class. But on the whole, it seems simpler to define a `Circle` class without using inheritance:

```C++
class Circle
{
private:
	double x;
	double y;
	double r;
	...
public:
	... void Move(int nx, ny) { x = nx, y = ny;}
	double Area() const { return 3.1415926 * r * r; }
	void Scale(double sr) { r *= sr;}
};
```

The two classes have a lot in common, but defining them separately ignores the fact. You can **abstract from the `Ellipse` and `Circle` classes what they have in common and place those features in an ABC.** Next, you derive both the `Circle` and `Ellipse` classes from the ABC. **Then, you can use an array of base-class pointers to manage a mixture of `Ellipse` and `Circle` objects.**

What the two classes have in common are the coordinates of the center of the shape; a `Move()` method, and an `Area()` method. However, **the `Area()` method works differently for the two classes**. Indeed, the `Area()` method can't even be implemented for the ABC because it doesn't have the necessary data member. C++ has a way to provide an unimplemented function by using a **pure virtual function**. A pure virtual function has `= 0` at the end of its declaration, as shown for the `Area()` method:

```C++
class BaseEllipse	// abstract base class
{
private:
	double x;
	double y;
	...
public:
	BaseEllipse(double x0 = 0, double y0 = 0) : x(x0), y(y0) {}
	virtual ~BaseEllipse() {}
	void Move(int nx, ny) { x = nx; y = ny; }
	virtual double Area() const = 0;	// a pure virtual function
	...
}
```

When a class declaration contains a pure virtual function, you **can't create an object of that class**. The idea is that classes with pure virtual functions exist solely to serve as base classes. For a class to be a genuine ABC, it has to have **at least one pure virtual function**.

In the case of `Area()` method, the function has no definition, but **C++ allows even a pure virtual function to have a definition.** For example, perhaps all the base methods are like `Move()` in that they can be defined for the base class, but you still need to make the class abstract. You could then make the prototype virtual:

```C++
void Move(int nx, int ny) = 0;
```

**This makes the base class abstract**. But then you could still provide a definition in the implementation file:

```C++
void BaseEllipse::Move(int nx, ny) { x = nx, y = ny; }
```

In short, the `=0` in the prototype indicates that the class is an abstract base class and that the class doesn't necessarily have to define the function. 

Now you can derive the `Ellipse` class and `Circle` class from the `BaseEllipse` class. A program using these classes would by able to create `Ellipse` objects and `Circle` objects **but no `BaseEllipse` objects.** Because `Circle` and `Ellipse` objects have the same base class, **a collection of such objects can be managed with an array of `BaseEllipse` pointers.**

Classes such as `Circle` and `Ellipse` are sometimes termed _concrete_ classes to indicate that you can create objects of those types.

In short, an ABC describes an interface that uses at least one pure virtual function, and classes derived from an ABC use regular virtual functions to implement the interface in terms of the properties of the particular derived class.

### Applying the ABC Concept

Let's apply the concept to representing the `Brass` and `BrassPlus` accounts, starting with an ABC called `AcctABC`. This class should contain all methods and data members that are common to both the `Brass` and the `BrassPlus` classes. the methods that are to work differently for the `BrassPlus` class that they do for the `Brass` class should be declared as virtual functions. 

Listing 13.11 is a header file that contains the `AcctABC` class (an ABC) and the `Brass` and `BrassPlus` class (both concrete classes). `AcctABC` also provides a protected member function to handle the formatting previously handled by nonmember functions.

Listing 13.11

```C++
#ifndef acctabc_hpp
#define acctabc_hpp
#include <iostream>
#include <string>

class AcctABC
{
public:
	AcctABC(const std::string & s = "Nullbody", long an = -1, double bal = 0.0);
	void Deposit(double amt);
	virtual void Withdraw(double amt) = 0;
	double Balance() const {return balance;}
	virtual void ViewAcct() const = 0;
	virtual ~AcctABC() {}
protected:
	struct Formatting
	{
		std::ios_base::fmtflags flag;
		std::streamsize pr;
	};
	const std::string & FullName() const {return fullName;}
	long AcctNum() const {return acctNum;}
	Formatting SetFormat() const;
	void Restore(Formatting & f) const;
private:
	std::string fullName;
	long acctNum;
	double balance;
};

class Brass : public AcctABC
{
public:
	Brass(const std::string & s = "Nullbody", long an = -1, double bal = 0,0) : AcctABC(s, an, bal) {}
	virtual void Withdraw(double amt);
	virtual void ViewAcct() const;
	virtual ~Brass() {}
};

class BrassPlus : public AcctABC
{
public:
	BrassPlus(const std::string & s = "Nullbody", long an = -1, double bal = 0.0, double ml = 500, double r = 0.10);
	BrassPlus(const Brass & ba, double ml = 500, double r = 0.1);
	virtual void ViewAcct() const;
	virtual void Withdraw(double amt);
	void ResetMax(double m) {maxLoan = m;}
	void ResetRate(double r) {rate = r;}
	void ResetOwes() { owesBank = 0;}
private:
	double maxLoan;
	double rate;
	double owesBank;
};

#endif /* acctabc_hpp */

```

The next step is to implement the methods that don't already have inline definitions. Listing 13.12 does that.

```C++
// Listing 13.12
#include "acctabc.hpp"

#include <iostream>

using std::cout;
using std::ios_base;
using std::endl;
using std::string;

AccABC::AcctABC(const string & s, long an, double bal)
{
	fullName = s;
	acctNum = an;
	balance = bal;
}

void AcctABC::Depoisit(double amt)
{
	if (amt < 0)
		cout << "Negative deposit not allowed; "
			 << "deposit is cancelled.\n";
	else
		balance += amt;
}

void AcctABC::Withdraw(double amt)
{
	balance -= amt;
}

AcctABC::Formatting AcctABC::SetFormat() const
{
	Formatting f;
	f.flag = cout.setf(ios_base::fixed, ios_base::floatfield);
	f.pr = cout.precision(2);
	return f;
}

void AcctABC::Restore(Formatting & f) const
{
	cout.setf(f.flag, ios_base::floatfield);
	cout.precision(f.pr);
}

void Brass::Withdraw(double amt)
{
	if (amt < 0)
		cout << "Withdrawal amount must be positive; "
			 << "withdrawal cancelled.\n";
	else if (amt <= Balance())
		AcctABC::Withdraw(amt);
	else
		cout << "Withdrawal amount of $" << amt
		 	 << " exceeds your balance.\n"
		 	 << "Withdrawal cancelled.\n";
}

void Brass::ViewAcct() const
{
	Formatting f = SetFormat();
	cout << "Brass Client: " << FullName() << endl;
	cout << "Account Number: " << AcctNum() << endl;
	cout << "Balance: $" << Balance() << endl;
	Restore(f);
}

BrassPlus::BrassPlus(const Brass & ba, double ml, double r) : AcctABC(ba)
{
	maxLoan = ml;
	owesBank = 0.0;
	rate = r;
}

void BrassPlus::ViewAcct() const
{
	Formatting f = Set();
	cout << "Brass Number: " << AcctNum() << endl;
	cout << "Balance: $" << Balance() << endl;
	cout << "Maximum loan: $" << maxLoan << endl;
	cout << "Owed to bank: $" << owesBank << endl;
	cout.precision(3);
	cout << "Loan Rate: " << 100 * rate << "%\n";
	Restroe(f);
}

void BrassPlus::Withdraw(double amt)
{
	Formatting f = SetFormat();

	double bal = Balance();
	if (amt <= bal)
		AcctABC::Withdraw(amt);
	else if (amt <= bal + maxLoan - owesBank)
	{
		double advance = amt - bal;
		owesBank += advance * (1.0 + rate);
		cout << "Bank advance: $" << advance << endl;
		cout << "Finanace charge: $" << advance * rate << endl;
		Deposit(advance);
		AcctABC::Withdraw(amt);

	}
	else
		cout << "Credit limit exceeded. Transaction cancelled.\n";
	Restore(f);
}
```

The `Fullname()` and `AcctNum()` protected methods provide read-only access to the `fullName` and `acctNum` data members and make it possible to customize `ViewAcct()` a little more individually for each derived class.

This example places the formatting control structures and functions in the protected part of the class definition. This makes them available to the base class and the derived class while hiding them from the outside world.

This new implementation of the `Brass` and `BrassPlus` accounts can be used in the same manner as the old one **because the class methods have the same names and interface as before.**. To convert Listing 13.10 to use the new implementation, you just need to take these steps to convert `usebrass2.cpp` to a `usebrass3.cpp` file:

* Link `usebrass2.cpp` with `acctabc.cpp` instead of with `brass.cpp`.
* Include _acctabc.h_ instead of _brass.h_
* Replace 

```
Brass * p_clients[CLIENTS];
```
with
â€‹
```	
AcctABC * p_clients[CLIENTS];
```

```C++
#include <iostream>

#include <string>
#include "acctabc.hpp"
const int CLIENTS = 4;

int main(void)
{
	using std::cin;
	using std::cout;
	using std::endl;

	AcctABC * p_clients[CLIENTS];
	std::string temp;
	long tempnum;
	double tempbal;
	char kind;

	for (int i = 0; i < CLIENTS; ++i)
	{
		cout << "Enter client's name: ";
		getline(cin, temp);
		cout << "Enter client's account number: ";
		cin >> tempnum;

		cout << "Enter opening balance: $";
		cin >> tempbal;
		cout << "Enter 1 for Brass Account or "
			 << "2 for BrassPlus Account: ";
		while (cin >> kind && (kind != '1' && kind != '2'))
			cout << "Enter either 1 or 2: ";
		if (kind == '1')
			p_clients[i] = new Brass(temp, tempnum, tempbal);
		else
		{
			double tmax, trate;
			cout << "Enter the overdraft limit: $";
			cin >> tmax;
			cout << "Enter the interest rate "
				 << "as a decimal fraction: ";
			cin >> trate;
			p_clients[i] = new BrassPlus(temp, tempnum, tempbal, tmax, trate);
			while (cin.get() != '\n')
				continue;
		}
	}	
	cout << endl;
	for (int i = 0; i < CLIENTS; ++i)
	{
		delete p_clients[i];
	}
	cout << "Done.\n";

	return 0;
}
```

### ABC Philosophy

The ABC methodology is a much more systematic, disciplined way to approach inheritance. One school of thought holds that if you design an inheritance hierarchy of classes, **the only concrete classes should be those that never serve as a base class.** This approach tends to produce cleaner designs with fewer complications.

One way of thinking about ABCs is to consider them an enforcement of interface. An ABC demands that its pure virtual funcitons be overridden in any concrete derived classes, forcing the derived class to obey the rules of interface the ABC has set.

This model is common in component-based programming paradigms, in which the use of ABCs allowss the component designer to create an "interface contract" where all components derived from ABC are guaranteed to uphold at least the common funcitonality specified by the ABC.

## Inheritance and Dynamic Memory Allocation

If the derived class does not itself use dynamic memory allocation, **you don't need to take special steps.** If the derived class does also use dynamic memory allocation, then there are a couple new tricks to learn. Let's look at these two cases.

### Case 1: Derived Class Doesn't Use `new`

Suppose you begin with the following base class that uses dynamic memory allocation:

```C++
class baseDMA
{
public:
	baseDMA(const char * l = "null", int r = 0);
	baseDMA(const baseDMA & rs);
	virtual ~baseDMA();
	baseDMA & operator=(const baseDMA & rs);
	...
private:
	char * label;
	int rating;
};
```

The declaration contains the special methods that are required when constructors use `new`: **a destructor, a copy constructor and an overloaded assignment operator**.

Now suppose you derive a `lackDMA` class from `baseDMA` and that `lackDMA` doesn't use `new`:

```C++
class lacksDMA : public baseDMA
{
public:
	...
private:
	char color[40];
};
```

**You don't have to define an explicit destructor, copy constructor, and assginment operator for the `lackDMA` class.**

You don't need a destructor because the default destructor for a derived class always calls the base-class destructor automatically.

Next, consider the copy constructor. The default copy constructor does memberwise copying which uses the form of copying that is defined for that data type in question. Copying a class member of an **inherited class component** is done using the copy constructor for that class.

Essentially the same situation holds for assginment. The default assignment operator for a class automatically uses the base-class assignment operator for the base-class component.

### Case 2: Derived Class Does Use `new`

Suppose that the derived class uses `new`:

```C++
class hasDMA : public baseDMA
{
public:
...
private:
	char * style;
};
```

In this case, you do have to define an explicit destructor, copy constructor, and assignement operator for the derived class. Let's consider these methods in turn.

A derived class destructor automatically calls the base-class constructor, so its only responsibility is to clean up after what the derived-class construcotors do:

```C++
hasDMA::~hasDMA()
{
	delete [] style;
}
```

Now consider copy constructor. The `hasDMA` copy constructor only has access to `hasDMA` data, so it must invoke the `baseDMA` copy constructor to handle the `baseDMA` share of the data:

```C++
hasDMA::hasDMA(const hasDMA & hs) : baseDMA(hs)
{
	style = new char [strlen(hs.style) + 1];
	std::strcpy(style, hs.style);
}
```

The point to note is that the member initializer list **passes a `hasDMA` reference to a `baseDMA` constructor**. A base class reference can refer to a derived type, and the `baseDMA` copy constructor uses the `baseDMA` portion of the `hasDMA` argument to construct the `baseDMA` portion of the new object.

Next, consider assignement operators. An explicit assignment operator for a derived class also has to take care of assignement for the inherited base class `baseDMA` object. You can accomplish this by **explicitly calling the base class assignment operator:**

```C++
// thi implementation is unsafe, though
hasDMA & hasDMA::operator=(const hasDMA & hs)
{
	tempStyle = new char [std::strlen(hs.style) + 1];
	std::strcpy(tempStyle, hs.style);
	delete [] style;
	style = tempStyle;
	baseDMA::operator=(hs);
	return * this;

}
```

An explicit assignment operator for a derived class also has to take care of assignemnt for the inherited base class `baseDMA` object. The following statement is the key:

```C++
baseDMA::operator=(hs);
```

What this actually does is, assign a `hasDMA` object to another `hasDMA` object **using the assignment operator defined in base class.** This works because the derived class inherits the assignement operator. But to specify it's the base-class assignment to use, you **have use the function notation and scope-resolution operator.** Otherwise, the compiler will use the default assignment for the derived-class, **resulting in a recursive function.**

In summary, when both the base class and the derived class use dynamic memory allocation, the derived-class destructor, copy constructor, and assignment operator all must **use their base-class counterparts to handle he base-class component**. For a destructor, it is done automatically. For a constructor, **it is accomplished by invoking the base-class copy constructor in the member initialization list**, ro else the default constructor. For the assignemnt operator, it is accomplished by using the scope-resolution operator in a **explicit call of the base-class assignment operator**.

### An Inheritance Example with Dynamic Memory Allocation and Friends

To illustrate these ideas of inheritance and dynamic memory allocation, let's integrate the `baseDMA`, `lacksDMA` and `hasDMA` classes just discussed into a single example. Listing 13.14 is a header file for these classes. It adds a friend function that illustrate how derived classes can access friends to a base class.

```C++

#include <iostream>

class baseDMA
{
public:
	baseDMA(const char * l = "null", int r = 0);
	baseDMA(const baseDMA & rs);
	virtual ~baseDMA();
	baseDMA & operator=(const baseDMA & rs);
	friend std::ostream & operator<<(std::ostream & os, const baseDMA & rs);
private:
	char * label;
	int rating;
};

class lacksDMA : public baseDMA
{
public:
	lacksDMA(const char * c = "blank", const char * l = "null", int r = 0);
	lacksDMA(const char * c, const baseDMA & rs);
	friend std::ostream & operator<<(std::ostream & os, const lacksDMA & rs);
private:
	enum { COL_LEN = 40};
	char color[COL_LEN];
};

class hasDMA : public baseDMA
{
public:
	hasDMA(const char * s = "none", const char * l = "null", int r = 0);
	hasDMA(const char * s, const baseDMA & rs);
	hasDMA(const hasDMA & hs);
	~hasDMA();
	hasDMA & operator=(const hasDMA & rs);
	friend std::ostream & operator<<(std::ostream & os, const hasDMA & rs);
private:
	char * style;
};
```

listing 13.15

```C++
#include "test.hpp"
#include <cstring>

baseDMA::baseDMA(const char * l, int r)
{
	label = new char[std::strlen(l) + 1];
	std::strcpy(label, l);
	rating = r;
}
baseDMA::baseDMA(const baseDMA & rs)
{
	label = new char [std::strlen(rs.label) + 1];
	std::strcpy(label, rs.label);
	rating = rs.rating;
}

baseDMA::~baseDMA()
{
	delete [] label;
}

baseDMA & baseDMA::operator=(const baseDMA & rs)
{
	auto tempLabel = new char [strlen(rs.label) + 1];
	strcpy(tempLabel, rs.label);
	delete [] label;
	label = tempLabel;
	rating = rs.rating;
	return *this;
}

std::ostream & operator<<(std::ostream & os, const baseDMA & rs)
{
	os << "Label: " << rs.label << std::endl;
	os << "Rating: " << rs.rating << std::endl;
	return os;
}

lacksDMA::lacksDMA(const char * c, const char * l, int r) : baseDMA(l, r)
{
	std::strncpy(color, c, 39);
	color[39] = '\0';
}

lacksDMA::lacksDMA(const char * c, const baseDMA & rs) : baseDMA(rs)
{
	std::strncpy(color, c, COL_LEN - 1);
	color[COL_LEN - 1] = '\0';
}

std::ostream & operator<<(std::ostream & os, const lacksDMA & ls)
{
	os << (const baseDMA &) ls;
	os << "Color: " << ls.color << std::endl;
	return os;
}

hasDMA::hasDMA(const char * s, const char * l, int r) : baseDMA(l, r)
{
	style = new char [std::strlen(s) + 1];
	std::strcpy(style, s);
}

hasDMA::hasDMA(const char * s, const baseDMA & rs) : baseDMA(rs)
{
	style = new char [std::strlen(s) + 1];
	std::strcpy(style, s);
}

hasDMA::hasDMA(const hasDMA & hs) : baseDMA(hs)
{
	style = new char [std::strlen(hs.style) + 1];
	std::strcpy(style, hs.style);
}

hasDMA::~hasDMA()
{
	delete [] style;
}

hasDMA & hasDMA::operator=(const hasDMA & hs)
{
	auto tempStyle = new char [std::strlen(hs.style) + 1];
	std::strcpy(tempStyle, hs.style);
	delete [] style;
	style = tempStyle;
	baseDMA::operator=(hs);
	return *this;
}
std::ostream & operator<<(std::ostream & os, const hasDMA & hs)
{
	os << (const baseDMA &) hs;
	os << "Style: " << hs.style << std::endl;
	return os;
}

```

Listing 13.16

```C++
#include <iostream>
#include "test.hpp"
int main(void)
{
	using std::cout;
	using std::endl;

	baseDMA shirt("Portabelly", 8);
	lacksDMA balloon("red", "Blimpo", 4);
	hasDMA map("Mercator", "Buffalo Keys", 5);
	cout << "Displaying baseDMA object:\n";
	cout << shirt << endl;
	cout << "Displaying lacksDMA object:\n";
	cout << balloon << endl;
	cout << "Displaying hasDMA object:\n";
	cout <<map << endl;
	lacksDMA balloon2(balloon);
	cout << "Result of lacksDMA copy:\n";
	cout << balloon2 << endl;
	hasDMA map2;
	map2 = map;
	cout << "Result of hasDMA assignment:\n";
	cout << map2 << endl;
	return 0;
}

```

The new feature to note in Listings 13.14 and 13.15 is how derived classes can make use of a friend to a base class. Consider the following friend to the `hasDMA` class:

```C++
friend std::osteram & operator<<(std::ostream & os, const hasDMA & rs);
```

This function is not a friend to the `baseDMA` class, so it has to use the `operator<<()` function that is a friend to the `baseDMA` class.

The next problem is that because friends are not member functions, **you can't use the scopy-resolution operator to indicate which function to use. The solution is to use a type case so that prototype matching will select the correct function:**

```C++
std::ostream operator<<(std::osteram & os, const hasDMA & hs)
{
	os << (const baseDMA &) hs;
	os << "Style: " << hs.style << endl;
	return os;
}
```

## Class Design Review

### Member Functions That the Compiler Generates for You

The compiler automatically generates certain public member functions, termed _special member functions_.

#### Default Constructors

If you don't define **any** constructors, the compiler defines a default constructor. You need a default constructor to use the following:

```C++
Star rigel;
Star pleiades[6];
```

If you define a non-default constructor but fail to provide a default constructors, the code above won't run.

**An automatic default constructor for a derived class will call the default constructors for any base classes and for any members that are objects of another class**.

Also if you write a derived-class constructor without explicitly inoking a base-class constructor in the member initializer list, the compiler uses the base class default constructor.

**If you define a constructor of any kind, the compiler does not define a default constructor for you.**

#### Copy Constructors

A copy constructor is a constructor that takes an object of the class type as its argument. Typically, the declared parameter is constant reference to the class type. 

A class copy constructor is used in the following situations:
* When a **new** object is initialized to an object of the same class
* When an object is passed to a function by **value**
* When a function returns an object **by value**
* When the compiler generates a temporary object.

If a program use a copy constructor, the program defines a copy constructor that performs memberwise initialization. If a member is itself a class object, then memberwise initilization uses the copy constructor defined for that particular class. 

If some pointer members are initialized with `new`, you need to define you own copy constructor to perform deep copying.

#### Assignment Operator

Don't confuse assignment with initialization. If a statement alters the value of an **existing** object, it's assignment:

```C++
Star sirius;
Star alpha = sirius; // initialization
Star dogstar;
dogstar = sirius; // assignment.
```

Default assignment uses memberwise assignment. If a member is itself a class object, then default memberwise assignment uses the assignment operator defined for that particular class. If you need to define a copy constructor explicitly, you also need, for the same reasons, to define the assignment operator explicitly:

```C++
Star & Star::operator=(const Star &);
```

Note that the assignment operator returns a reference to a `Star` object.

If you want to assign one type to another, you can either define such a assignment operator youself, or rely on a conversion function. The second involves calling a constructor for conversion, the assignment function.

### Other Class Method Considerations

#### Constructor Considerations

Constructors are different from other class methods in that they create new objects, whereas **other methods are invokes by existing objects.** This is one reason constructors **aren't inherited**.

#### Destructor Considerations

You need to remember to define an explicit destructor that deletes any memory allocated by `new` in the class constructors.

If a class is to be used as a base class, **you should provide a virtual destructor even if the class doesn't require a destructor**. This is for the situation where an object is managed with pointer or reference by `new` and `delete`.

### Conversion Considerations

Any constructor that **can** be invoked with exactly one argument defines converison from the arguement type to the class type:

```C++
Star(const char *)
Star(const Spectral &, int members = 1);
```

For instance:

```C++
Star north;
north = "polaris";
```

Using `explicit` in the prototype for a one-argument constructor disables implicit conversions.

To convert from a class object to some other type, you define a conversion function. A conversion function is a **class member function** with **no arguments or return type** that **has the name of the type to be converted to**:

```C++
Star::double() {...}
```

C++11 provides the option of using the keyword `explicit` with conversion functions.

#### Passing an Object by Value Versus Passing a Reference

In general, if you write a function using an object argument, **you should pass the object by reference**. One reason is efficiency. This is very pratical because passing by value involves calling either a copy constructor or conversion constructor and a destructor. If the funciton doesn't modify the object, you should declare the argument as a `const` reference.

Another reason for passing objects by reference is that, in the case of inheritance **using virtual functions**, a function defined as accepting a base-class reference argument can also be used successfully with derived class.

#### Returning an Object Versus Returning a Reference

Sometimes a method **must** return an object, but if it isn't necessary, you should use a reference instead for efficiency reason.

A function shouldn't return reference to a temporary object created in the funciton.

If a function returns an object that was passed to it via a reference or pointer, you should return the object by reference.

#### Using `const`

You can use it to gurantee that a method won't modify the object the invokes it:

```C++
void Star::show() const {...};
```

Here `const` means `const Star * this`.

You can use `const` to ensure that a refence or pointer return value can't be used to modify data in an object:

```C++
const Stock & Stock::topval(const Stock & s) const
{
	if (s.total_val > total_val)
		return s;
	else
		return *this;
}
```

Here, both `s` and `*this` are themself `const`. Thus the return reference must be `const`.

Note that **if a function declares an argument as a reference or pointer to a `const`, it cannot pass along that argument to another function unless that function also guarantees not to change that argument**.

#### Public Inheritance Considerations

#### _Is-a_ Relationship Considerations

If your proposed derived class is not a particular kind of the base class, you shouldn't use the public derivation.

In some cases the best approach may be to create an abstract data class with pure virtual functions and to derive other classes from it.

#### What's Not Inherited

Constructors (**including copy constructor**) are not inherited. However, derived-class constructors must call the base-class constructors. Typically this is accomplished by using the member initializer list syntax. If the member initializer list doesn't explicitly calls a base-class constructor, is uses the base class's default constructor.

Destructor are not inherited either. However, when an object is destroyed, the program first calls the base-class destructor and then the base destructor. **Generally speaking, if a class serves as a base class, its destructor should be virtual.**

**Assignment operators are not inherited either.** The reason is simple. An inherited method has the same funciton signature in a derived class as it does in the base class.

These three types of members, constructors, destructors and assignment operators, as well as copy constructor that are not inherited, all involve a chain call to its base-class counterparts.

#### Assignment Operator Considerations

The default version of assignment is memberwise assignment.

If the object belongs to a derived class, the compiler uses the base-class assignment operator to handle assignment for the base-class portion of the derived-class object.

**You need to provide an explicit assignment operator is class constructors use `new` to initialize objects.** In this case, you need to explicitly call the base-class assignment operator in the derived class assignment operator definition:

```C++
hasDMA & hasDMA::operator=(const hasDMA & hs)
{
	auto tempStyle = new char[std::strlen(hs.style) + 1];
	std::strcpy(tempStyle, hs.style);
    delete [] style;
    style = tempStyle;
    baseDMA::operator= (hs);
	return *this;
}
```

**VERY IMPORTSNT: derived-class methods can use the scope-resolution operator to invoke public and protected base-class methods, even if this method is redefined in the derived class.** That's why this statement runs:

```C++
baseDMA::operator=(hs);
```

Assigning a derived-class object to a base-class object is much more interesting:

```C++
Brass blips;
BrassPlus snips("Rafe Plosh", 91191, 3993.19, 600.0, 0.12);
blips = snips;
```

**The assignment statment is translated into a method that is invoked by the left-hand object:**

```C++
blips.operator=(snips);
```

because this function takes a base-class reference argument, it works.

But you can't do the reverse:

```C++
Brass gp("Griff Hexbait", 21234, 1200);
BrassPlus temp;
temp = gp;
```

The left-hand object is a `BrassPlus` object, so it invokes the `BrassPlus::operator=(const BrassPlus &)` function. This code won't run unless there is also a conversion constructor:

```C++
BrassPlus(const Brass &);
```

#### Private Versus Protected Members

The protected members act like public members as far as a derived class is concerned, but they act like private members for the world at large.

#### Virtual Method Considerations

**If you want a derived class to be able to redefine a method, you define the method as virtual in the base class.**

If you don't want the method to be redefined you don't make it virtual. **This doesn't prevent someone from redefining the mthod, but it should be interpreted as meaning that you don't want it redefined.**

#### Destructors Considerations

**A base class destructor should be virtual**. That way, when you delete a derived object via a base-class pointer or reference to the object, the program uses the derived-class destructor followed by the base-class destructor rather than using only the base-class destructor.

#### Friend Considerations

Because a friend function is not acutally a member function, it's **not inherited**. You can still use a friend to the base class **by type case a derived-class reference or pointer to invoke the base-class friend**:

```C++
ostream & oeprator<<(ostream & os, const hasDMA & hs)
{
	os << (const baseDMA &) hs;
	os << "Style: " << hs.style << endl;
	return os;
}
```

#### Observations on Using Base-Class Methods

* A derived object automatically uses inherited base-class methods if the derived class hasn't redefined the method. (**Automatically generated default assignment oeprator hides the original one**)

* A derived-class destructor automatically invokes the base-class destructor

* A derived-class constructor automatically invokes the base-class default constructor if you don't specify another constructor in a member-initializer list.

* A derived class constructor explicitly invokes the base-class constructor specified in a member initializer list

* Derived-class methods **can use the scope-resolution operator to invoke public and protected base-class methods**.

* Friends to a derived class can type cast a derived-class reference or pointer to a base-class reference or pointer and then use that reference or pointer to invoke a friend to the base class.

### Class Function Summary

See P777.


## Chpater Review

1. **ALL** the data members. Public become public, protected become protected. Private members are inherited also, but can not be accessed.

2. If the base class and a derived-class both define a method with the same name, the newly defined version will be invoked by a derived-class object. **BUt the derived-class method can access base-class methods by using the scope-resolution operator**.




