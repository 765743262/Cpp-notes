# Chapter 16 The `string` Class and the Standard Template Library

In this chapter you'll learn about the following:

* The standard C++ `string` class
* The `auto_ptr`, `unique_ptr`, and `shared_ptr` templates
* The Standard Template Library
* Container classes
* Iterators
* Function objects (functors)
* STL algorithms
* The `initializer_list` template

## The `string` Class

### Constructing a String

Let's look at the `string` constructors. Listing 16.1 uses seven of the `string` constructors (labeled `ctor`, the traditional C++ abbreviation for construcotr). Table 16.1 on page 952 briefly describes the contructors. The table begins with the seven constructors used in Listing 16.1, in that order. It also lists a couple of C++11 additions.

The type `size_type` is an implementation-dependent integral type defined in the `string` header file. The class defines `string::npos` as the maximum possible length of the string. Typically, this would equal the maximum value of an `unsigned int`. Also the table uses the common abbreviation NBTS for null-byte-terminated string---that is, the traditional C string.

```C++
// Listing 16.1
#include <iostream>
#include <string>

// using string constructors

int main()
{
	using namespace std;
	string one("Lottery Winner!");		// ctor #1
    cout << one << one << endl;			// overloaded <<
	string two(20, '$');				// ctor #2
	cout << two << endl;
	string three(one);					// ctor #3
	cout << three << endl;
	one += " Oo`ps`!"; 					// overloaded +=
	cout << one << endl;
	two = "Sorry! That was ";
	three[0] = 'P';
	string four;						// ctor #4
	four = two + three;					// overloaded +, =
	cout << four << endl;
	char alls[] = "All's well that ends well";
	string five(alls, 20);				// ctor #5
	cout << five << "!\n";
	string six(alls + 6, alls + 10);	// ctor #6
	cout << six << ", ";
	string seven(&five[6], &five[10]);	// ctor #6 again
	cout << seven << "...\n";
	string eight(four, 7, 16);			// ctor #7
	cout << eight << " in motion!" << endl;
	return 0;
}
```

The start of the program in Listing 16.1 illustrates that you can initialize a `string` object to a regular C-style string and display it by using the overloaded `<<` operator:

```C++
string one("Lottery Winner!");	// ctor #1
cout << oned << endl;			// overloaded <<
```

The next constructor initializes the `string` object `two` to a string consisting of 20 `$` characters:

```C++
string two(20, '$');			// ctor #2
```

The copy constructor initializes the `string` object `three` to the `string` object `one`:

```C++
string three(one);				// ctor #3
```

The overloaded `+=` operator appends the string `" Oops!"` to the string `one`:

```C++
one += " Oops!";				// overloaded +=
```

This particular example appends a C-style string to a `string` object. However, the `+=` operator is multiply overloaded so that you can also append `string` objects and single characters:

```C++
one += two;		// append a string object (not in program)
one += '!';		// append a type char value (not int program)
```

Similarly, the `=` operator is overloaded so that you can assign a `string` object to a `string` object, a C-style string to a `string` object, or a simple `char` value to a string object:

```C++
two = "Sorry! That was ";	// assign a C-style string
two = one;					// assign a string object (not in program)
two = '?';					// assign a char value (not in program)
```

Overloading the `[]` operator, as the `String` example in Chapter 12 does, permits access to individual characters in a `string` object by using array notation:

```C++
three[0] = 'P';
```

A default constructor creates an empty string that can later be given a value:

```C++
string four;				// ctor #4
four = two + three;			// overloaded +, =
```

The second line here uses the overloaded `+` operator to create a temporary `string` object, which is then assigned, using the overloaded `=` operator, to the four object. As you might expect, the `+` operator concatenates its two operands into a single `string` object. The operator is multiply overloaded, so the second operand can be a `string` object or a C-style string or a `char` value.

The fifth constructor takes a C-style string and an integer as arguments, with the integer indicating how many characters to copy:

```C++
char all[] = "All's well that ends well";
string five(alls, 20);		// ctor #5
```

As Table 16.1 notes, if the character count exceeds the length of the C-style string, the requested number of characters is still copied. So replacing 20 with 40 in the preceding example would result in 15 junk characters being copied at the end of `five`. (That is, the constructor would interpret the contents in memory following the string `"All's well that ends well"` as character codes.)

The sixth constructor has a template argument:

```C++
template<class Iter> string(Iter begin, Iter end);
```

The intent is that `begin` and `end` act like pointers pointing to two locations in memory. (In general, `begin` and `end` can be iterators, generalizations of pointers extensively used in the STL.) The constructor then uses the values between the locations pointed to by begin and end to initialize the `string` object it constructs.

Now suppose you want to use this constructor to initialize an object to part of another
`string` object. You use the following:

```C++
string seven(&five[6], &five[10]);	// ctor #6 again
```

The seventh constructor copies a portion of one `string` object to the constructed object:

```C++
string eight(four, 7, 16);		// ctor #7
```

This statement copies 16 characters from four to eight, starting at position 7 (the
eighth character) in four.

#### C++11 Constructors

The `string(string && str) noexcept` constructor is similar to the copy constructor in that the new `string` is a copy of `str`. However, unlike the copy constructor, it doesn’t guarantee that `str` will be treated as `const`. This form of constructor is termed a _move constructor_. The compiler can use it in some situations instead of the copy constructor to optimize performance. Chapter 18, “Visiting with the New C++ Standard,” discusses this topic in the section “Move Semantics and the rvalue Reference.”

The `string(initialize_list<char> il)` constructor enables list-initialization for the `string` class. That is, it makes declarations like the following possible:

```C++
string piano_man = {'L', 'i', 's','z','t'}; 
string comp_lang {'L', 'i', 's', 'p'};
```

This chapter will discuss the `initializer_list` template further later on.

### The `String` Class Input

For `string` objects, recall, you have two options:

```C++
string stuff;
cin >> stuff;			// read a word
getline(cin, stuff);	// read a line, discard \n
```

`getline()` allows for an optional argument that specifies which character to use to delimit input:

```C++
getline(stuff, ':');	// read up to :, discard :
```

Let’s examine the `string` input functions a bit more closely. Both, as mentioned, size the target string to fit the input. There are limits. The first limiting factor is the maximum allowable size for a string, represented by the constant `string::npos`. The second limiting factor is the amount of memory available to a program.

The `getline()` function for the `string` class reads characters from the input and stores them in a `string` object until one of three things occurs:

* The end-of-file is encountered, in which case `eofbit` of the input stream is set, implying that both the `fail()` and `eof()` methods will return `true`.

*  The delimiting character (`\n`, by default) is reached, in which case it is removed from the input stream but not stored.

* The maximum possible number of characters (the lesser of `string::npos` and the number of bytes in memory available for allocation) is read, in which case `failbit` of the input stream is set, implying that the `fail()` method will return `true`.

(An input stream object has an accounting system to keep track of the error state of the stream. In this system, setting `eofbit` registers detecting the end-of-file; setting `failbit` registers detecting an input error; setting `badbit` registers some unrecognized failure, such as a hardware failure; and setting `goodbit` indicates that all is well. Chapter 17,“Input,Output,and Files,”discusses this further.)

The `operator>>()` function for the `string` class behaves similarly, except that instead of reading to and discarding a delimiting character, it reads up to a white space character and leaves that character in the input queue. 

Listing 16.2 shows a short example that reads strings from the file. It assumes that the file contains strings separated by the colon character and uses the `getline()` method of specifying a delimiter. It then numbers and displays the strings, one string to an output line.

```C++
// Listing 16.2
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>

int main()
{
	using namespace std;
	ifstream fin;
	fin.open("tobut.txt");
	if (fin.is_open() == false)
	{
		cerr << "Can't open file. Bye.";
		exit(EXIT_FAILURE);
	}
	string item;
	int count = 0;
	getline(fin, item, ':');
	while (fin)
	{
		++count;
		cout << count << ": " << item << endl;
		getline(fin, item, ':');
	}
	cout << "Done\n";
	fin.close();
	return 0;
}
```

Note that with `:` specified as the delimiting character, the newline character becomes just another regular character.

### Working with Strings

You can compare strings. All six relational operators are overloaded for `string` objects, with one object being considered less than another if it occurs earlier in the machine collating sequence. Each relational operator is overloaded three ways so that you can compare a `string` object with another `string` object, compare a `string` object with a C-style string, and compare a C-style string with a `string` object:

```C++
string snake1("cobra");
string snake2("coral");
char snake3[20] = "anaconda";
if (snake1 < snake2)
	...
if (snake1 == snake2)
	...
if (snake3 != snake2)
	...
```

You can determine the size of a string. Both the `size()` and `length()` member functions return the number of characters in a string:

```C++
if (snake1.length() == snake2.size())
	cout << "Both strings have the same length.\n";
```

Why two functions that do the same thing? The `length()` member comes from earlier versions of the `string` class, and `size()` was added for STL compatibility.

You can search a string for a given substring or character in a variety of ways. Table 16.2 on page 960 provides a short description of four variations of a `find()` method. Recall that `string::npos` is the maximum possible number of characters in a string, typically the largest `unsigned int` or `unsigned long` value.

The string library also provides the related methods `rfind()`, `find_first_of()`, `find_last_of()`, `find_first_not_of()`, and `find_last_not_of()`, each with the same set of overloaded function signatures as the `find()` method. The `rfind()` method finds the last occurrence of a substring or character. The `find_first_of()` method finds the first occurrence in the invoking string of any of the characters in the argument. For example, the following statement would return the location of the `r` in `"cobra"` (that is, the index 3) because that’s the first occurrence of any of the letters in `"hark"` in `"cobra"`:

```C++
int where = snake1.find_first_of("hark");
```

The `find_last_of()` method works the same, except it finds the last occurrence. Thus, the following statement would return the location of the `a` in `"cobra"`:

```C++
int where = snake1.find_last_of("hark");
```

The `find_first_not_of()` method finds the first character in the invoking string that is not a character in the argument. So the following would return the location of the `c` in `cobra` because `c` is not found in `hark`:

```C++
int where = snake1.find_first_not_of("hark");
```

Listing 16.3 shows a program that simulates the word game Hangman.

```C++
// Listing 16.3
#include <iostream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <cctype>
using std::string;
const int NUM = 26;
const string wordlist[NUM] = {"apiary", "beetle", "cereal",
"danger", "ensign", "florid", "garage", "health", "insult", "jackal", "keeper", "loaner", "manage", "nonce", "onset", "plaid", "quilt", "remote", "stolid", "train", "useful", "valid", "whence", "xenon", "yearn", "zippy"};

int main()
{
	using std::cout;
	using std::cin;
	using std::tolower;
	using std::endl;
	std::srand(std::time(0));
	char play;
	cout << "Will you play a word gram <y/n> ";
	cin >> play;
	play = tolower(play);
	while (play == 'y')
	{
		string target = wordlist[std::rand() % NUM];
		int length = target.length();
		string attempt(length, '-');
		string badchars;
		int guesses = 6;
		cout << "Guess my secret word. It has " << length
			 << " letters, and you guess\n"
			 << "one letter at a time. You get " << guesses
			 << " wrong guesses.\n";
		cout << "Your word: " << attempt << endl;
		while (guesses > 0 && attempt != target)
		{
			char letter;
			cout << "Guess a letter: ";
			cin >> letter;
			if (badchars.find(letter) != string::npos
					|| attempt.find(letter) != string::npos)
			{
				cout << "You already guessed that. Try again.\n";
				continue;
			}
            int loc = target.find(letter);
		
			if (loc == string::npos)
			{	
				cout << "Oh, bad guess!\n";
				--guesses;
				badchars += letter;
			}	
			else
			{
				cout << "Good guess!\n";
				attempt[loc] = letter;
				loc = target.find(letter, loc + 1);
				while (loc != string::npos)
				{
					attempt[loc] = letter;
					loc = target.find(letter, loc + 1);
				}
			}
			cout << "Your word: " << attempt << endl;
			if (attempt != target)
			{
				if (badchars.length() > 0)
					cout << "Bad choices: " << badchars << endl;
				cout << guesses << " bad guesses left\n";
			}
		}
		if (guesses > 0)
			cout << "That's right!\n";
		else
			cout << "Sorry, the word is " << target << ".\n";
		cout << "Will you play another? <y/n> ";
		cin >> play;
		play = tolower(play);
	}
	cout << "Bye\n";

	return 0;
}
```

### What Else Does the `string` Class Offer?

The `string` library supplies many other facilities. Appendix F describes the string library function briefly, but let's talk about a few more featuers here.

First, think about the automatic sizing feature. In Listing 16.3, what happens each time the program appends a letter to a string? It can’t necessarily just grow the string in place because it might run into neighboring memory that is already in use. So it may have to allocate a new block and then copy the old contents to a new location. It would be inefficient to do this a lot, so many C++ implementations allocate a block of memory larger than the actual string, giving the string room to grow. Then if the string eventually exceeds that size, the program allocates a new block twice the size to afford more room to grow without continuous resizing. The `capacity()` method returns the size of the current block, and the `reserve()` method allows you to request a minimum size for the block. Listing 16.4 shows an example that uses these methods.

```C++
#include <iostream>
#include <string>

int main()
{
	using namespace std;
	string empty;
	string small = "bit";
	string larger = "Elephants are a girl's best friend";
	cout << "Sizes.\n";
	cout << "\tempty: " << empty.size() << endl;
	cout << "\tsmall: " << small.size() << endl;
	cout << "\tlarger: " << larger.size() << endl;
	cout << "Capacities:\n";
	cout << "\tempty: " << empty.capacity() << endl;
	cout << "\tsmall: " << small.capacity() << endl;
	cout << "\tlarger: " << larger.capacity() << endl;
	empty.reserve(50);
	cout << "Capacities after empty.reserve(50): "
		 << empty.capacity() << endl;
	return 0;
}
```

Here is the output of the program in Listing 16.4 for one C++ implementation:

```
Sizes:
	empty: 0
	small: 3
	larger: 34 
Capacities:
	empty: 15 
	small: 15 
	larger: 47
Capacity after empty.reserve(50): 63
```

Note that this implementation uses a minimum capacity of 15 characters and seems to use 1 less than multiples of 16 as standard choices for capacities. Other implementations may make different choices.

What if you have a `string` object but need a C-style string? For example, you might want to open a file whose name is in a `string` object:

```C++
string filename;
cout << "Enter file name: ";
cin >> filename;
ofstream fout;
```

The bad news is that the `open()` method requires a C-style string argument. The good news is that the `c_str()` method returns a pointer to a C-style string that has the same contents as the invoking `string` object. So you can use this:

```C++
fout.open(filename.c_str());
```

## Smart Pointer Template Classes

A _smart pointer_ is a class object that acts like a pointer but has additional features.  Here we’ll look at three smart pointer templates that can help with managing the use of dynamic memory allocation. Let’s begin by taking a look at what might be needed and how it can be accomplished. Consider the following function:

```C++
void remodel(std::string & str)
{
	std::string * ps = new std::string(str);
	...
	str = *ps;
	return;
}
```

You probably see its flaw. The solution is just to remember to free the allocated memory by adding the following statement just before the `return` statement:

```C++
delete ps;
```

However, a solution involving the phrase “just remember to” is seldom the best solution. And even if you do remember, there can still be problems. Consider the following variation:

```C++
void remodel(std::string & str)
{
	std::string * ps = new std::string(str);
	...
	if (weird_thing())
		throw exception();
	str = *ps;
	delete ps;
	return;
}
```

If the exception is thrown, the delete statement isn’t reached, and again there is a memory leak. the problem with `ps` is that it is just an ordinary pointer and not a class object having a destructor. If it were an object, you could have its destructor delete the pointed-to memory when the object expires. And that is the idea behind `auto_ptr`, `unique_ptr`, and `shared_ptr`. The `auto_ptr` template is the C++98 solution. C++11 deprecates `auto_ptr` and provides the other two as alternatives. However, although deprecated, `auto_ptr` has been used for years and may be your only choice if your compiler doesn’t support the other two.

### Using Smart Pointers

These three smart pointer templates (`auto_ptr`, `unique_ptr`, and `shared_ptr` ) each defines a pointer-like object intended to be assigned an address obtained (directly or indirectly) by `new`. When the smart pointer expires, its destructor uses `delete` to free the memory. Thus, if you assign an address returned by `new` to one of these objects, you don’t have to remember to free the memory later; it will be freed automatically when the smart pointer object expires. The `shared_ptr` and `unique_ptr` share the same behaviour in this situation.

To create one of these smart pointer objects, you include the `memory` header file, which includes the template definitions. Then you use the usual template syntax to instantiate the kind of pointer you require. The `auto_ptr`, for instance, includes the following constructor:

```C++
template <class X> class auto_ptr {
public:
	explicit auto_ptr(X * p = 0) throw();	
... };
```

(The `throw()` notation, recall, means this constructor doesn’t throw an exception. Like `auto_ptr`, it is deprecated.) Thus, asking for an `auto_ptr` object of type `X` gives you an `auto_ptr` object that points to type `X`:

```C++
auto_ptr<double> pd(new double);	// pd an auto_ptr to double
									// (use in place of double * pd)
auto_ptr<string> ps(new string);	// ps an auto_ptr to string
									// (use in place of string * ps)
```

Here `new double` is a pointer returned by `new` to a newly allocated chunk of memory. It is the argument to the `auto_ptr<double>` constructor. Similarly, `new string` is also an actual argument for a constructor. The other two smart pointers use the same syntax:

```C++
unique_ptr<double> pdu(new double);	// pdu an unique_ptr to double
shared_ptr<string> pss(new string);	// pss a shared_ptr to string
```

Thus, to convert the `remodel()` function, you would follow these three steps:

1. Include the `memory` header file
2. Replace the pointer-to-`string` with a smart pointer object that points to `string`
3. Remove the `delete` statement.

Here's the function with those changes made using `auto_ptr`

```C++
#include <memory>
void remodel(std::string & str)
{
	std::auto_ptr<std::string> ps (new std::string(str));
	...
	if (weird_thing())
		throw exception();
	str = *ps;
	// delete ps;	// NO LONGER NEEDED
	return;
}
```

Note that smart pointers belong to the std namespace. Listing 16.5 presents a simple program using all three of these smart pointers.

```C++
// Listing 16.5
#include <iostream>
#include <string>
#include <memory>

class Report
{
private:
	std::string str;
public:
	Report(const std::string s) : str(s)
		{ std::cout << "Object created!\n"; }
	~Report() { std::cout << "Object deleted!\n"; }
	void comment() const { std::cout << str << "\n"; }
};

int main()
{
	{
		std::auto_ptr<Report> ps(new Report("using auto_ptr"));
		ps->comment();
	}
	{
		std::shared_ptr<Report> ps(new Report("using shared_ptr"));
		ps->comment();
	}
	{
		std::unique_ptr<Report> ps(new Report("using unique_ptr"));
		ps->comment();
	}
	return 0;
}
```


Each of these classes has an `explicit` constructor taking a pointer as an argument. Thus, there is no automatic type cast from a pointer to a smart pointer object:

```C++
shared_ptr<double> pd;
double * p_reg = new double;
pd = p_reg;							// not allowed (implicit conversion)
pd = shared_ptr<double>(p_reg);		// allowed (explicit conversion)
shared_ptr<double> pshared = p_reg;	// not allowed (implicit conversion)
shared_ptr<double> pshared(p_reg);	// allowed (explicit conversion)
```

The smart pointer template classes are defined so that in most respects a smart pointer object acts like a regular pointer. For example, given that `ps` is a smart pointer object, you can dereference it (`*ps`), use it to access structure members (`ps->puffIndex`), and assign it to a regular pointer that points to the same type. You can also assign one smart pointer object to another of the same type, but that raises an issue that the next section faces.

But first, here's something you should avoid with all three of these smart pointers:

```C++
string vacation("I wandered lonely as a cloud.");
shared_ptr<string> pvac(&vacation);	// NO!
```

When `pvac` expires, the program would apply the `delete` operator to non-heap memory, which is wrong.

### Smart Pointer Considerations

Why three smart pointers? And why is `auto_ptr` being deprecated?

Begin by considering assignment:

```C++
auto_ptr<string> ps(new string("I reigned lonely as a cloud."));
auto_ptr<string> vocation;
vocation = ps;
```

If `ps` and `vocation` were ordinary pointers, the result would be two pointers pointing to the same `string` object. That is not acceptable here because the program would wind up attempting to delete the same object twice—once when `ps` expires, and once when `vocation` expires. There are ways to avoid this problem:

* Define the assignemnt operator so that it makes a deep copy
* Institute the concept of _ownership_, with only one smart pointer allowed to own a particular object. Only if the smart pointer owns the object will its destructor delete the object. Then have assignment transfer ownership. This is the strategy used for `auto_ptr` and for `unique_ptr`, although `unique_ptr` is somewhat more restrictive.
* Create an even smarter pointer that keeps track of how many smart pointer refer to a particular object. This is called _reference counting_. Assignment, for example, would increase the count by one, and the expiration of a pointer would decrease the count by one. Only when the final pointer expires would `delete` be invoked. This is the `shared_ptr` strategy.

The same strategies we’ve discussed for assignment, of course, would also apply to the copy constructors.

Each approach has its uses. Listing 16.6 shows an example for which `auto_ptr` is poorly suited.

```C++
// Listing 16.6
#include <iostream>
#include <string>
#include <memory>

int main()
{
	using namespace std;
	auto_ptr<string> films[5] =
	{
		auto_ptr<string>(new string("Fowl Balls")),
		auto_ptr<string>(new string("Duck Walks")),
		auto_ptr<string>(new string("Chichen Runs")),
		auto_ptr<string>(new string("Turkey Erros")),
		auto_ptr<string>(new string("Goose Eggs"))
	};
	auto_ptr<string> pwin;
	pwin = films[2];	// films[2] loses ownership

	cout << "The nominee for best avian baseball film are\n";
	for (int i = 0; i < 5; i++)
		cout << *films[i] << endl;
	cout << "The winner is " << *pwin << "!\n";
	cin.get();
	return 0;
}
```

The program will crash. The problem is that the following statement transfers ownership from `film[2]` to `pwin`:

```C++
pwin = films[2];	// films[2] loses ownership
```

That causes `films[2]` to no longer refer to the `string`. After an `auto_ptr` gives up ownership of an object, it no longer provides access to the object. When the program goes to print the string pointed to by `films[2]`, it finds the null pointer, which apparently is an unpleasant surprise.

Suppose you go back to Listing 16.6 but use `shared_ptr` instead of `auto_ptr`. Then the program runs fine. The difference occurs in this part of the program:

```C++
shared_ptr<string> pwin;
pwin = films[2];
```

This time both `pwin` and `films[2]` point to the same object, and the reference count is upped from 1 to 2. At the end of the program, `pwin`, which was declared last, is the first object to have its destructor called. The destructor decreases the reference count to 1. Then the members of the array of `shared_ptrs` are freed. The destructor for `films[2]` decrements the count to 0 and frees the previously allocated space.

What happends if you use `unique_ptr`? Like `auto_ptr`, `unique_ptr` incorporates the ownership model. Yet instead of crashing, the `unique_ptr` version yields a compile-time error objecting to this line:

```C++
pwin = films[2];
```

Why `unique_ptr` Is Better than `auto_ptr`

Consider the following statement:

```C++
auto_ptr<string> p1(new string("auto"));	// #1
auto_ptr<string> p2;						// #2
p2 = p1;									// #3
```

When, in statement #3, `p2` takes over ownership of the `string` object, `p1` is stripped of ownership. This, recall, is good because it prevents the destructors for both `p1` and `p2` from trying to delete the same object. But it also is bad if the program subsequently tries to use p1 because p1 no longer points to valid data.

Now consider the `unique_ptr` equivalent:

```C++
unique_ptr<string> p3(new string("auto"));	// #4
unique_ptr<string> p4;						// #5
p4 = p3;									// #6
```

In this case, the compiler does not allow statement #6, so we avoid the problem of `p3` not pointing to valid data. Hence, `unique_ptr` is safer than `auto_ptr`.

But there are times when assigning one smart pointer to another doesn't leave a dangerous orphan behind. Suppose we have this function definition:

```C++
unique_ptr<string> demo(const char * s)
{
	unique_ptr<string> temp(new string(s));
	return temp;
}
```

And suppose we then have this code:

```C++
unique_ptr<string> ps;
ps = demo("Uniquely special");
```

Here, `demo()` returns a temporary `unique_ptr`, and then `ps` takes over the ownership of the object originally owned by the returned `unique_ptr`. Because the temporary `unique_ptr` returned by `demo()` is soon destroyed, there’s no possibility of it being misused in an attempt to access invalid data. In other words, there is no reason to forbid assignment in this case. And, miraculously enough, the compiler does allow it!

In short, if a program attempts to assign one `unique_ptr` to another, the compiler allows it if the source object is a temporary rvalue and disallows it if the source object has some duration:

```C++
using namespace std;
unique_ptr<string> pu1(new string("Hi ho!"));
unique_ptr<string> pu2;
pu2 = pu1;										// #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string "Yo!");		// #2 allowed
```

Assignment #1 would leave a dangling `unique_ptr` behind (that is, `pu1`), a possible source of mischief. Assignment #2 leaves no `unique_ptr` behind because it invokes the `unique_ptr` constructor, which constructs a temporary object that is destroyed when ownership is transferred to `pu3`. This selective behavior is one indication that `unique_ptr` is superior to `auto_ptr`, which would allow both forms of assignment. It’s also the reason that `auto_ptrs` are banned (by recommendation, not by the compiler) from being used in container objects, whereas `unique_ptr`s are allowed.

C++ does have a standard library function called `std::move()` that lets you assign one `unique_ptr` to another. Here is an example using the previously defined `demo()` function, which returns a `unique_ptr<string>` object:

```C++
using namespace std;
unique_ptr<string> ps1, ps2;
ps1 = demo("Uniquely special");
ps = move(ps1);
ps1 = demo(" and more");
cout << *ps2 << *ps1 << endl;
```

You may be wondering how `unique_ptr`, unlike `auto_ptr`, is able to discriminate between safe and possibly unsafe uses. The answer is that it uses the C++11 additions of move constructors and rvalue references, as discussed in Chapter 18.

Also `unique_ptr` has another advantage over `auto_ptr`. It has a variant that can be used with arrays. The `auto_ptr` can only be used with `new`, not with `new []`. But `unique_ptr` has a `new []`, `delete []` version:

```C++
std::unique_ptr<double []> pda(new double(5));	// will use delete []
```

> **Caution**

> You should use an `auto_ptr` or `shared_ptr` object only for memory allocated by `new`, not for memory allocated by `new[]`. You should not use `auto_ptr`, `shared_ptr`, or `unique_ptr` for memory not allocated via `new`, or, in the case of `unique_ptr` via `new` or `new []`.

### Selecting a Smart Pointer

Which pointer type should you use? If the program uses more than one pointer to an object, `shared_ptr` is your choice. For instance, you may have an array of pointers and use some auxiliary pointers to identify particular elements, such as the largest and the smallest. Or you could have two kinds of objects that contain pointers to the same third object. Or you might have an STL container of pointers. Many of the STL algorithms include copy or assignment operations that will work with `shared_ptr` but not with `unique_ptr` (you’ll get a compiler warning) or `auto_ptr` (you’ll get undefined behavior)

If the program doesn’t need multiple pointers to the same object, `unique_ptr` works. It’s a good choice for the return type for a function that returns a pointer to memory allocated by `new`. That way, ownership is transferred to the `unique_ptr` assigned the return value, and that smart pointer takes on the responsibility of calling `delete`. You can store `unique_ptr` objects in an STL container providing you don’t invoke methods or algorithms, such as `sort()`, that copy or assign one `unique_ptr` to another. For example, assuming the proper includes and using statements, code fragments like the following could be used in a program:

```C++
unique_ptr<int> make_int(int n)
{
	return unique_ptr<int>(new int(n));
}
void show(unique_ptr<int> & pi)		// pass by reference
{
	cout << *a << ' ';
}
int main()
{
	...
	vector<unique_ptr<int>> vp(size);
	for (int i = 0; i < vp.size(); i++)
		vp[i] = make_int(rand() % 1000);	// copy temporary unique_ptr
	vp.push_back(make_int(rand() % 1000))	// ok because arg is temporary
	for_each(vp.begin(), vp.end(), show);	// use for_each()
...
}
```

The call to `push_back()` works because it passes a temporary `unique_ptr` to be assigned to a `unique_ptr` in `vp`. Also note the `for_each()` statement would fail if `show()` were passed an object by value instead of by reference because then it would be necessary to initialize `pi` to a nontemporary `unique_ptr` from `vp`, which isn’t allowed.

You can assign a `unique_ptr` to `shared_ptr` under the same conditions that you can assign one `unique_ptr` to another—--the source has to be an rvalue. As previously, in the following code `make_int()` is a function with a `unique_ptr`<int> return type:

```C++
unique_ptr<int> pup(make_int(rand() % 1000));	// ok
shared_ptr<int> spp(pup);						// not allowed, pup an lvalue
shared_ptr<int> spr(make_int(rand() % 1000));	// ok
```

The `shared_ptr` template includes an explicit constructor for converting an rvalue `unique_ptr` to a `shared_ptr`.The `shared_ptr` takes over ownership of the object previously owned by the `unique_ptr`.

## The Standard Template Library

The STL provides a collection of templates representing containers, iterators, function objects, and algorithms. 

### The `vector` Template Class

To create a `vector` template object, you use the usual `<type>` notation to indicate the type to be used. Also the `vector` template uses dynamic memory allocation, and you can use an initialization argument to indicate how many `vector` elements you want:

```C++
#include <vector>
using namespace std;
vector<int> ratings(5);		// a vector of 5 ints
int n;
cin >> n;
vector<double> scores(n);	// a vector of n ints
```

After you create a `vector` object, operator overloading for `[]` makes it possible to use the usual array notation for accessing individual elements:

```C++
ratings[0] = 9;
for (int i = 0; i < n; i++)
	cout << scores[i] << endl;
```

> **Allocators Again**

> Like the string class, the various STL container templates take an optional template argument that specifies what allocator object to use to manage memory. For example, the vector template begins like this:

```C++
template <class T, class Allocator = allocaotr<T>>
	class vector {...
```

> If you omit a value for this template argument, the container template uses the `allocator<T>` class by default. This class uses `new` and `delete`.

Listing 16.7 uses this class in an undemanding application. This particular program creates two `vector` objects, one an `int` specialization and one a `string` specialization; each has five elements.

```C++
// Listing 16.7
#include <iostream>
#include <string>
#include <vector>

const int NUM = 5;
int main()
{
	using std::vector;
	using std::string;
	using std::cin;
	using std::cout;
	using std::endl;

	vector<int> ratings(NUM);
	vector<string> titles(NUM);
	cout << "You will do exactly as told. You will enter\n"
		 << NUM << " book titles and yours ratings (0-10).\n";
	for (int i = 0; i < NUM; i++)
	{
		cout << "Enter title #" << i + 1 << ": ";
		getline(cin, titles[i]);
		cout << "Enter your rating (0-10): ";
		cin >> ratings[i];
		cin.get();
	}
	cout << "Thank you. You entered the following:\n"
		 << "Rating\tBook\n";
	for (int i = 0; i < NUM; i++)
	{
		cout << ratings[i] << "\t" << titles[i] << endl;
	}
	return 0;
}
```

### Things to Do to Vectors

All the STL containers provide certain basic methods, including `size()`, which returns the number of elements in a container, `swap()`, which exchanges the contents of two containers, `begin()`, which returns an iterator that refers to the first element in a container, and `end()`, which returns an iterator that represents past-the-end for the container.

An _iterator_ is a generalization of a pointer. In fact, it can be a pointer. Or it can be an object for which pointer-like operations such as dereferencing (for example, `operator*()`) and incrementing (for example, `operator++()`) have been defiend. Each container class defines a suitable iterator. The type name for this iterator is a class scope `typedef` called `iterator`. For example, to declare an iterator for a type `double` specialization of `vector`, you would use this:

```C++
vector<double>::iterator pd;	// pd an iterator
```

Suppose `scores` is a `vector<double>` object:

```C++
vector<double> scores;
```

Then you can use the iterator `pd` in code like the following:

```C++
pd = scores.begin();	// have pd point to the first element
*pd = 22.3;				// dereference pd and assign value to first element
++pd;					// make pd point to the next element
```

As you can see, an iterator behaves like a pointer. By the way, here’s another place the C++11 automatic type deduction can be useful. Instead of, say,

```C++
vector<double>::iterator pd = scores.begin();
```

you can use this:

```C++
auto pd = scores.begin();	// C++ automatic type deduction
```

Returning to the example, what’s _past-the-end_? It is an iterator that refers to an element **one past the last element** in a container. The `end()` member function identifies the past-the-end location. If you set an iterator to the first element in a container and keep incrementing it, eventually it will reach past-the-end, and you will have traversed the entire contents of the container. Thus, if `scores` and `pd` are defined as in the preceding example, you can display the contents with this code:

```C++
for (pd = scores.begin(); pd != scores.end(); pd++)
	cout << *pd << endl;
```

All containers have the methods just discussed. The `vector` template class also has some methods that only some STL containers have. One handy method, called `push_back()`, adds an element to the end of a `vector`. While doing so, it attends to memory management so that the vector size increases to accommodate added members. This means you can write code like the following:

```C++
vector<double> scores;	// create an empty vector
double temp;
while (cin >> temp && temp >= 0)
	scores.push_back(temp);
cout << "You entered " << scores.size() << " scores.\n";
```

You don’t have to pick the number of element when you write the program or when you run the program. As long as the program has access to sufficient memory, it will expand the size of `scores` as necessary.

The `erase()` method removes a given range of a vecotr. It takes two iterator arguments that define the range to be removed. For example, the following erases the first and the second elements---that is, those refered to by `begin()` and `begin() + 1`:

```C++
scores.erase(scores.begin(), scores.begin() + 2);
```

If `it1` and `it2` are two iterators, the STL literature uses the notation `[p1, p2)` to indicate a range starting with `p1` and goint up to, but no including `p2`. Thus, the range `[begin(), end()` encompasses the entire contents of a collection. Also the range `[p1, p1)` is empty.

An `insert()` method complements `erase()` It takes three iterator arguments. The first gives the position **ahead of which** new elements are to be inserted. The second and third iterator parameters define the range to be inserted. This range typically is part of another container object. For example, the following code inserts all but the first element of the `new_v` ahead of the first element of the `old_v` vector:

```C++
vector<int> old_v;
vector<int> new_v;
...
old_v.insert(old_v.begin(), new_v.begin() + 1, new_v.end());
```

Incidentatlly, this is a case where having a past-the-end element is handy because it makes it simple to append something to the end of a vector. In this code the new material is inserted ahead of `old.end()`, meaning it's placed _after_ the last element in the vector:

```C++
old_v.insert(old_v.end(), new_v.begin() + 1, new_v.end());
```

Listing 16.8 illustrates the use of `size()`, `begin()`, `end()`, `push_back()`, `erase()` and `insert()`.

```C++
// Listing 16.8

#include <iostream>
#include <string>
#include <vector>

struct Review
{
	std::string title;
	int rating;
};

bool FillReview(Review & rr);
void ShowReview(const Review & rr);

int main()
{
	using std::cout;
	using std::vector;
	vector<Review> books;
	Review temp;
	while (FillReview(temp))
		books.push_back(temp);
	int num = books.size();
	if (num > 0)
	{
		cout << "Thank you. You entered the following:\n"
			 << "Rating\tBook\n";
		for (int i = 0; i < num; i++)
			ShowReview(books[i]);
		cout << "Resprising:\n"
			 << "Rating\tBook\n";
		vector<Review>::iterator pr;
		for (pr = books.begin(); pr != books.end(); pr++)
			ShowReview(*pr);
		vector<Review> oldlist(books);	// copy constructor used
		if (num > 3)
		{
			// remove two items
			books.erase(books.begin() + 1, books.begin() + 3);
			cout << "After erasure:\n";
			for (pr = books.begin(); pr != books.end(); pr++)
				ShowReview(*pr);
			// insert 1 item
			books.insert(books.begin(), oldlist.begin() + 1,
						oldlist.begin() + 2);
			cout << "After insertion:\n";
			for (pr = books.begin(); pr != books.end(); pr++)
				ShowReview(*pr);
		}
		books.swap(oldlist);
		cout << "Swapping oldlist with books:\n";
		for (pr = books.begin(); pr != books.end(); pr++)
			ShowReview(*pr);
	}
	else
		cout << "Nothing entered, nothing gained.\n";
	return 0;
	return 0;
}

bool FillReview(Review & rr)
{
	std::cout << "Enter book title (quit to quit): ";
	std::getline(std::cin, rr.title);
	if (rr.title == "quit")
		return false;
	std::cout << "Enter book rating: ";
	std::cin >> rr.rating;
	if (!std::cin)
		return false;
	// get rid of rest of input line
	while (std::cin.get() != '\n')
		continue;
	return true;
}

void ShowReview(const Review & rr)
{
	std::cout << rr.rating << "\t" << rr.title << std::endl;
}
```

### More Things to Do to Vectors

There are many things programmers commonly do with arrays, such as search them, sort them, randomize the order, and so on. The vector template class does **not** have methods for these common operations. However, the STL takes a broader view, defining _nonmember_ functions for these operations. Thus, instead of defining a separate `find()` member function for each container class, it defines a single `find()` nonmember function that can used for all container classes.

On the other hand, the STL sometimes defines a member function even if it also defines a nonmember function for the same task. The reason is that for some actions, there is a class-specific algorithm that is more efficient than the more general algorithm. One the other hand, the nonmember version will allow you swap contents between two **different kinds of containers**.

Let's examine three representive STL functions: `for_each()`, `random_shuffle()`, and `sort()`. The `for_each()` function can be used with **any** container class. It takes three arguments. The first two are iterators that define a range in the container, and the last is a pointer to a function. (More generally, the last argument is a function object). The `for_each()` function then applies the pointed-to function to each container element in the range. The pointed-to function must **not** alter the value of the container elements. 

You can use the `for_each()` funciton instead of a `for` loop. For example, you can replace the code

```C++
vector<double>::iterator pr;
for (pr = books.begin(); pr != books.end(); pr++)
	ShowReview(*pr);
```

with the following:

```C++
for_each(books.begin(), books.end(), ShowReview);
```

This enables you to avoid dirtying your hands (and code) with explicit use of iterator variables.

The `random_shuffle()` function takes two iterators that specify a range and rearranges the elements in the range in random order. For example, the following statement randomly rearrages the order of all the elements in the `books` vector:

```C++
random_shuffle(books.begin(), books.end());
```

Unlike, `for_each()`, which works with any container class, this function requires that the container class **allow random access**, which the `vector` class does.

The `sort()` function, too, requires that the container support random access. It comes in two versions. The first version takes two iterators that define a range, and it sorts that range by **using the `<` operator defined for the type element stored in the container**. For example, the following sorts the contents of `coolstuff` in ascending order, using the built-in `<` operator to compare values:

```C++
vector<int> coolstuff;
...
sort(coolstuff.begin(), coolstuff.end());
```

If the container elements are user-defined objects, then there has to be an `operator<()` function defined that works with that type of object in order to use `sort()`. For example, you could sort a vector containing `Review` objects if you provided either a `Review` member function or a nonmember function for `operator<()`. Because `Review` is a structure, its members are public, and a nonmember function like this would serve:

```C++
bool operator<(const Review & r1, const Review & r2)
{
	if (r1.title < r2.title)
		return true;
	else if (r1.title == r2.title && r1.rating < r2.rating)
		return true;
	else
		return false;	
}
```

With a function like this in place, you could then sort a vector of `Review` objects:

```C++
sort(books.begin(), books.end());
```

Suppose you want to sort in decreasing order or in order of ratings instead of titles. In such a case, you can use the second form of `sort()`. It takes three arguments. The first two, again, are iterators that indicate the range. The final argument is a pointer to a function (more generally, a function object) to be used instead of `operator<()` for mak- ing the comparison. The return value should be convertible to `bool`, with `false` meaning the two arguments are in the wrong order. Here’s an example of such a function:

```C++
bool WorseThan(const Review & r1, const Review & r2)
{
	if (r1.rating < r2.rating)
		return true;
	else
		return false;
}
```

With this function in place, you can use the following statement to sort the `books` vector of `Review` objects in order of increasing rating values:

```C++
sort(books.begin(), books.end(), WorseThan);
```

Listing 16.9 illustrate the use of these STL functions.

```C++
// Listing 16.9
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

struct Review
{
	std::string title;
	int rating;
};

bool operator<(const Review & r1, const Review & r2);
bool worsethan(const Review & r1, const Review & r2);
bool FillReview(Review & rr);
void ShowReview(const Review & rr);

int main()
{
	using namespace std;
	vector<Review> books;
	Review temp;
	while (FillReview(temp))
		books.push_back(temp);
	if (books.size() > 0)
	{
		cout << "Thank you. You entered the following "
			 << books.size() << " ratings:\n"
			 << "Rating\tBook\n";
		for_each(books.begin(), books.end(), ShowReview);

		sort(books.begin(), books.end());
		cout << "Sorted by title:\nRating\tBook\n";
		for_each(books.begin(), books.end(), ShowReview);

		sort(books.begin(), books.end(), worsethan);
		cout << "Sorted by rating:\nRating\tBook\n";
		for_each(books.begin(), books.end(), ShowReview);

		random_shuffle(books.begin(), books.end());
		cout << "After shuffling:\nRating\tBook\n";
		for_each(books.begin(), books.end(), ShowReview);
	}
	else
		cout << "No entries. ";
	cout << "Bye.\n";
	return 0;
}

bool operator<(const Review & r1, const Review & r2)
{
	if (r1.title < r2.title)
		return true;
	else if (r1.title == r2.title && r1.rating < r2.rating)
		return true;
	else
		return false;
}

bool worsethan(const Review & r1, const Review & r2)
{
	if (r1.rating < r2.rating)
		return true;
	else
		return false;
}

bool FillReview(Review & rr)
{
	std::cout << "Enter book title (quit to quit): ";
	std::getline(std::cin, rr.title);
	if (rr.title == "quit")
		return false;
	std::cout << "Enter book rating: ";
	std::cin >> rr.rating;
	if (!std::cin)
		return false;
	// get rid of rest of input line
	while (std::cin.get() != '\n')
		continue;
	return true;
}

void ShowReview(const Review & rr)
{
	std::cout << rr.rating << "\t" << rr.title << std::endl;
}
```

### The Range-Based `for` Loop (C++11)

The range-based `for` loop is designed to work with the STL. To review, here's the first example from Chapter 5:

```C++
double prices[5] = {4.99, 10.99, 6.87, 7.99, 8.49};
for (double x : prices)
	cout << x << std::endl;
```

The contents of the parentheses for the `for` loop declare a variable of the type stored in a container and then the name of the container. Next, the body of the loop uses the named variable to access each container element in turn. Consider, for instance, this statement from Listing 16.9:

```C++
for_each(books.begin(), books.end(), ShowReview);
```

It can be replaced with the following range-based `for` loop:

```C++
for (auto x : books) ShowReview(x);
```

Unlike `for_each()`, the range-based `for` **can alter the contents of a container**. The trick is to specify a reference parameter. For example, suppose we have this funciton:

```C++
void InflateReview(Review & r) {r.rating++;}
```

You could apply this function to each element in `books` with the following loop:

```C++
for (auto & x : books) InflateReview(x);
```

## Generic Programming

A goal of generic programming is to write code that is independent of data types. Templates are the C++ tools for creating generic programs. Templates, of course, let you define a function or class in terms of a generic type. The STL goes further by providing a generic representation of algorithms. Templates make this possible, but not without the added element of careful and conscious design. To see how this mixture of templates and design works, let’s look at why iterators are needed.

### Why Iterators

Just as templates make algorithms independent of the type of data stored, iterators make the algorithms independent of the type of container used. Thus, they are an essential componenet of the STL's generic approach.

Let's consider searching a container for a value, using a function called `find()`. The goal of generic programming in this case would be to have a single `find` function that would work with arrays or linked lists or any other container type. That is, not only should the function be independent of the data type stored in the container, it should be **independent of the data structure** of the container itself. Templates provide a generic representation for the data type stored in a container. What’s needed is a generic representation of the process of moving through the values in a container. The iterator is that generalized representation. 

What properties should an iterator have in order to implement a `find` function? Here's a short list:

* You should be able to dereference an iterator in order to access the value to which it refers. That is, if `p` is an iterator, `*p` should be defined.
* You should be able to assign oen iterator to another. That is, if `p` and `q` are iterators, the expression `p = q` should be defined.
* You should be able to compare one iterator to another for equality. That is, if `p` and `q` are iterators, the expressions `p == q` and `p != q` should be defined.
* You should be able to move an iterator through all the elements of a container. This can be satisfied by defining `++p` and `p++` for an iterator `p`.

To use a container class, you don't need to know how its iterators are implemented nor how past-the-end is implemented. It's enough to know that it does have iterators, that `begin()` returns an iterator to the first element, and that `end()` returns an iterator to past-the-end. For example, suppose you want to print the values in a `vector<double>` object. In that case, you can use this:

```C++
vector<double>::iterator pr;
for (pr = scores.begin(); pr != scores.end(); pr++)
	cout << *pr << endl;
```

Here the following line identifies `pf` as the iterator type defined for the `vector<double>` class:

```C++
vector<double>::iterator pr;
```

If you used the `list<double>` class template instead to store scores, you could use this code:

```C++
list<double>::iterator pr;
for (pr = scores.begin(); pr != scores.end(); pr++)
	cout << *pr << endl;
```

With C++ automatic type deduction, you can simplify further and use the following code with either the vector or the list:

```C++
for (auto pr = scores.begin(); pr != scores.end(); pr++)
	cout << *pr << endl;
```

Actually, as a matter of style, it's better to avoid using the iterators directly; instead, if possible, you should use an STL function, such as `for_each()`, that takes care of the details for you. Alternatively, use the C++11 range-based `for` loop:

```C++
for (auto x : scores) cout << x << endl;
```

### Kinds of Iterators

Different algorithms have different requirements for iterators. For example, a find algorithm needs the `+` operator to be defined so the iterator can step through the entire container. It needs read access to data but not write access. The usual sorting algorithm, on the other hand, requires random access so that it can swap two non-adjacent elements. If `iter` is an iterator, you can get random access by defining the `+` operator so that you can use expresssions such as `iter + 10`. Also a sort algorithm needs to be able to both read and write data.

The STL defines five kinds of iterators and **desribes its algorithms in terms of which kinds of iterators it needs**. The five kinds are the input iterator, output iterator, forward iterator, bidirectional iterator, and random access iterator. For example, the `find()` prototype looks like this:

```C++
template <class InputIterator, class T>
InputIterator find(InputIterator first, Input last, const T & value);
```

This tells you that this algorithm requires an input iterator. Similarly, the following prototype tells you that the sort algorithm requires a random access iterator:

```C++
template <class RandomAccessIterator>
void sort(RandomAccessIterator first, RandomAccessIterator last);
```

All five kinds of iterator can be dereferenced (this is, the `*` operator is defined for them) and can be compared for equality and inequality (using the `==` and `!=` operator). 

Of course, these properties hold true for built-in operators and pointers, so these requirements are guides for what you must do when overloading these operators for an iterator class. Now let’s look at other iterator properties.

#### Input Iterators

An input iterator is one that a program can use to read values from a container. In particular, dereferencing an input iterator must allow a program to read a value from a container, but it needn’t allow a program to alter that value. So algorithms that require an input iterator are algorithms that don’t change values held in a container.

An input iterator has to allow you to access all the values in a container. It does so by supporting the `++` operator, both in prefix and suffix form. If you set an input operator to the first element in a container and increment it until it reaches past-the-end, it will point to every container item once en route. Incidentally, there is no guarantee that traversing a container a second time with an input iterator will move through the values in the same order. Also after an input iterator has been incremented, there is no guarantee that its prior value can still be dereferenced. Any algorithm based on an input iterator, then, should be **a single-pass algorithm that doesn’t rely on iterator values from a previous pass or on earlier iterator values from the same pass**.

Note that an input iterator is a one-way iterator; it can increment, but it can't back up.

#### Output Iterators

In STL usage, the term _output_ indicates that the iterator is used for transferring information from a program to a container. An output iterator is similar to an input iterator, except that dereferencing is guaranteed to allow a program to alter a container value but not to read it.

In short, you can use an input iterator for single-pass, read-only algorithms and an output operator for single-pass, write-only algorithms.

#### Forward Iterators

Like input and output iterators, forward iterators use only the `++` operators for navigating through a container. So a forward iterator can only go forward through a container one element at a time. However, unlike input and output iterators, it necessarily goes through a sequence of values **in the same order each time you use it**. Also after you increment a forward iterator, you can still dereference the prior iterator value, if you’ve saved it, and get the same value. These properties make **multiple-pass algorithms** possible.

A forward iterator can allow you to both read and modify data, or it can allow you just to read it.

#### Bidirectional Iterators

A bidirectional iterator has all the features of a forward iterator and adds support for the two decrement operators (prefix and postfix).

#### Random Access Iterators

Some algorithms, such as standard sort and binary search, require the ability to jump directly to an arbitrary element of a container. This is termed _random access_, and it requires a random access iterator. This type of iterator has all the features of a bidirectional iterator, plus it adds operations (such as pointer addition) that support random access and relational operators for ordering the elements. Table 16.3 on page 999 lists the operations a random access iterator has beyond those of a bidirectional iterator. In this table, `X` represents a random iterator type, `T` represents the type pointed to, `a` and `b` are iterator values, `n` is an integer, and `r` is a random iterator variable or reference.

Expression such as `a + n` are valid only if both `a` and `a + n` lie within the range of the container.

### Iterator Hierarchy

Table 16.4 on page 1000 summarizes the main iterator capabilities. In it, `i` is an iterator, and `n` is an integer.

An algorithm written **in terms of a particular kind of iterator** can use that kind of iterator or any other iterator that has the required capabilities. So a container with, say, a ran- dom access iterator can use an algorithm written for an input iterator.

Why all these different kinds of iterators? The idea is to write an algorithm using the iterator with the fewest requirements possible, allowing it to be used with the largest range of containers. Thus, the `find()` function, by using a lowly input iterator, can be used with any container that contains readable values. The `sort()` function, however, by requiring a random access iterator, can be used just with containers that support that kind of iterator.

### Concepts, Refinements, and Models

An STL algorithm works with any iterator implementation that meets its requirements. STL literature uses the word _concept_ to describe a set of requirements. Thus, there is an input iterator concept, a forward iterator concept, and so on. 

Concepts can have an inheritance-like relationship. For example, a bidirectional iterator inherits the capabilities of a forward iterator. However, you can’t apply the C++ inheritance mechanism to iterators. Conceptually, however, it does inherit. Some STL literature uses the term _refinement_ to indicate this conceptual inheritance. Thus, a bidirectional iterator is a refinement of the forward iterator concept. 

A particular implementation of a concept is termed a _model_. Thus, an ordinary pointer-to-int is a model of the concept random access iterator. It’s also a model of a forward iterator, for it satisfies all the requirements of that concept.

#### The Pointer As Iterator

Iterators are generalizations of pointers, and a pointer satisfies all the iterator requirements. Iterators form the interface for STL algorithms, and pointers are iterators, so **STL algorithms can use pointers to operate on non-STL containers that are based on pointers**. For example, you can use STL algorithms with arrays. Suppose `Receipts` is an array of `double` values, and you would like to sort in ascending order:

```C++
const int Size = 100;
double Receipts[Size];
```

The STL `sort()` function, recall, takes as arguments an iterator pointing to the first element in a container and an iterator pointing to past-the-end. Thus, the following function call sorts the array:

```C++
sort(Receipts, Receipts + Size);
```

C++ guarantees that the expression `Receipts + n` is defined as long as the result lies in the array or one past-the-end. Thus, the fact that pointers are iterators and that algorithms are iterator based makes it possible to apply STL algorithms to ordinary arrays. Similarly, you can apply STL algo- rithms to data forms of your own design, provided that you supply suitable iterators (which may be pointers or objects) and past-the-end indicators.

#### `copy`, `ostream_iterator`, and `istream_iterator`

The STL provides some predefined iterators. To see why, let’s establish some background. There is an algorithm called `copy()` for copying data from one container to another. This algorithm is expressed in terms of iterators, so it can copy from one kind of container to another or even from or to an array, because you can use pointers into an array as iterators. For example, the following copies an array into a vector:

```C++
int casts[10] = {6, 7, 2, 9, 4, 11, 8, 7, 10, 5};
vector<int> dice[10];
copy(casts, casts + 10, dice.begin());	// copy array to vector
```

The first two arguments to `copy()` represent a range to be copied, and the final iterator argument represents the location to which the first item is copied. The first two argument must be input iterators (or better), and the final iterator must be an output iterator (or better). The `copy()` function overwrites existing data in the destination container, and it assumes that the container has to be large enough to hold the copied elements. So you **can't use `copy()` to place data in an empty vector---at least not without resorting to a trick that is revealed later in this chatper**.

Now suppose you want to copy information to the display. The STL provides such an iterator with the `ostream_iterator` template. Using STL terminology, this template is a _model_ of the output iterator concept. It is also an example of an _adapter_---a class or function that converts some other interface to an interface used by the STL. You can create an iterator of this kind by including the `iterator` header file and making a declaration:

```C++
#include <iterator>
...
ostream_iterator<int, char> out_iter(cout, " ");
```

The `out_iter` iterator noew becomes an interface that allows you to use `cout` to display information. The first template argument indicates the data type being sent to the output stream. The second template argument indicates the character type used by the output stream. The first constructor argument identifies the output stream being used. The final character string argument is a separator to be displayed after each item sent to the output stream.

You could use the iterator like this:

```C++
*out_iter++ = 15;	// works like cout << 15 << " ";
```

You could use the iterator with `copy()` as follows:

```C++
copy(dice.begin(), dice.end(), out_iter);	// copy vector to output stream
```

This would mean to copy the entire range of the `dice` container to the output stream---that is, to display the contents of the container.

Or you could skip creating a named iterator and construct an anonymous iterator instead. That is, you could use the adapter like this:

```C++
copy(dice.begin(), dice.end(), ostream_iterator<int, char>(cout, " "));
```

Similarly, the `iterator` header file defines an `istream_iterator` template for adapting `istream` input to the iterator interface. It is a model of the input iterator concept. You could use two `istream_iterator` objects to define an input range for `copy()`:

```C++
copy(istream_iterator<int, char>(cin), istream_iterator<int, char>(), dice.begin());
```

Like `ostream_iterator`, `istream_iterator` uses two template arguments. The first indicates the data type to be read, and the second indicates the character type used by the input stream. Using a constructor argument indicates input failure, so the previous code means to read from the input stream until end-of-file, type mismatch, or some other input failure.

#### Other Useful Iterators

The `iterator` header file provides some other special-purpose predefined iterator types in addition to `ostream_iterator` and `istream_iterator`. They are `reverse_iterator`, `back_insert_iterator`, `front_insert_iterator`, and `insert_interator`.

Let's start with seeing what a reverse iterator does. In essence, incrementing a reverse iterator causes it to decrement. Why not just decrement a regular iterator? The main reason is to simplify using existing functions. Suppose you want to display the contents of the `dice` container. As you just saw, you can use `copy()` and `ostream_iterator` to copy the contents to the output stream:

```C++
ostream_iterator<int, char>(cout, " ");
copy(dice.begin(), dice.end(), out_iter);	// display in forward order
```

Now suppose you want to print the contents in reverse order. The `vector` class has a member function called `rbegin()` that returns a reverse iterator pointing to past-the-end and a member `rend()` that returns a reverse iterator pointing to the first element. Because incrementing a reverse iterator makes it decrement, you can use the following statement to display the contents backward:

```C++
copy(dice.rbegin(), dice.rend(), out_iter);	// display in reverse order
```

You don't even have to declare a reverse iterator

> **Note**

> Both `rbegin()` and `end()` return the same value (past-the-end), but as a different type (`reverse_iterator` versus `iterator`).  Similarly, both `rend()` and `begin()` return the same value (an iterator to the first element), but as a different type.

Reverse pointers have to make a special compensation. Because `rbegin()` returns past-the- end, you shouldn’t try to dereference that address. Similarly, if `rend()` is really the location of the first element, `copy()` stops one location earlier because the end of the range is not in a range. Reverse pointers solve both problems by **decrementing first and then dereferencing**. That is, `*rp` dereferences the iterator value immediately preceding the current value of `*rp`. If `rp` points to position six, `*rp` is the value of position five, and so on. Listing 16.10 illustrates using `copy()`, an `ostream` iterator, and a reverse iterator.

```C++
// Listing 16.10
#include <iostream>
#include <iterator>
#include <vector>

int main()
{
	using namespace std;
	int casts[10] = {6, 7, 2, 9, 4, 11, 8, 7, 10, 5};
	vector<int> dice(10);
	// copy from array to vector
	copy(casts, casts + 10, dice.begin());
	cout << "Let the dice be cast!\n";
	// create an ostream_iterator
	ostream_iterator<int, char> out_iter(cout, " ");
	// copy from vector to output
	copy(dice.begin(), dice.end(), out_iter);
	cout << endl;
	cout << "Implicit use of reverse iterator.\n";
	copy(dice.rbegin(), dice.rend(), out_iter);
	cout << endl;
	cout << "Explicit use of reverse iterator.\n";
	vector<int>::reverse_iterator ri;
	for (ri = dice.rbegin(); ri != dice.rend(); ri++)
		cout << *ri << ' ';
	cout << endl;

	return 0;

}
```

If you have the choice of explicitly declaring iterators or using STL functions to han- dle the matter internally, for example, by passing an rbegin() return value to a function, you should take the latter course. It’s one less thing to do and one less opportunity to experience human fallibility.

The other three iterators (`back_insert_iterator`, `front_insert_iterator`, and `insert_iterator`) also increase the generality of the STL algorithms.  Insertion adds new elements without overwriting existing data, and it uses automatic memory allocation to ensure that the new information fits. A `back_insert_iterator` inserts items at the end of the container, and a `front_insert_iterator` inserts items at the front. Finally, the `insert_iterator` inserts items in front of the location specified as an argument to the `insert_iterator` constructor. All three of these iterators are models of the output container concept.

There are restrictions. A `back_insert_iterator` can be used only with container types that allow rapid insertion at the end. (_Rapid_ refers to a constant time algorithm) The `vector` class qualifies. A `front_insert_iterator` can be used only with container types that allow constant time insertion at the beginning. Here the `vector` class doesn't qualify. The `insert_iterator` doesn’t have these restrictions. Thus, you can use it to insert material at the front of a vector.

> **Tip**

> You can use an `insert_iterator` to convert an algorithm that copies data into one that inserts data.

These iterators take the container type as a template argument and the actual container identifier as a construcot argument. That is, to create a `back_insert_iterator` for a `vector<int>` container called `dice`, you use this:

```C++
back_insert_iterator<vector<int>> back_iter(dice);
```

The reason you have to declare the container type is that the iterator has to make use of the appropriate container method. The code for the `back_insert_iterator` constructor will assume that a `push_back()` method exists for the type passed to it. The `copy()` function, being a standalone function, doesn’t have the access rights to resize a container. But the declaration just shown allows `back_iter` to use the `vector<int>::push_back()` method, which does have access rights.

Declaring a `front_insert_iterator` has the same form. An `insert_iterator` declaration has an additional constructor argument to identify the insertion location:

```C++
insert_iterator<vector<int>> insert_iter(dice, dice.begin());
```

Listing 16.11 illustrate using two of these iterators. Also it uses `for_each()` instead of an `ostream` iterator for output

```C++
// Listing 16.11
#include <iostream>
#include <string>
#include <iterator>
#include <vector>
#include <algorithm>

void output(const std::string & s) { std::cout << s << " "; }

int main()
{
	using namespace std;
	string s1[4] = {"fine", "fish", "fashion", "fate"};
	string s2[2] = {"busy", "bats"};
	string s3[2] = {"silly", "singers"};
	vector<string> words(4);
	copy(s1, s1 + 4, words.begin());
	for_each(words.begin(), words.end(), output);
	cout << endl;
// construct anonymous back_insert_iterator object
	copy(s2, s2 + 2, back_insert_iterator<vector<string>>(words));
	for_each(words.begin(), words.end(), output);
	cout << endl;

// construct anonymous insert_iterator object
	copy(s3, s3 + 2, insert_iterator<vector<string>>(words, words.begin()));
	for_each(words.begin(), words.end(), output);
	cout << endl;
	return 0;
}
```

### Kinds of Containers

The STL has both container concepts and container types. The concepts are general categories with names such as container, sequence container, and associative container. The container types are templates you can use to create specific container objects. The original 11 container types are `deque`, `list`, `queue`, `priority_queue`, `stack`, `vector`, `map`, `multimap`, `set`, `multiset`, and `bitset`. C++11 adds `forward_list`, `unordered_map`, `unordered_multimap`, `unordered_set`, and `unordered_multiset`, and it moves `bitset` from the container category into its own separate category.

#### Container Concepts

No type corresponds to the basic container concept, but the concept describes elements common to all the container classes. The container concept lays down a set of requirements that all STL container class must satisfy.

A _container_ is an object that stores other objects, which are **all of a single type**. Data stored in a container is _owned_ by the container. That means when a container expires, so does the data stored in the container.

You can’t store just any kind of object in a container. In particular, the type has to be copy _constructable_ and _assignable_. 

The basic container doesn't guarantee that its elements are stored in any particular order or that order doesn't change, but refinements to the concept may add such guarantees. **All containers provide certain features and operations.** Table 16.5 on page 1008 summarizes several of these common features. In the table, `X` represents a container type (such as `vector`), `T` represents the type of object stored in the container, `a` and `b` represent values of type X, `r` is a value of type `X&`, and `u` represents an identifier of type X (that is, if `X` represents `vector<int>`, then `u` is a `vector<int>` object).

The Complexity column in Table 16.5 describes the time needed to perform an operation. This table lists three possibilities, which, from fastest to slowest, are as follows:

* Compile time 
* Constant time 
* Linear time

Complexity requirements are characteristic of the STL.Although the details of an implementation may be hidden, the performance specifications should be public so that you know the computing cost of doing a particular operation.

#### C++11 Additions to Container Requirements 

See page 1010.

#### Sequences

You can refine the basic container concept by adding requirements. The sequence is an important refinement because several of the STL container types—--`deque`, `forward_list` (C++11), `list`, `queue`, `priority_queue`, `stack`, and `vector`--—are sequences.  The requirement that the iterator **be at least a forward iterator** guarantees that the elements are arranged in a definite order that doesn’t change from one cycle of iteration to the next.

The sequence also requires that its elements be arranged in strict linear order. That is, there is a first element, there is a last element, and each element but the first and last has exactly one element immediately ahead of it and one element immediately after it. An array and a linked list are examples of sequences, whereas a branching structure (in which each node points to two daughter nodes) is not.

Because elements in sequence have a definite order, **operations such as inserting values at a particular location and erasing a particular range become possible**. Table 16.7 lists these and other operations required of a sequence. The table uses the same notation as Table 16.5, with the addition of `t` representing a value of type `T`--—that is, the type of value stored in the container, of `n`, an integer, and of `p`, `q`, `i`, and `j`, representing iterators.

Because the `deque`, `list`, `queue`, `priority_queue`, `stack`, and `vector` template classes are all models of the sequence concept, they all support the operators in Table 16.7. In addition, there are operations that are available to some of these six models. When
allowed, **they have constant-time complexity**. Table 16.8 lists these additional operations.

Let’s take a closer look at the six sequence container types.

#### `vector`

In brief, `vector` is a class representation of an array. The class provides automatic memory management that allows the size of a vector object to vary dynamically. Elements can be added to or removed from the end in constant time, but insertion and removal from the beginning and the middle are linear-time operations.

In addition to being a sequence, a vector container is also a model of the _reversible container_ concept. This adds two more class methods: `rbegin()` returns an iterator to the first element of the reversed sequence, and `rend()` returns a past-the-end iterator for the reversed sequence. So if `dice` is a `vector<int>` container and `Show(int)` is a function that displays an integer, the following code displays the contents of dice first in forward order and then in reverse order:

```C++
for_each(dice.begin(), dice.end(), Show);		// display in order
cout << endl;
for_each(dice.rbegin(), dice.rend(), Show);		// display in reverse order
cout << endl;
```

The iterator returned by the two methods is of **a class scope type `reverse_iterator`.**

The `vector` template class is the simplest of the sequence types and is considered the type that should be used by default unless the program requirements are better satisfied by the particular virtues of the other types.

#### `deque`

The `deque` template class (declared in the `deque` header file) represents a **double-ended queue**, a type often called a **deque**.  As implemented in the STL, it’s a lot like a `vector` container, **supporting random access**. The main difference is that inserting and removing items from the beginning of a `deque` object are constant-time operations instead of being linear-time operations the way they are for `vector`. So if most operations take place at the beginning and ends of a sequence, you should consider using a `deque` data structure.

#### `list`

The `list` template class (declared in the `list` header file) represents a **doubly linked list**. The crucial difference between `list` and `vector` is that list provides for **constant-time insertion and removal of elements at any location** in the list.

Like `vector`, list is a reversible container. Unlike `vector`, `list` does not support array notation and random access. Unlike a `vector` iterator, a `list` iterator remains pointing to the same element even after items are inserted into or removed from a container. 

The `list` template class has some list-oriented member functions in addition to those that come with sequences and reversible containers. Table 16.9 lists many of them. 

Listing 16.12 illustrates these methods, along with the `insert()` method, which comes with all STL classes that model sequences.

```C++
// Listing 16.12
#include <iostream>
#include <list>
#include <iterator>
#include <algorithm>

void outint(int n) {std::cout << n << " "; }

int main()
{
	using namespace std;
	list<int> one(5, 2);	// list of 5 2s
	int stuff[5] = {1, 2, 4, 8, 6};
	list<int> two;
	two.insert(two.begin(), stuff, stuff + 5);
	int more[6] = {6, 4, 2, 4, 6, 5};
	list<int> three(two);
	three.insert(three.end(), more, more + 6);

	cout << "List one: ";
	for_each(one.begin(), one.end(), outint);
	cout << endl << "List two: ";
	for_each(two.begin(), two.end(), outint);
	cout << endl << "List three: ";
	for_each(three.begin(), three.end(), outint);
	three.remove(2);
	cout << endl << "List three minus 2s: ";
	for_each(three.begin(), three.end(), outint);
	three.splice(three.begin(), one);
	cout << endl << "List three after splice: ";
	for_each(three.begin(), three.end(), outint);
	cout << endl << "List one: ";
	for_each(one.begin(), one.end(), outint);
	three.unique();
	cout << endl << "List three after unique: ";
	for_each(three.begin(), three.end(), outint);
	three.sort();
	three.unique();
	cout << endl << "List three after sort & unique: ";
	for_each(three.begin(), three.end(), outint);
	two.sort();
	three.merge(two);
	cout << endl << "Sorted two merged into three: ";
	for_each(three.begin(), three.end(), outint);
	cout << endl;

	return 0;
}
```

The program in Listing 16.12 uses the `for_each()` algorithm and an `outint()` function to display the lists. With C++11, you could use the range-based `for` loop instead:

```C++
for (auto x : three) cout << " ";
```

The main difference between `insert()` and `splice()` is that `insert()` inserts a copy of the original range into the destination, whereas `splice()` moves the original range into the destination. Thus, after the contents of `one` are spliced to `three`, `one` is left empty. The `splice()` method leaves iterators valid. That is, if you set a particular iterator to point to an element in `one`, that iterator still points to the same element after `splice()` relocates it in `three`.

Notice that `unique()` only reduces adjacent equal values to a single value. After the program executes `three.unique()`, `three` still contains two fours and two sixes that weren’t adjacent. But applying `sort()` and then `unique()` does limit each value to a single appearance.

There is a nonmember `sort()` function (Listing 16.9), but it requires random access iterators. Because the trade-off for rapid insertion is to give up random access, you can’t use the nonmember `sort()` function with a list. Therefore, the class includes a member version that works within the restrictions of the class.

#### The `list` Toolbox

The `list` methods form a handy toolbox. Suppose, for example, that you have two mailing lists to organize. You could sort each list, merge them, and then use `unique()` to remove multiple entries.

The `sort()`, `merge()`, and `unique()` methods also each have a version that accepts an additional argument to specify an alternative function to be used for comparing elements. Similarly, the `remove()` method has a version with an additional argument that specifies a function used to determine whether an element is removed. These arguments are examples of predicate functions, a topic to which we’ll return later.

#### `forward_list` (C++11)

C++11 adds `forward_list` as a container class. This class implements a singly linked list. In this kind of list, each item is linked just to the next item, but not to the preceding item. Therefore, the class requires just a forward iterator, not a bidirectional one. Thus, unlike `vector` and `list`, `forward_list` isn’t a reversible container. Compared to list, `forward_list` is simpler, more compact, but with fewer features.

#### `queue`

The `queue` template class (declared in the `queue`—--formerly `queue`.h—header file) is an adapter class. Recall that the ostream_iterator template is an adapter that allows an output stream to use the iterator interface. Similarly, the `queue` template allows an underlying class (deque, by default) to exhibit the typical queue interface.

The `queue` template is more restrictive than deque. Not only does it not permit random access to elements of a `queue`, the `queue` class doesn’t even allow you to iterate through a `queue`. Instead, it limits you to the basic operations that define a queue. Table 16.10 lists these operations.

Note that `pop()` is a data removal method, not a data retrieval method. If you want to use a value from a queue, you first use `front()` to retrieve the value and then use `pop()` to remove it from the queue.

#### `priority_queue`

The `priority_queue` template class (declared in the `queue` header file) is another adapter class. It supports the same operations as `queue`.The main difference between the two is that with `priority_queue`, the largest item gets moved to the front of the `queue`. An internal difference is that the default underlying class is `vector`. You can alter the comparison used to determine what gets to the head of the `queue` by providing an optional constructor argument:

```C++
priority_queue<int> pq1;				// default version
priority_queue<int> pq2(greater<int>);	// use greater<int> to order
```

The `greater<>()` function is a predefined function object, and it is discussed later in this chatper.

#### `stack`

Like `queue`, `stack` (declared in the `stack` header file) is an adapter class. It gives an underlying class (`vector`, by default) the typical stack interface.

Table 16.11 on page 1018 lists these operations.

Much as with `queue`, if you want to use a value from a `stack`, you first use `top()` to retrieve the value, and then you use `pop()` to remove it from the stack.

#### `array` (C++11)

The `array` template class, introduced in Chapter 4 and defined in the `array` header file, is not an STL container because it has a fixed size. Thus, operations that would resize a container, such as `push_back()` and `insert()`, are not defined for `array`. But those member functions that do make sense, such as `operator[]()` and `at()`, are provided. And you can use many standard STL algorithms, such as `copy()` and `for_each()`, with `array` objects.

### Assciative Containers

An _associative container_ is another refinement of the container concept. An associative container associates a value with a key and uses the key to find the value. 

Recall that for a container `X`, in general, the expression `X::value_type` indicates the type of value stored in the container. For an associative container, the expression `X::key_type` indicates the type used for the key.

The STL provides four associative containers: `set`, `multiset`, `map`, and `multimap`. The first two types are defined in the `set` header file, and the second two types are defined in the `map` header file.

The simplest of the bunch is `set`; the value type is the same as the key type, and the keys are unique, meaning there is no more than one instance of a key in a `set`. Indeed, for `set`, the value is the key. The `multiset` type is like the `set` type except that it can have more than one value with the same key. For example, if the key and value type are int, a `multiset` object could hold, say `1`, `2`, `2`, `2`, `3`, `5`, `7`, and `7`.

For the `map` type, the value type is different from the key type, and the keys are unique, with only one value per key. The `multimap` type is similar to `map`, except one key can be associated with multiple values.

#### A `set` Example

The STL `set` models several concepts. It is an associative set, it is reversible, it is sorted, and the keys are unique, so it can hold no more than one of any given value. Like `vector` and `list`, `set` uses a template parameter to provide the type stored:

```C++
set<string> A;	// a set of string objects
```

A optional second template argument can be used to indicate a comparison funcition or object to be used to order the key. By default, the `less<>` template (discussed later) is used.

Consider the following code:

```C++
const int N = 6;
string s1[N] = {"buffoon", "thinkers", "for" "heavy", "can", "for"};
set<string> A(s1, s1 + N);	// initializa set A using a range from array
ostream_iterator<string, char> out(cout, " ");
copy(A.begin(), A.end(), out);
```

Like other containers, `set` has a constructor (refer to Table 16.6) that takes a range of iterators as arguments. The output for this code fragment illustrates that keys are unique (the string "`for`" appears twice in the array but once in the `set`) and that the `set` is sorted:

```
buffoon can for heavy thinkers
```

The STL provides algorithms that support these operations. They are general functions rather than methods, so they aren’t restricted to `set` objects. However, all `set` objects automatically satisfy the precondition for using these algorithms--—namely, that the container be sorted. The `set_union()` function takes five iterators as arguments. The first two define a range in one `set`, the second two define a range in a second `set`, and the final iterator is an output iterator that identifies a location to which to copy the resultant `set`. For example, to display the union of sets A and B, you can use this:

```C++
set_union(A.begin(), A.end(), B.begin(), B.end(),
	ostream_iterator<string, char> out(cout, " "));
```

Suppose you want to place the result into a `set` `C` instead of displaying it. In this case, you would want the last argument to be an iterator into `C`. The obvious choice is `C.begin()`, but that doesn’t work for two reasons. The first reason is that associative sets treat keys as constant values, so the iterator returned by `C.begin()` is a constant iterator and can’t be used as an output iterator. The second reason not to use `C.begin()` directly is that `set_union()`, like `copy()`, overwrites existing data in a container and requires the container to have sufficient space to hold the new information. `C`, being empty, does not satisfy that requirement. But the `insert_iterator` template discussed earlier solves both problems. Earlier you saw that it converts copying to insertion. Also it models the output iterator concept, so you can use it to write to a container. So you can construct an anonymous `insert_iterator` to copy information to `C`.The constructor, recall, takes the name of the container and an iterator as arguments:

```C++
set_union(A.begin(), A.end(), B.begin(), B.end(),
	insert_iterator<set<string>>(C, C.begin()));
```

The `set_intersection()` and `set_difference()` functions find the set intersection and set difference of two sets, and they have the same interface as `set_union()`.

Two useful set methods are `lower_bound()` and `upper_bound()`. The `lower_bound()` method takes a key-type value as its argument and returns an iterator that points to the first member of the set that is not less than the key argument. Similarly, the `upper_bound()` method takes a key as its argument and returns an iterator that points to the first member of the set that is greater than the key argument. For example, if you had a set of strings, you could use these methods to identify a range encompassing all strings from `"b"` up to `"f"` in the set.

Because sorting determines where additions to a set go, the class has insertion methods that just specify the material to be inserted, without specifying a position. If A and B are `set`s of `string`s, for example, you can use this:

```C++
string s("tennis");
A.insert(s);		// insert a value
B.insert(A.begin(), A.end());			// insert a range
```

Listing 16.13 illustrates these uses of sets.

```C++
#include <iostream>
#include <string>
#include <set>
#include <algorithm>
#include <iterator>

int main()
{
	using namespace std;
	const int N = 6;
	string s1[N] = {"buffoon", "thinkers", "for", "heavy", "can", "for"};
	string s2[N] = {"metal", "any", "food", "elegant", "deliver", "for"};

	set<string> A(s1, s1 + N);
	set<string> B(s2, s2 + N);

	ostream_iterator<string, char> out(cout, " ");
	cout << "Set A: ";
	copy(A.begin(), A.end(), out);
	cout << endl;
	cout << "Set B: ";
	copy(B.begin(), B.end(), out);
	cout << endl;
	cout << "Union of A and B:\n";
	set_union(A.begin(), A.end(), B.begin(), B.end(), out);
	cout << endl;

	cout << "Intersection of A and B:\n";
	set_intersection(A.begin(), A.end(), B.begin(), B.end(), out);
	cout << endl;

	cout << "Difference of A and B:\n";
	set_difference(A.begin(), A.end(), B.begin(), B.end(), out);
	cout << endl;

	set<string> C;
	cout << "Set C:\n";
	set_union(A.begin(), A.end(), B.begin(), B.end(),
			insert_iterator<set<string>>(C, C.begin()));
	copy(C.begin(), C.end(), out);
	cout << endl;

	string s3("grungy");
	C.insert(s3);
	cout << "Set C after insertion:\n";
	copy(C.begin(), C.end(), out);
	cout << endl;

	cout << "Showing a range:\n";
	copy(C.lower_bound("ghost"), C.upper_bound("spook"), out);
	cout << endl;

	return 0;
}
```

#### A `multimap` Example

Like `set`, `multimap` is a reversible, sorted, associative container. However, with `multimap`, the key type is different from the value type, and a `multimap` object can have more than one value associated with a particular key.

The basic `multimap` declaration specifies the key type and the type of value, stored as template arguments. For example, the following declaration creates a `multimap` object that uses `int` as the key type and string as the type of value stored:

```C++
multimap<int, string> codes;
```

An optional third template argument can be used to indicate a comparison function or an object to be used to order the key. By default, the `less<>` template (discussed later) is used with the key type as its parameter.

To keep information together, the actual value type combines the key type and the data type into a single pair. To do this, the STL uses a `pair<class T, class U>` template class for storing two kinds of values in a single object. If `keytype` is the key type and `datatype` is the type of the stored data, the value type is `pair<const keytype, datatype>`. For example, the value type for the `codes` object declared earlier is `pair<const int, string>`.

Suppose that you want to store city names, using the area code as a key. This happens to fit the `codes` declaration, which uses an `int` for a key and a `string` as a data type. One approach is to create a pair and then insert it into the `multimap` object:

```C++
pair<const int, string> item(213, "Log Angeles");
codes.insert(item);
```

Or you can create an anonymous `pair` object and insert it in a single statement:

```C++
codes.insert(pair<const int, string> (213, "Log Angeles"));
```

Given a `pair` object, you can access the two components by using the `first` and
`second` members:

```C++
pair<const int, string> item(213, "Log Angeles");
cout << item.first << ' ' << item.second << endl;
```

What about getting information about a `multimap` object? The `count()` member function takes a key as its argument and returns the number of items that have that key. The `lower_bound()` and `upper_bound()` member functions take a key and work as they do for `set`. Also the `equal_range()` member function takes a key as its argument and returns iterators representing the range matching that key. In order to return two values, the method packages them into a `pair` object, this time with **both template arguments being the iterator type**. For example, the following would print a list of cities in the `codes` object with area code 718:

```C++
pair<multimap<KeyType, string>::iterator,
	 multimap<KeyType, string>::iterator> range
	 = codes.equal_range(718);
cout << "Cities with area code 718:\n";
std::multimap<KeyType, std::string::iterator> it;
for (it = range.first; it != range.second; it++)
	cout << (*it).second << endl;
```

Listing 16.14 demonstrates most of these techniques. 

```C++
// Listing 16.14
#include <iostream>
#include <string>
#include <map>
#include <algorithm>

typedef int KeyType;
typedef std::pair<const KeyType, std::string> Pair;
typedef std::multimap<KeyType, std::string> MapCode;

int main()
{
	using namespace std;
	MapCode codes;

	codes.insert(Pair(415, "San Francisco"));
	codes.insert(Pair(510, "Oakland"));
	codes.insert(Pair(718, "Brooklyn"));
	codes.insert(Pair(718, "Staten Island"));
	codes.insert(Pair(415, "San Rafael"));
	codes.insert(Pair(510, "Berkeley"));

	cout << "Number of cities with area code 415: "
		 << codes.count(415) << endl;
	cout << "Number of cities with area code 718: "
		 << codes.count(718) << endl;
	cout << "Number of cities with area code 510: "
		 << codes.count(510) << endl;
	cout << "Area Code\tCity\n";
	MapCode::iterator it;
	for (it = codes.begin(); it != codes.end(); it++)
		cout << "\t" << (*it).first << "\t"
			 << (*it).second << endl;
	pair<MapCode::iterator, MapCode::iterator> range
		= codes.equal_range(718);
	cout << "Cities with area code 718:\n";
	for (it = range.first; it != range.second; it++)
		cout << (*it).second << endl;
}
```

### Unordered Associative Containers (C++11)


An _unordered associative container_ is yet another refinement of the container concept. Like an associative container, an unordered associative container associates a value with a key and uses the key to find the value. The underlying difference is that associative containers are based on tree structures, whereas unordered associative containers are based on another form of data structure called a _hash table_. The intent is to provide containers for which adding and deleting elements is relatively quick and for which there are efficient search algorithms. The four unordered associative containers are called `unordered_set_`, `unordered_multiset`, `unordered_map`, and `unordered_multimap`. Appendix G looks a bit further at these additions.

## Function Objecs (a.k.a Functors)

Many STL algorithms use _function objects_, also known as _functors_. A _functor_ is any object that can be used with `()` in the manner of a function. This includes normal function names, pointers to functions, and class objects for which the `()` operator is overloaded—--that is, classes for which the peculiar-looking function `operator()()` is defined. For example, you could define a class like this:

```C++
class Linear
{
private:
	double slope;
	double y0;
public:
	Linear(double sl_ = 1, double y_ = 0)
		: slope(sl_), y0(y_) {}
	double operator()(double x) {return y0 + slope * x; }
};
```

The overloaded `()` operator then allows you to use `Linear` objects like functions:

```C++
Linear f1;
Linear f2(2.5, 10.0);
double y1 = f1(12.5);	// right-hand side is f1.operator()(12.5)
double y2 = f2(0.4);
```

Remember the `for_each` function? It applied a specified function to each member of a range:

```C++
for_each(books.begin(), books.end(), ShowReview);
```

In general, the third argument could be a functor, not just a regular function. The `for_each` prototype looks like this:

```C++
template <class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function f);
```

The `ShowReview()` prototype is this:

```C++
void ShowReview(const Review &);
```

This makes the identifier `ShowReview` have the type `void (*)(const Review &)`, so that is the type assigned to the template argument `Function`. With a different function call, the `Function` argument could represent a class type that has an overloaded `()` operator. Ultimately, the `for_each()` code will have an expression using `f()`. 

### Functor Concepts

Just as the STL defines concepts for containers and iterators, it defines functor concepts'

* A _generator_ is a functor that can be called with no arguments.
* A _unary function_ is a functor that can be called with one argument.
* A _binary function_ is a functor that can be called with tao arguments.

For example, the functor supplied to `for_each()` should be a unary function because it is applied to one container element at a time.

Of course, these concepts come with refinements:

* A unary function that returns a `bool` value is a _predicate_.
* A binary function that returns a `bool` value is a _binary predicate_.

Several STL functions require predicate or binary predicate arguments. For example, Listing 16.9 uses a version of `sort()` that takes a binary predicate as its third argument:

```C++
bool WorseThan(const Review & r1, const Review & r2);
...
sort(books.begin(), books.end(), WorseThan);
```

The `list` template has a `remove_if()` member that takes a predicate as an argument. It applies the predicate to each member in the indicated range, removing those elements for which the predicate returns `true`. For example, the following code would remove all elements greater than 100 from the list `three`:

```C++
bool tooBig(int n) { return n > 100; }
list<int> scores;
...
scores.remove_if(tooBig);
```

Incidentally, this last example shows where a class functor might be useful. Suppose you want to remove every value greater than 200 from a second list. It would be nice if you could pass the cut-off value to `tooBig()` as a second argument so you could use the function with different values, but **a predicate can have but one argument**. If, however, you design a `TooBig` class, you can use class members instead of function arguments to convey additional information:

```C++
template <class T>
class TooBig
{
private:
	T cutoff;
public:
	TooBig(const T & t) : cutoff(t) {}
	bool operator()(const T & v) { return v > cutoff; }	
};
```

Here one value (`v`) is passed as a function argument, and the second argument (`cutoff`) is set by the class constructor. Given this definition, you can initialize different `TooBig` objects to different cut-off values to be used in calls to `remove_if()`. Listing 16.15 illustrates the technique.

```C++
// Listing 16.15
#include <iostream>
#include <list>
#include <algorithm>

template <class T>		// functor class defines operator()()
class TooBig
{
private:
	T cutoff;
public:
	TooBig(const T & t) : cutoff(t) {}
	bool operator()(const T & v) { return v > cutoff; }
};

void outint(int n) { std::cout << n << " "; }

int main()
{
	using std::list;
	using std::cout;
	using std::endl;

	TooBig<int> f100(100);	// limit = 100
	int vals[10] = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
	list<int> yadayada(vals, vals + 10);	// range constructor
	list<int> etcetera(vals, vals + 10);
// C++11 can use the following instead
//	list<int> yadayada = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
//	lsit<int> etcetera {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
	cout << "Original lists:\n";
	for_each(yadayada.begin(), yadayada.end(), outint);
	cout << endl;
	for_each(etcetera.begin(), etcetera.end(), outint);
	cout << endl;
	yadayada.remove_if(f100);					// use a named function object
	etcetera.remove_if(TooBig<int>(200));		// construct a function object
	cout << "Trimmed lists:\n";
	for_each(yadayada.begin(), yadayada.end(), outint);
	cout << endl;
	for_each(etcetera.begin(), etcetera.end(), outint);
	cout << endl;
	return 0;	
}
```

Suppose you already have a template function with two arguments:

```C++
template <class T>
bool tooBig(const T & val, const T & lim)
{
	return val > lim;
}
```

You can use a class to convert it to a one-argument function object:

```C++
template <class T>
class TooBig2
{
private:
	T cutoff;
public:
	TooBig2(const T & t) : cutoff(t) {}
	bool operator() (const T & v) { return tooBig<T>(v, cutoff); }
};
```

That is, you can use the following:

```C++
TooBig2<int> tB100(100);
int x;
cin >> x;
if (tB100(x))	// same as if (tooBig(x, 100))
	...
```

So the call `tB100(x)` is the same as `tooBig(x,100)`, but the two-argument function is converted to a one-argument function object, with the second argument being used to construct the function object. In short, the class functor `TooBig2` is a function adapter that adapts a function to meet a different interface.

As noted in the listing C++11's initializer-list feature simplifies initialization. You can replace

```C++
int vals[10] = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
list<int> yadayada(vals, vals + 10);	// range constructor
list<int> etcetera(vals, vals + 10);
```

with this:

```C++
list<int> yadayada = {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
list<int> etcetera {50, 100, 90, 180, 60, 210, 415, 88, 188, 201};
```

### Predefined Functors

The STL defines several elementary functors to help support STL functions that take functions as arguments. For example, consider the `transform()` function. It has two versions. The first version takes four arguments. The first two arguments are iterators that specify a range in a container. The third is an iterator that specifies where to copy the result. The final is a functor that is applied to each element in the range to produce each new element in the result. For example, consider the following:

```C++
const int LIM = 5;
double arr1[LIM] = {36, 39, 42, 45, 48};
vector<double> gr8(arr1, arr1 + LIM);
ostream_iterator<double, char> out(cout, " ");
transform(gr8.begin(), gr8.end(), out, sqrt);
```

This code calculates the square root of each element and sends the resulting values to the output stream. The destination iterator can be in the original range. For example, replacing `out` in this example with `gr8.begin()` would copy the new values over the old values. Clearly, the functor used must be one that works with a single argument.

The second version uses a function that takes two arguments, applying the function to one element from each of two ranges. It takes an additional argument, which comes third in order, identifying the start of the second range. For example, if `m8` were a second `vector<double>` object and if `mean(double, double)` returned the mean of two values, the following would output the average of each pair of values from `gr8` and `m8`:

```C++
transform(gr8.begin(), gr8.end(), m8.begin(), out, mean);
```

Now suppose you want to add the two arrays. You could define a function to add two numbers and use it:

```C++
double add(doube x, double y) { return x + y; }
...
transform(gr8.begin(), gr8.end(), m8.begin(), out, add);
```

It would be better to define a template, except that you don’t have to because the STL already has. The `functional` header defines several template class function objects, including one called `plus<>()`.

Using the `plus<>` class for ordinary addition is possible, if awkward:

```C++
#include <functional>
...
plus<double> add;	// create a plus<double> object
double y = add(2.2, 3.4);	// using plus<double>::operator()()
```

But it makes it easy to provide a function object as an argument:

```C++
transform(gr8.begin(), gr8.end(), m8.begin(), out, plus<double>());
```

The STL provides functor equivalents for all the built-in arithmetic, relational, and logical operators. Table 16.12 on page 1031 shows the names for these functor equivalents. They can be used with the C++ built-in types or with any user-defined type that overloads the corresponding operator.

### Adaptable Functors and Function Adapters

The predefined functors in Table 16.12 are all `adaptable`. Actually,the STL has five related concepts: adaptable generators, adaptable unary functions, adaptable binary functions, adaptable predicates, and adaptable binary predicates.

What makes a functor adaptable is that it carries `typedef` members identifying its argument types and return type. The members are called `result_type`, `first_argument_type`, and `second_argument_type`, and they represent what they sound like. For example, the return type of a `plus<int>` object is identified as `plus<int>::result_type`, and this would be a `typedef` for `int`.

The significance of a functor being adaptable is that it can then be used by **function adapter** objects, which assume the existence of these `typedef` members. For example, a function with an argument that is an adaptable functor can use the `result_type` member to declare a variable that matches the function’s return type.

Indeed, the STL provides function adapter classes that use these facilities. For example, suppose you want to multiply each element of the vector `gr8` by 2.5. That calls for using the `transform()` version with a unary function argument, like the example shown earlier:

```C++
transform(gr8.begin(), gr8.end(), out, sqrt);
```

The `multiplies()` functor can do the multiplication, but it’s a binary function. So you need a **function adapter** that converts a functor that has two arguments to one that has one argument. The earlier `TooBig2` example shows one way, but the STL has automated the process with the `binder1st` and `binder2nd` classes, which **convert adaptable binary functions to adaptable unary functions**.

Let’s look at `binder1st`. Suppose you have an adaptable binary function object `f2()`. You can create a `binder1st` object that binds a particular value, called `val`, to be used as the first argument to `f2()`:

```C++
binder1st(f2, val) f1;
```

Now, `f1(x)` is equivalent to `f2(val, x)`. The `f2()` function has been adapted. Again, this is possible only if `f2()` is an adaptable function.

However, the STL provides the `bind1st()` function to simplify using the `binder1st` class. You give it the function name and value used to construct a `binder1st` object, and it returns an object of that type. For example, you can convert the binary function `multiplies()` to a unary function that multiplies its argument by 2.5. Just do this:

```C++
bind1st(multiplies<double>(), 2.5);
```

Thus, the solution to multiplying every element in `gr8` by 2.5 and displaying the results is this:

```C++
transform(gr8.begin(), gr8.end(), out,
	bind1st(multiplies<double>(), 2.5));
```

The `binder2nd` class is similar, except that it assigns the constant to the second argument instead of to the first. It has a helper function called `bind2nd` that works analogously to `bind1st`.

Listing 16.16 incorporates some of the recent examples into a short program.

```C++
// Listing 16.16
#include <iostream>
#include <vector>
#include <iterator>
#include <algorithm>
#include <functional>

void Show(double);
const int LIM = 6;
int main()
{
	using namespace std;
	double arr1[LIM] = {28, 29, 30, 35, 38, 59};
	double arr2[LIM] = {63, 65, 69, 75, 80, 99};
	vector<double> gr8(arr1, arr1 + LIM);
	vector<double> m8(arr2, arr2 + LIM);
	cout.setf(ios_base::fixed);
	cout.precision(1);
	cout << "gr8:\t";
	for_each(gr8.begin(), gr8.end(), Show);
	cout << endl;
	cout << "m8: \t";
	for_each(m8.begin(), m8.end(), Show);
	cout << endl;

	vector<double> sum(LIM);
	transform(gr8.begin(), gr8.end(), m8.begin(), sum.begin(),
			  plus<double>());
	cout << "sum:\t";
	for_each(sum.begin(), sum.end(), Show);
	cout << endl;

	vector<double> prod(LIM);
	transform(gr8.begin(), gr8.end(), prod.begin(),
			bind1st(multiplies<double>(), 2.5));
	cout << "prod:\t";
	for_each(prod.begin(), prod.end(), Show);
	cout << endl;

	return 0;
}

void Show(double v)
{
	std::cout.width(6);
	std::cout << v << ' ';
}
```

## Algorithms

There are two main generic components to the algorithm function designs. First, they use templates to provide generic types. Second, they use iterators to provide a generic representation for accessing data in a container.

### Algorithm Groups

The STL provides the algorithm library into four groups:

* Nonmodifying sequence operations
* Mutating sequence operations
* Sorting and related operations
* Generalized numeric operations

The first three groups are described in the `algorithm` header file, and the fourth group, being specifically oriented toward numeric data, gets its own header file, called `numeric`. 

Nonmodifying sequence operations operate on each element in a range. These operations leave a container unchanged. For example, `find()` and `for_each()` belong to this category.

Mutating sequence operations also operate on each element in a range. As the name suggests, however, they can mutate, or change, the contents of a container. The change could be in values or in the order in which the values are stored. The `transform()`, `random_shuffle()`, and `copy()` functions fall into this category.

Sorting and related operations include several sorting functions (including `sort()`) and a variety of other functions, including the set operations.

The numeric operations include functions to sum the contents of a range, calculate the inner product of two containers, calculate partial sums, and calculate adjacent differences. Typically, these are operations that are characteristic of arrays, so `vector` is the container most likely to be used with them.

### General Properties of Algorithms

STL functions work with iterators and iterator ranges. The function prototype indicates the assumptions made about the iterators. For example, the `copy()` function has this prototype

```C++
template <class InputIterator, class OutputIterator>
OutputIterator copy(InputIterator first, InputIterator last,
	OutputIterator result);
```

The STL documentation uses the template parameter names to indicate the concept that the parameter models. So this declaration tells you that the range parameters must be input iterators or better and that the iterator indicating where the result goes must be an output parameter or better.

One way of classifying algorithms is on the basis of where the result of the algorithm is placed. Some algorithms do their work in place, and others create copies. For example, when the `sort()` function is finished, the result occupies the same location that the original data did. So `sort()` is an _in-place algorithm_. The `copy()` function, however, sends the result of its work to another location, so it is a _copying algorithm_. The `transform()` function can do both. Like `copy()`, it uses an output iterator to indicate where the results go. Unlike `copy()`, `transform()` allows the output iterator to point to a location in the input range, so it can copy the transformed values over the original values.

Some algorithms come in two versions: an in-place version and a copying version. The STL convention is to append `_copy` to the name of the copying version. The latter version takes an additional output iterator parameter to specify the location to which to copy the outcome. For example, there is a `replace()` function that has this prototype:

```C++
template <class ForwardIterator, class T>
void replace(ForwardIterator first, ForwardIterator last,
			 const T & old_value, const T & new_value);
```

It replaces each instance of `old_value` with `new_value`. This occurs in place. **Because this algorithm both reads from and writes to container elements, the iterator type has to be `ForwardIterator`** or better. The copying version has this prototype:

```C++
template <class InputIterator, class OutputIterator, class T>
OutputIterator replace_copy(InputIterator first, InputIterator last, OutputIterator result,
	const T& old_value, const T& new_value);
```

This time the resulting data is copied to a new location, given by result, so the read-only input iterator is sufficient for specifying the range.

Note that `replace_copy()` has an `OutputIterator` return type. The convention for copying algorithms is that they return an iterator pointing to the location one past the last value copied.

Another common variation is that some functions have a version that performs an action conditionally, depending on the result of applying a function to a container element. These versions typically append `_if` to the function name. For example, `replace_if()` replaces an old value with a new value if applying a function to the old value returns the value true. Here’s the prototype:

```C++
template <class ForwardIterator, class Predicate class T>
void replace_if(ForwardIterator first, FowardIterator last,
				Predicate pred, const T& new_value);
```

There’s also a version called `replace_copy_if()`. You can probably figure out what it does and what its prototype is like.

As with `InputIterator`, `Predicate` is a template parameter name and could just as easily be called `T` or `U`. However, the STL chooses to use `Predicate` to remind the user that the actual argument should be a model of the `Predicate` concept. Keep in mind that although the documentation can remind you what the iterator or functor requirements are, these names are not something the compiler can check. If you use the wrong sort of iterator, you can expect to see a long list of error messages as the compiler tries to instantiate the template.

### The STL and the `string` Class

The `string` class, although not part of the STL, is designed with the STL in mind. For example, it has `begin()`, `end()`, `rbegin()`, and `rend()` members. Thus, it can use the STL interface. Listing 16.17 uses the STL to show all the permutations you can form from the letters in a word. The `next_permutation()` algorithm transforms the contents of a range to the next permutation; in the case of a `string`, the permutations are arranged in ascending alphabetical order. The algorithm returns `true` if it succeeds and `false` if the range already is in the final sequence. To get all the permutations of a range, you should start with the elements in the earliest possible order, and the program uses the STL `sort()` algorithm for that purpose.

```C++
#include <iostream>
#include <string>
#include <algorithm>

int main()
{
	using namespace std;
	string letters;
	cout << "Enter the letter grouping (quit to quit): ";
	while (cin >> letters && letters != "quit")
	{
		cout << "Permutations of " << letters << endl;
		sort(letters.begin(), letters.end());
		cout << letters << endl;
		while (next_permutation(letters.begin(), letters.end()))
				cout << letters << endl;
			cout << "Enter next sequence (quit to quit): ";
	}
	cout << "Done!\n";
	return 0;
}
```

### Functions Versus Container Methods

Sometimes you have a choice between using an STL method and an STL function. Usually, the method is the better choice. First, it should be better optimized for a particular container. Second, being a member function, **it can use a template class’s memory management facilities** and resize a container when needed.

Suppose, for example, that you have a list of numbers and you want to remove all instances of a certain value, say `4`, from the list. If `la` is a `list<int>` object, you can use the list `remove()` method:

```C++
la.remove(4);	// remove all 4s from the list
```

After this method call, all elements with the value `4` are removed from the list, and **the list is automatically resized**.

There is also an STL algorithm called `remove()` (see Appendix G). Instead of being invoked by an object, it takes range arguments. So if `lb` is a `list<int>` object, a call to the function could look like this:

```C++
remove(lb.begin(), lb.end(), 4);
```

However, because this `remove()` is not a member, it can’t adjust the size of the list. Instead, it makes sure all the nonremoved items are at the beginning of the list, and it returns an iterator to the new past-the-end value. You can then use this iterator to fix the list size. For example, you can use the list `erase()` method to remove a range that describes the part of the list that is no longer needed. Listing 16.18 shows how this process works.

```C++
// Listing 16.18
#include <iostream>
#include <list>
#include <algorithm>

void Show(int);
const int LIM = 10;
int main()
{
	using namespace std;
	int ar[LIM] = {4, 5, 4, 2, 2, 3, 4, 8, 1,4};
	list<int> la(ar, ar + LIM);
	list<int> lb(la);
	cout << "Original list contents:\n\t";
	for_each(la.begin(), la.end(), Show);
	cout << endl;
	la.remove(4);
	cout << "After using the remove() method:\n";
	cout << "la:\t";
	for_each(la.begin(), la.end(), Show);
	cout << endl;
	list<int>::iterator last;
	last = remove(lb.begin(), lb.end(), 4);
	cout << "After using the remove() function:\n";
	cout << "lb:\t";
	for_each(lb.begin(), lb.end(), Show);
	cout << endl;
	lb.erase(last, lb.end());
	cout << "After using the erase() method:\n";
	cout << "lb:\t";
    for_each(lb.begin(), lb.end(), Show);
	cout << endl;
	return 0;
}

void Show(int v)
{
	std::cout << v << ' ';
}
```

As you can see, the `remove()` method reduces the list `la` from 10 elements to 6 elements. However, list `lb` still contains 10 elements after the `remove()` function is applied to it. The last 4 elements are disposable because each is either the value 4 or a duplicate of a value moved farther to the front of the list.

### Using the STL

Suppose you want to write a program that lets the user enter words. At the end, you’d like a record of the words as they were entered, an alphabetical list of the words used (capitalization differences ignored), and a record of how many times each word was entered.

Entering and saving the list of words is simple enough. Following the example of Listings 16.8 and 16.9, you can create a `vector<string>` object and use `push_back()` to add input words to the vector:

```C++
vector<string> words;
string input;
while (cin >> input && input != "quit")
	words.push_back(input);
```

What about getting the alphabetic word list? You can use `sort()` followed by `unique()`, but that approach overwrites the original data because `sort()` is an in-place algorithm. There is an easier way that avoids this problem.You can create a `set<string>` object and copy (**using an insert iterator**) the words from the vector to the set. A set automatically sorts its contents, which means you don’t have to call `sort()`, and a set allows only one copy of a key, so that takes the place of calling `unique()`. Wait! The specification called for ignoring the case differences. One way to handle that is to use `transform()` instead of `copy()` to copy data from the vector to the set. For the transformation function, you can use one that converts a string to lowercase:

```C++
set<string> wordset;
transform(words.begin(), words.end(),
	insert_iterator<set<string>>(wordset, wordset.begin()), ToLower);
```

The `ToLower()` function is easy to write. You just use `transform()` to apply the `tolower()` function to each element in the string, using the string both as source and destination. Remember, `string` objects, too, can use the STL functions. Passing and returning the string as a reference means the algorithm works on the original string without having to make copies. Here’s the code for `ToLower()`:

```C++
string & ToLower(string & st)
{
	transform(st.begin(), st.end(), st.begin(), tolower);
	return st;
}
```

To get the number of times each word appears in the input, you can use the `count()` function. It takes a range and a value as arguments, and it returns the number of times the value appears in the range. You can use the `vector` object to provide the range and the `set` object to provide the list of words to count. That is, **for each word in the set, you can count how many times it appears in the vector**. To keep the resulting count associated with the correct word, you can store the word and the count as a `pair<const string, int>` object in a `map` object. The word will be the key (just one copy), and the count will be the value. This can be done in a single loop:

```C++
map<string, int> wordmap;
set<string>::iterator si;
for (si = wordset.begin(); si != wordset.end(); si++)
	wordmap.insert(pair<string, int>(*si, count(words.begin(), words.end(), *si)));
```

The `map` class has an interesting feature: You can use array notation with keys that serve as indexes to access the stored values. For example, `wordmap["the"]` would represent the value associated with the key `"the"`, which in this case is the number of occurrences of the string `"the"`. Because the wordset container holds all the keys used by `wordmap`, you can use the following code as an alternative and more attractive way of storing results:

```C++
for (si = wordset.begin(); si != wordset.end(); si++)
	wordmap[*si] = count(words.begin(), words.end(), *si);
```

Because `si` points to a string in the `wordset` container, `*si` is a string and can serve as a key for `wordmap`. **This code places both keys and values into the wordmap map.**

Similarly, you can use the array notation to report results:

```C++
for (si = wordset.begin(); si != wordset.end(); si++)
	cout << *si << ": " << wordmap[*si] << endl;
```

If a key is invalid, the corresponding value is `0`.

Listing 16.19 puts these ideas together and includes code to display the contents of the three containers (a vector with the input, a set with a word list, and a map with a word count).

```C++
// Listing 16.19
#include <iostream>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <iterator>
#include <algorithm>
#include <cctype>
using namespace std;

char toLower(char ch) { return tolower(ch); }
string & ToLower(string & st);
void display(const string & s);

int main()
{
	vector<string> words;
	cout << "Enter words (enter quit to quit):\n";
	string input;
	while (cin >> input && input != "quit")
		words.push_back(input);

	cout << "You entered the following words:\n";
	for_each(words.begin(), words.end(), display);
	cout << endl;

	// place words in set, converting to lowercase
	set<string> wordset;
	transform(words.begin(), words.end(),
		insert_iterator<set<string>>(wordset, wordset.begin()),
		ToLower);
	cout << "\nAlphabetic list of words:\n";
	for_each(wordset.begin(), wordset.end(), display);
	cout << endl;

	// place word and frequency in map
	map<string, int> wordmap;
	set<string>::iterator si;
	for (si = wordset.begin(); si != wordset.end(); si++)
		wordmap[*si] = count(words.begin(), words.end(), *si);

	// display map contents
	cout << "\nWord frequency:\n";
	for (si = wordset.begin(); si != wordset.end(); si++)
		cout << *si << ": " << wordmap[*si] << endl;

	return 0;
}

string & ToLower(string & st)
{
	transform(st.begin(), st.end(), st.begin(), toLower);
	return st;
}

void display(const string & s)
{
	cout << s << " ";
}
```

## Other Algorithms

### `vector`, `valarray`, and `array`

These classes were developed by different groups for different purposes. The `vector` template class is part of a system of container classes and algorithms. The `vector` class supports container-oriented activities, such as sorting, insertion, rearrangement, searching, transferring data to other containers, and other manipulations. The `valarray` class template, on the other hand, is oriented toward **numeric computation**, and it is not part of the STL. It doesn’t have `push_back()` and `insert()` methods, for example, but it does provide a simple, intuitive interface for many mathematical operations. Finally, `array` is designed as a substitute for the built-in array type, combining the compactness and effi- ciency of that type with a better, safer interface. Being of fixed size, `array` doesn’t support `push_back()` and `insert()`, but it does offer several other STL methods.These include `begin()`, `end()`, `rbegin()`, and `rend()`, making it easy to apply STL algorithms to `array` objects.

Suppose, for example, that you have these declarations:

```C++
vector<double> ved1(10), ved2(10), ved3(10);
array<double, 10> vod1, vod2, vod3;
valarray<double> vad1(10), vad2(10), vad3(10);
```

Furthermore, assume that `ved1`, `ved2`, `vod1`, `vod2`, `vad1`, and `vad2` all acquire suitable values. Suppose you want to assign the sum of the first elements of two arrays to the first element of a third array, and so on. With the `vector` class, you would do this:

```C++
transform(ved1.begin(), ved2.begin(), ved2.begin(), ved3.begin(), plus<double>());
```

You can do the same with the `array` class:

```C++
transform(vod1.begin(), vod1.end(), vod2.begin(), vod3.begin(),
	plus<double>());
```

However, the `valarray` class overloads all the arithmetic operators to work with `valarray` objects, so you would use this:

```C++
vad3 = vad1 + vad2;		// +overloaded
```

Similarly, the following would result in each element of `vad3` being the produce of the corresponding elements in `vad1` and `vad2`:

```C++
vad3 = vad1 * vad2;		// *overloaded
```

Suppose you want to replace every value in an array with that value multiplied by 2.5. The STL approach is this:

```C++
transform(ved3.begin(), ved3.end(), ved3.begin(),
		  bind1st(multiple<double>(), 2.5));
```

The `valarray` class overloads multiplying a `valarray` object by a single value, and it also overloads the various computed assignment operators, so you could use either of the following:

```C++
vad3 = 2.5 * vad3;		// * overloaded
vad3 *= 2.5;			// *= overloaded
```

Suppose you want to take the natural logarithm of every element of one array and store the result in the corresponding element of a second array. The STL approach is this:

```C++
tranform(ved1.begin(), ved2.end(), ved3.begin(), log);
```

The `valarray` class overloads the usual math functions to take a `valarray` argument and to return a `valarray` object, so you can use this:

```C++
vad3 = log(vad1);	// log() overloaded
```

Or you could use the `apply()` method, **which also works for non-overloaded functions**:

```C++
vad3 = vad1.apply(log);
```

The `apply()` method doesn’t alter the invoking object; instead, it returns a new object that contains the resulting values.

The simplicity of the `valarray` interface is even more apparent when you do a multistep calculation:

```C++
vad3 = 10.0 * ((vad1 + vad2) / 2.0 + vad1 * cos(vad2));
```

The `valarray` class also provides a `sum()` method that sums the contents of a `valarray` object, a `size()` method that returns the number of elements, a `max()` method that returns the largest value in an object, and a `min()` method that returns the smallest value.

The `valarray` class does have a `resize()` method, but there’s no automatic resizing of the sort you get when you use the `vector` `push_back()` method. There are no methods for inserting values, searching, sorting, and the like. In short, the `valarray` class is more limited than the `vector` class, but its narrower focus allows a much simpler interface.

The `valarray` class doesn’t have `begin()` and `end()` methods, so you can’t use them as the range arguments:

```C++
sort(vad.begin(), vad.end());	// NO, no begin(), end()
```

The following might not work:

```C++
sort(&vad[0], &vad[10]);	// might not work
```

C++11 remedies the situation by providing `begin()` and `end()` template functions that take a `valarray` object as an argument. So you would use `begin(vad)` instead of `vad.begin()`. These functions return values that are compatible with STL range requirements:

```C++
sort(begin(vad), end(vad));	// C++11 fix
```

Listing 16.20 illustrates some of the relative strengths of the `vector` and `valarray` classes. It uses `push_back()` and the automatic sizing feature of `vector` to collect data. Then after sorting the numbers, the program copies them from the `vector` object to a `valarray` object of the same size and does a few math operations.

```C++
// Listing 16.20
#include <iostream>
#include <valarray>
#include <vector>
#include <algorithm>

int main()
{
	using namespace std;
	vector<double> data;
	double temp;

	cout << "Enter numbers (<=0 to quit):\n";
	while (cin >> temp && temp > 0)
		data.push_back(temp);
	sort(data.begin(), data.end());
	int size = data.size();
	valarray<double> numbers(size);
	int i;
	for (i = 0; i < size; i++)
		numbers[i] = data[i];
	valarray<double> sq_rts(size);
	sq_rts = sqrt(numbers);
	valarray<double> results(size);
	results = numbers + 2.0 * sq_rts;
	cout.setf(ios_base::fixed);
	cout.precision(4);
	for (i = 0; i < size; i++)
	{
		cout.width(8);
		cout << numbers[i] << ": ";
		cout.width(8);
		cout << results[i] << endl;
	}
	cout << "done\n";
	return 0;
}
```

The `valarray` class has many features besides the ones discussed so far. For example, if `numbers` is a `valarray<double>` object, the following statement creates an array of `bool` values, with `vbool[i]` set to the value of `numbers[i] > 9`--—that is, to `true` or `false`:

```C++
valarray<bool> vbool = numbers > 9;
```

There are extended versions of subscripting. Let’s look at one—--the `slice` class. A `slice` class object can be used as an array index, in which case it represents, in general, not just one value but a subset of values. A `slice` object is initialized to three integer values: the `start`, the `number`, and the `stride`. The `start` indicates the index of the first element to be selected, the `number` indicates the number of elements to be selected, and the `stride` rep- resents the spacing between elements. For example, the object constructed by `slice(1,4,3)` means select the four elements whose indexes are 1, 4, 7, and 10. That is, start with the start element, add the `stride` to get the next element, and so on until four elements are selected. If, say, `varint` is a `vararray<int> object`, then the following statement would set elements 1, 4, 7, and 10 to the value `10`:

```C++
varint[slice(1, 4, 3)] = 10; // set selected elements to 10
```

This special subscripting facility allows you to use a one-dimensional `valarray` object to represent two-dimensional data. For example, suppose you want to represent an array with 4 rows and 3 columns. You can store the information in a 12-element `valarray` object. Then a `slice(0,3,1)` object used as a subscript would represent elements 0, 1, and 2--—that is, the first row. Similarly, a `slice(0,4,3)` subscript would represent elements 0, 3, 6, and 9—--that is, the first column. Listing 16.21 illustrates some features of `slice`.

```C++
// Listing 16.21
#include <iostream>
#include <valarray>
#include <cstdlib>

const int SIZE = 12;
typedef std::valarray<int> vint;	// simplify declarations
void show(const vint & v, int cols);
int main()
{
	using std::slice;
	using std::cout;
	vint valint(SIZE);		// think of as 4 rows of 3
	int i;
	for (int i = 0; i < SIZE; i++)
		valint[i] = std::rand() % 10;
	cout << "Original array:\n";
	show(valint, 3);					// show in 3 columns
	vint vcol(valint[slice(1,4,3)]);	// extract 2nd column;
	cout << "Second column:\n";
	show(vcol, 1);						// show in 1 column
	vint vrow(valint[slice(3,3,1)]);	// extract 2nd row
	cout << "Second row:\n";
	show(vrow, 3);
	valint[slice(2, 4, 3)] = 10;		// assign to 2nd column
	cout << "Set last column to 10:\n";
	show(valint, 3);
	cout << "Set first column to sum of next two:\n";
	// + not defined for slices, so convert to valarray<int>
	valint[slice(0,4,3)] = vint(valint[slice(1,4,3)]) + vint(valint[slice(2,4,3)]);
	show(valint, 3);
	return 0;
}

void show(const vint & v, int cols)
{
	using std::cout;
	using std::endl;
	int lim = v.size();
	for (int i = 0; i < lim; i++)
	{
		cout.width(3);
		cout << v[i];
		if (i % cols == cols - 1)
			cout << endl;
		else
			cout << ' ';
	}
	if (lim % cols != 0)
		cout << endl;
}
```

The `+` operator is defined for `valarray` objects, such as `valint`, and it’s defined for a single int element, such as `valint[1]`. But as the code in Listing 16.21 notes, the `+` operator isn’t defined for `slice`-subscripted `valarray` units, such as `valint[slice(1,4,3)]`. Therefore, the program constructs full objects from the slices to enable addition:

```C++
vint(valint[slice(1,4,3)])	// calls a slice-based constructor
```

The `valarray` class provides constructors just for this purpose.

### The `initializer_list` Template (C++11)

The `initializer_list` template is another C++11 addition to the C++ library. You can
use the initializer-list syntax to initialize an STL container to a list of values:

```C++
std::vector<double> payments = {45.99, 39, 23, 19.95, 89.01};
```


This would create a container for four elements and initialize the elements to the four values in the list. What makes this possible is that the container classes now have constructors taking an `initializer_list<T>` argument. A `vector<double>` object, for example, has a constructor that accepts an `initializer_list<double>` argument, and the previous declaration is the same as this:

```C++
std::vector<double> payments({45.99, 39.23, 19.95, 89.01});
```

Here, the list is written explicitly as a constructor argument.

Normally, as part of the C++11 universal initialization syntax, you can invoke a class constructor using `{}` instead of `()` notation:

```C++
shared_ptr<double> pd {new double};	// ok to use {} instead of ()
```

But this would create problems if there also is an `initializer_list` constructor:

```C++
std::vector<int> vi {10};	// ??
```

Which constructor does this invoke?

```C++
std::vector<int> vi(10);	// case A: 10 uninitialized elements
std::vector<int> vi({10});	// case B: 1 element set to 10
```

The answer is that if the class does have a constructor accepting an `initializer_list` argument, then using the `{}` syntax invokes that particular constructor. So in this example, case B applies.

The `initializer_list` elements should all be of one type. However, the compiler will do conversions to match the type:

```C++
std::vector<double> payments {45.99, 32.23, 19, 89};
// same as std::vector<double> payments {45.99, 39.23, 19.0, 89.0};
```

Here, because the `vector` element type is `double`, the list is type `initializer_list<double>`, and `19` and `89` are converted to `double`.

The usual list restrictions on narrowing apply:

```C++
std::vector<int> values = {10, 8, 5.5};	// narrowing, compile-time error
```

It doesn’t make sense to provide an `initializer_list` constructor unless the class is meant to handle lists of varying sizes. For instance, you don’t want an `initializer_list` constructor for a class taking a fixed number of values. For example, the following declaration does not provide an `initializer_list` constructor for the three data members:

```C++
class Position
{
private:
	int x;
	int y;
	int z;
public:
	Position(int xx = 0, int yy = 0, int zz = 0)
		: x(xx), y(yy), z(zz) {}
	// no initializer_list constructor
	...
};
```

This allows you to use the `{}` syntax with the `Position(int,int,int)` constructor:

```C++
Position A = {20, -3};	// uses Position(20, -3, 0)
```

### Using `initializer_list`

You can use `initializer_list` objects in your code by including the `initializer_list` header file. The template class has `begin()` and `end()` members, and you can use them to access list elements. It also has a `size()` member that returns the number of elements. Listing 16.22 shows a simple example using `initializer_list`. It requires a compiler that supports this C++11 feature.

```C++
// Listing 16.22
#include <iostream>
#include <initializer_list>

double sum(std::initializer_list<double> il);
double average(const std::initializer_list<double> & ril);

int main()
{
	using std::cout;
	cout << "List 1: sum = " << sum({2, 3, 4})
		 << ", ave = " << average({2, 3, 4}) << '\n';
	std::initializer_list<double> dl = {1.1, 2.2, 3.3, 4.4, 5.5};
	cout << "List 2: sum = " << sum(dl)
		 <<", ave = " << average(dl) << '\n';
	dl = {16.0, 25.0, 36.0, 40.0, 64.0};
	cout << "List 3: sum = " << sum(dl)
		 <<", ave = " << average(dl) << '\n';
	return 0;
}

double sum(std::initializer_list<double> il)
{
	double tot = 0;
	for (const auto & x : il)
		tot += x;
	return tot;
}

double average(const std::initializer_list<double> & ril)
{
	double tot = 0;
	int n = ril.size();
	double ave = 0.0;
	if (n > 0)
	{
		for (const auto & x : ril)
			tot += x;
		ave = tot / n;
	}
	return ave;
}
```

You can pass an `initializer_list` object by value or by reference, as shown by `sum()` and `average()`. The object itself is small, typically two pointers (one to the beginning and one past end) or a pointer to the beginning and an integer representing the size, so the choice is not a major performance issue. (The STL passes them by value.)

The function argument can be a list literal, like `{2,3,4}`, or it can be a list variable, like `dl`.

The iterator types for `initializer_list` are `const`, so you can’t change the values in a list:

```C++
*dl.begin() = 2011.6;		// not allowed
```

But, as Listing 16.22 shows, you can assign a list variable to a different list:

```C++
dl = {16.0, 25.0, 36.0, 40.0, 64.0};	// allowed
```

However, the intended use of the `initializer_list` class is to pass a list of values to a
constructor or some other function.

