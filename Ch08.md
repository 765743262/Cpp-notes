# Chapter 8

## Content

* Inline functions
* Reference variables
* Pass argument by reference
* Default arguments
* Function overloading
* Function templates
* Function templates specializations

## Inline Functions

The difference between normal and inline functions is how compiler incorporates them:

* Normal functions:

	The program will jump to the function's address and then jump back.

	This includes:

	* Reach call
	* Stores memory address of instructions *following* the call
	* **Copy function arguments** to the stacks
	* Jump to the address of function and execute
	* Jump back.

* Inline functions:
	
	The compiler put the compiled code in the program. So we do not need to jump back and forth.

**A disavantage:**

Comes with a memory penalty if an inline function is called at several locations.

To use inline, you must take at least two actions:

* Preface the function declaration with the keyword inline
* Preface the function definition with the keyword inline.

C's macros are not real functions. **Always** convert a macro to an inline function if you can.

## Reference Variables

### Creating a Reference Variable

"**Reference**" is a type. So "**reference variable**" makes sense.

The main use is as a formal argument.

**Declaration:**
		
	int rats;
	int & rodents = rats;

Note you place "&" just as how you will place a "*".

**NOTE: YOU MUST INITIALIZE A REFERENCE VARIABLE WHEN YOU DECLARE IT**, code like

	int rat;
	int & rodent;
	rodent = rat;

isn't allowed.

### References as Function Parameters

* **Passing by reference**:
  
  Allows a called function to access variables in the calling function.

* Passing by value:
  
  Just make a copy of that variable.

A function using reference as arguments may look like this:

	void swap(int & a, int & b);

And to use, you use:
	
	int first, second;
	swap(first, second);

Note passing by value and passing by reference may look identical. The **only** way to distinguish them is to look at the prototype or the definition.

### Reference Properties and Oddities

Functions that pass by value can use many kinds of actual argument like expressions. But this is not the case for contemporary C++.

But in early years of C++, 

	refcude(x + 3.);

is allowed. This will create a temporary, nameless variable with the value of x + 3.0. Then ra becomes a reference to that variable.

#### Temporary Variables, Reference Arguments, and const

Currently, a temporary variable can be permitted **only when the argument is a const reference.**

Provided that the reference parameter is a const (**and only in this case the following two applies**):

* When the actual argument is the corret type but not lvalue. **Non-const variable IS of correct type**
* When the actual argument is the wrong type, but it's of a type that can be converted to correct type

**Note:**

* Lvalue: all variables with an address. Const variables are non-modifiable lvalue.
* Non-lvalue: literal constants, expressions.

Consider codes:

	double side = 3.0;
	long edge = 5L;
	double refcude(double & d);

	double(side);
	double(edge);
	double(side + 10.0);

The latter two are the cases. But note double(side) is a exact match.

Note what compiler do: create a temporary and anonymous variable and **makes ra refer to it**.

The reason why **only this is okey for constant reference** is non-const reference is for modification, but a temporary variable cannot achieve that.

So in short, temporary variable is created when parameter is const reference and the argument isn't an lvalue or of the wrong type.

* refcube(a_long_variable);
* refcube(3.0 + x);

Const: const parameter accepts both non-const and const argument as exact match.

### Using References with a Structure

Suppose a structure definition:

	struct free_throws
	{
		std::string name;
		int made;
		int attempts;
		float percent;
	};

Then a function using a reference could be prototyped as follows:
	
	void set_pc(free_throws & ft);

Note we replace built-int types like int with "free_throws".

We can return a reference to the structure: 

	free_throws & accumulate(free_throw & target, const free_throw & source);

In the return statement, we just return the variable we want to refer to. In this case
the function call can be use as if it were the variable it refer to like:

	display(accumulate(a, b));

or

	accumulate(a, b) = k;
	accumulate(a, b).member
	accumulate(accumulate(a, b), c);

### Why Return a Reference?

This is similar to the difference between passing by value and passing by reference.

Consider
	
	dup = accumulate(team, five);

If accumulate() returns a structre, this could involve copying the entire structure. This is inefficient.

**Note: a function that returns a reference is actually an alias for the referred-to variable.**

### Being Careful About What a Return Reference Refers To

**NEVER return a reference to a temporary variable.**

There are two ways to avoid this:

1. Return a reference that was passed as an argument to the function.
2. Use new to create new storage.

One example of the second way:

	const free_throw & clone(free_throws & ft)
	{
		free_throw * ft = new free_throw;

		*pt = ft;
		return *pt;
	}

Note *pt is a lvalue so it can be assign to a reference variable.

Then you can use this function like:

	free_throw & jolly = clone(three);

**Remeber to use delete to free momery allocated.**

### Why Use const with a Reference Return?

Regular return types are _rvalues. Non-const reference return types are modifiable lvalues. Const reference are non-modifiable lvalues.





Also note in the prototype, first argument isn't const but the second is.







