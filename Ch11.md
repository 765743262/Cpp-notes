# Chapter 11 Working with Classes

In this chapter you will learn about the following:

* Operator overloading
* Friend functions
* Overloading the  `<<` operator for output
* State members
* Using `rand()` to generate random values
* Automatic conversions and type casts for classes
* Class conversion functions

## Operator Overloading

_Operator overloading_ is an example of C++ polymorphism.

C++ lets you to extend operator overloading to user-defined types. The compiler **uses the number and type of operands to determine which definition of addition to use**.

You can define a class that represents arrays and that overloads the `+` operator so that you can do this:

```C++
evening = sam + janet;
```

The simple addition conceals the mechanics and emphasizes **what is essential**.

To overload an operator, you use a speicial function form called an _operator function_. **An operator function has the following form, where `_op_` is the symbol being overloaded**:

``` C++
opearator_op_(argument-list)
```

For example, `operator+()` overloads the `+` operator. **The `op` has to be valid C++ operator; you can't just make up a new symbol like @**. But the `operator[]()` function  would overload the `[]` operator because `[]` is the array-indexing operator.

Suppose you define an `operator+()` member function, then statement like

```C++
district2 = sid + sara;
```

may be replaced by

```C++
district2 = sid.operator+(sara);
```

## Time on Our Hands: Devoloping an Operator Overloading Example

Suppose you need a class to perform time addtion, you may have the following class declaration and method definition:

Listing 11.2


``` C++
class Time
{
private:
	int hours;
	int minutes;
public:
	Time();
	Time(int h, int m = 0);
	
	Time Sum(const Time & t) const;
	Time operator+(const Time & t) const;
	void Show() const;
};

Time::Time()
{
	hours = minutes = 0;
}

// default values should not occur here
Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

// Time Time::Sum(const Time & t) const
Time Time::operator+(const Time & t) const
{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}

void Time::Show() const
{
	std::cout << hours << " hours, " << minutes << " minutes";
}
```

Note we define a regular method version  `Time Sum(const Time & t) const` and an TIme operator version `Time operator+(const Time & t) const`. **Both these functions have exactly same pass-by-value return type, one argument, and the same code**.

Note the return type eas `Time` rather than `Time &` because **`sum` object is a local variable and is destroyed when the function terminates**. Using a `Time` return type means the program constructs a _copy_ of `sum` before destroying it.

You can invoke the `operator+()` method by using the same syntax that `Sum()` uses:

```C++
total = coding.operator+(fixing);
```

or use operator notation

```C++
total = coding + fixing;
```

Note that with the operator notation, **the object to the left of the operator is the invoking object and the object to the right is the one passed as an argument.**

The compiler uses the operand types to figure out what to do:

```C++
int a, b, c;
Time A, B, C;
c = a + b;
C = A + B;
```

You can add more than two objects:

```C++
t4 = t1 + t2 + t3;
```

**In this case, the statement is translated into**:

```C++
t1.operator+(t2.operator+(t2));
```

### Overloading Restrications

Overloaded operator (with some exceptions) **don't necessarily have to be member functions**. However, **at least one operands has to be a user-defined type**. Let's take a closer look at the limits:

* You can't create new operator symbols like `**`.
* The overloaded operator must have at least one operand that is user-defined type.
* You can't use an operator in a manner that violates the syntax rules for the original operator. For example, **you can't overload the modulus operator (%) so that it can be used with a single operand**.
* You cannot overload the following operators:

  ```C++
  sizeof
  .
  .*
  ::
  ?:
  typeid
  const_cast
  dynamic_cast
  reinterpre_cast
  static_cast
  ```

* Most of the operators in Table 11.1 can be overloaded by using **either member or nonmember functions**. However, you can use **_only_ member functions to overload the following operators**:

  ```C++
  =
  ()
  []
  ->
  ```

  Table 11.1 is omiited.

In addition to these formal restrictions, you should use sensible retraint in overloading operators. For example, you shouldn't use * operator so that is swaps the data member of two  `Time` object. Nothing in the notation would suggest what the operator did, so it would better to define a class method with an explanotory name such as `Swap()`.

### More Overloaded Operators

We introduce subtraction and multiplication by a factor:

```C++
Time operator-(const Time & t) const;
Time operator*(double n) const;

Time Time::operator-(const Time & t) const
{
	Time diff;
	int tot1, tot2;
	tot1 = t.minutes + 60 * t.hours;
	tot2 = minutes + 60 * hours;
	diff.minutes = (tot2 - tot1) % 60;
	diff.hours = (tot2 - tot1) / 60;
	return diff;
}
Time Time::operator*(double n) const
{
	Time result;
	long totalminutes = hours * mult * 60 + minutes * mult;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
```

## Introducing Friends

Friends comes in three varieties:

* Friend functions
* Friend classes
* Friend member functions

By makeing a function **a friend to a class**, you allow the function the same access privileges that a member function of the class has. We will only look at the friend functions in this chapter.

The overloaded multiplication operator is that it combines two different types. That cause a problem. You cannont handle the following statement:

```C++
A = 2.75 * B;
```

`2.75` is not a type `Time` object. The compiler cannot replace the expression with a member function call.

One way around this difficulty is to tell everyone that you can onle write `B * 2.75`. This is a **server-friendly, cliend-beware** solution, and that's not what OOP is about.

Because operators can be overloaded using either member of nonmember functions, we consider using a nonmember function:

```C++
Time operator*(double m, const Time & t);
```

This will make the left operand the first argument of the operator function and the right operand the second argument of the function. But it raises a new problem: **nonmember functions can't directly access private data in a class.** There is a special catagory of nonmember functions, called _friends_, that can access private members of a class.

### Creating Friends

* Step 1: Place a prototype **in the class declaration and prefix the declaration with the keyword `friend`:

  ```C++
  friend Time operator*(double m, const Time & t);
  ```

  The prototype has two implications:

  * Although the `operator*()` function is declare in the class declaration, **it is not a member function and isn't invoked by using the membership operator**.
  * Although the `operator*()` functions is not a member function, **it has the same access rights as a member function.**

* Step 2: Write the function definition. Because it is not a member function, **you don't use the `Time::` qulifier**. Also **you don't use the keyword `friend`:

  ```C++
  Time operator*(double m, const Time & t)
  {
      Time result;
      long totalminutes = t.hours * mult * 60 + t.minutes * mult;
      result.hours = totalminutes / 60;
      result.minutes = totalminutes % 60;
      return result;
  }
  ```

With this declaration and definition, the statement:

```C++
A = 2.75 * B;
```

translates to the following:

```C++
A = operator*(2.74, B);
```

In short, **a friend function to a class is a nonmember function that has the same access right as a membe function.**

The friends function doesn't deviate from the OOP approach because only a class declaration can decide which functions are friends, so the class declaration still controls which functions access private data. In short, **class methods and friends are simply two different mechanisms for expressing a class interface**.

Actually, you can write this particular friend function as a non-friend function:

```C++
Time operator*(double m, const Time & t)
{
	return t * m;
}
```

There are reasons two make this version a friend:

* A friend version ties the function in as part of the official class interface.
* If you later find a need for the function to access private data, you only have to alter the definition rather than the prototype.

### A Common Kind of Friend: Overloading the << Operator

You can overloaded the `<<` operator so that you can use it with cout to display an object's contents like:

```C++
cout << trip;
```

Actually << is already heavily overloaded. `ostream` class includes an overloaded `operator<<()` definition for each of the basic types.

One way to teach `cout` to recognize a `Time` object is to add a new function operator definition to the `ostream` class declaration. But that's a dangerous idea. Instead, use the `Time` class declaration to teach the `Time` class how to use `cout`.

#### The First Version of Overloading <<

To teach the `Time` class to use `cout`, **you must use a friend function**. That's because if you use a `Time` member function to overload <<, **the `Time` object would come first. That means you would have to sue the << operator this way:

```C++
trip << cout
```

which is confusing.

By using a friend function, you can overloaded the operator this way:

```C++
void operator<<(ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
}
```

This lets you use

```C++
cout << trip;
```

> ##### Friend or No Friend?
> You should note that `operator<<()` function is a friend to the `Time` class but not a friend to the `ostream` class. That's because it accessed individual members of the `Time` object but only uses the `ostream` object as a whole. It accesses private `Time` object members directly, but it does not directly access private `ostream` object members.

Note that the function **must use the `ostream` reference `os` as its first argument. Because it needs to manipulate the object itself rather that a copy. The second argument is reference for efficiency.

> ##### What? You Don't Know of Any Other `ostream` Object?

> Another `ostream` object is `cerr`, which routes output to the standard error system. Also, `os` can refer to a `ofstream` object.

#### The Second Version of Overloading <<

The second version allow you to combine the redefined << operator with the ones `cout` normally uses:

```C++
cout << "Trip time: " <<  trip << " (Tuesday)\n";
```

By making the operator function return an `ostream` reference:

```C++
ostream & opearator<<(ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
	return os;
}
```

The fact that the return type is `ostream &` and the return value is `os` means the function's return value is just the object passed to it. Thus, you can do:

```C++
cout << "Trip time: " << trip << " (Tuesday)\n";
```

As a point of interest, this version of `operator<<()` also can be used for file output:

```C++
#include <fstream>
...
ofstream fout;
fout.open("savetime.txt");
Time trip(12, 40);
fout << trip;
```

> ##### Tip

> In general, to overload the << operator to display an object of class `c_name`, you use a friend function with a definition in this form:

```C++
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ... ;
	return os;
}
```

The following code illustrate friend version of `operator*()` and `operator<<()`:

Listing 11.10

```C++
class Time
{
private:
	int hours;
	int minutes;
public:
	Time();
	Time(int h, int m = 0);
	Time operator+(const Time & t) const;
	Time operator-(const Time & t) const;
	Time operator*(double m) const;
	friend operator*(double m, const Time & t) { return t * m};
	friend ostream & operator<<(std::ostream & os, const Time & t);
}

std::ostream & operator<<(std::ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
	return os;
}
```

Note we make `operator*()` inline because it's simple.

## Overloaded Operators: Member Versus Nonmember Functions

For many operators, you have a choice between using member functions or non-member functional.

A nonmember version of an overloaded operator function requires as many formal parameters as the operator has operands. A member version requires **one fewer parameter** because one operand is passed implicitly as the invoking object.

For some operators like `[]`, the member function is the only valid choice. Otherwise it often doesn't make much difference. Depending on the class design, the nonmember function may have an advantage especially if you defined type conversions for the class.

## More Overloading: A Vector Class

Please refer to Listing 11.13.

Listing 11.13 (partial)

```C++
#ifndef vetc_hpp
#define vetc_hpp

#include <iostream>
namespace VECTOR
{
	class Vector
	{
	public:
		enum Mode {RECT, POL};
	private:
		double x;
		double y;
		double mag;
		double ang;
		Mode mode;
		void set_mag();
		void set_ang();
		void set_x();
		void set_y();
	public:
		Vector();
		Vector(double n1, double n2, Mode form = RECT);
		void reset(double n1, double n2, Mode form = RECT);
		~Vector();
		double xval() const {return x;}
		double yval() const {return y;}
		double magval() const {return mag;}
		double angval() const {return ang;}
		void polar_mode();
		void rect_mode();
	// operator overloading
		Vector operator+(const Vector & b) const;
		Vector operator-(const Vector & b) const;
		Vector operator-() const;
		Vector operator*(double n) const;
	// friends
		friend Vector operator * (doublen , const Vector & a);
		friend std::ostream & operater<<(std::ostream & os, const Vector & v);

	};
}

#endif /* vetc_hpp */

//
//  vetc.cpp
//  Listing 11.13
//
//  Created by lin on 04/09/2017.
//  Copyright © 2017 lin. All rights reserved.
//

#include "vetc.hpp"
#include <cmath>
#include "vect.h"
using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VEVTOR
{
	const double Rad_todeg = 45.0 / atan(1.0)

	void Vector::set_mag()
	{
		mag = sqrt(x * x + y * y);
	}

	void Vector::set_ang()
	{
		if (x == 0 && y == 0)
			ang = 0.0;
		else
			ang = atan2(y, x);
	}

	void Vector::set_x()
	{
		x = mag * cos(ang);
	}

	void Vector::set_y()
	{
		y = mag * sin(ang);
	}

	Vector::Vector()
	{
		x = y = mag = ang = 0.0;
		mdoe = RECT;
	}

	Vector::Vector(double n1, double n2, Mode form)
	{
		mode = form;
		if (form = RECT)
		{
			x = n1;
			y = n2;
			set_mag();
			set_ang();
		}
		else if (form = POL)
		{
			mag = n1;
			ang = n2 / Rad_to_deg;
			set_x();
			set_y();
		}
		else
		{
			cout << "Incorrect 3rd argument to Vector() -- ";
			cout << "vecotr set to 0\n";
			x = y = mag = ang = 0.0;
			mode = RECT;
		}
	}

	void Vector::reset(double n1, double n2, Mode form)
	{
		mode = form;
		if (form = RECT)
		{
			x = n1;
			y = n2;
			set_mag();
			set_ang();
		}
		else if (form = POL)
		{
			mag = n1;
			ang = n2 / Rad_to_deg;
			set_x();
			set_y();
		}
		else
		{
			cout << "Incorrect 3rd argument to Vector() -- ";
			cout << "vecotr set to 0\n";
			x = y = mag = ang = 0.0;
			mode = RECT;
		}
	}

	Vector::~Vector()
	{
	}

	void Vector::polar_mode()
	{
		mode = POL;
	}

	void Vector::rect_mode()
	{
		mode = RECT;
	}

	Vector Vector::operator+(const Vector & b) const
	{
		return Vector(x + b.x, y + b.y);
	}

	Vector Vector::operator-(const Vector & b)
	{
		return Vector(x - b.x, y - b.y);
	}

	Vector Vector::operator-() const
	{
		return Vector(-x, -y);
	}

	Vector Vector::operator*(double n) const
	{
		return Vector(x * n, y * n);
	}

	Vector operator*(double n, const Vector & a)
	{
		return a * n;
	}

	std::ostream & operator<<(std::ostream & os, const Vector & v)
	{
		if (v.mode == Vector::RECT)
			os << "(x, y) = (" << v.x << ", " << v.y << ")";
		else if (v.mode == Vector::POL)
		{
			os << "(m, a) = (" << v.mag << v.ang * Rad_to_deg << ")";
		}
		else
			os << "Vector object mode is invalid";
		return os;
	}

}

```

Features:

* **Has two representation for a vector at the same time**
* Puts the whole class in a namespace `VECTOR`
* Uses `enum` to create two constants (RECT and POL)
* Public portion appear first and last
* `set` series functions are all `const`

Note the `reset()` method isn't needed. It can be replaced with constructor like:

```C++
shove = Vector(100, 300);
```

But this will create and assign a temporary object, which is not so effiecient.

We'll look at some of the features in more detail.
### Using a State Member

The Vector class uses a _state member_ called `mode` to control which form the constructor, the `reset()` method, and he overloaded `operator<<()` function use with the enumerations `RECT` and `POL`.

The identifier has class scope. The fully qualified name is `VECTOR::Vector::POL`.

Note that the constructor delivers a warning if something other than `RECT` or `POL` is specified. But actually, an integer like 2 can't implicitly be converted to an `enum` type.

**Because `operator<<()` is a friend function and **not part of the class scope**, it has to use `Vector::RECT` insead of `RECT`.

> ##### Multiple Representations and Classes

> Quantities that have different, but equivalent, representations are common. First, you can store multiple representations in one object. Second, **you can writed the class functions so that assigning values for one representation automatically assigns values fo the other representation.**

### Overloading Operators for the `Vector` Class

Adding two vectors is very simple. So **you might be tempted to use this code**:

```C++
Vector Vector::operator+(const Vector & b) const
{
	Vector sum;
	sum.x = x + b.x;
	sum.y = y + b.y;
	return sum;
}
```

First note **we can access private members in b because it's in the same class.

This would be fine if the object stores only the x and y components. But this version fails to set the polar values. You could fix this by adding more code:

```C++
Vector Vector::operator+(const Vector & b) const
{
	Vector sum;
	sum.x = x + b.x;
	sum.y = y + b.y;
	sum.set_mag();
	sum.set_mag();
	return sum;
}
```

But **it is much simpler and more reliable to let a constructor do the work:

```C++
Vector Vector::operator+(const Vector & b)
{
	return Vector(x + b.x, y + b.y);
}
```

This way, you guaranteed that the new `Vector` object is created according to the **standard rules you lay down in the constructor**.

> ##### Tip

> **If a method needs to compute a new class object, you should see if you can sue a class constructor to do the work. Not only does that save you trouble, it ensures that the new object is constructed in the proper fashion.**

#### Mutiplication

As with overloaded addition, the code lets a constructor create the correct `Vector` object from the new x and y components:

```C++
Vector Vector::operator*(double n) const
{
	return Vector(n * x, n * y);
}
```

And as in the `Time` example, you can use an inline friend function to handle `double` times `Vector`:

Vector operator*(double n, const Vector & a)
{
	return a * n;
}

#### More Refinement: Overloading an Overloaded Operator

You can define both binary and unary versions of the `-` operator because C++ provides both binary and unary versions of that operator to begin with:

```C++
Vector operator-(const Vector & b) const;
Vector Vector::operator-(const Vector & b) const 
{
	return Vector(x - b.x, y - b.y);
}

Vector operator-() const;
Vector Vector::operator-() const
{
	return Vector(-x, -y);
}

> ##### Note

> **You can overload the same operator many times as long as each operator function has a distinct signature and as long as each operator function has the same number of operands as the corresponding built-in C++ operator.**

### An Implementation Comment

You have two ways to implement these two representations, but the public interface doesn't depend on this. 

Storing the data means that the object occupies more memory and the code has to be careful to update both datas. But data look-up is faster.

Which is better depends on how often these two representations are used. **You would choose one implementation in one program and the second implementation in another, yet retain the same user interface for both.**

### Taking the `Vector` Class on a Random Walk

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "vect.hpp"
int main(void)
{
	using namespace std;
	using VECTOR::Vector;
	srand(time(0));
	double direction;
	Vector step;
	Vector result(0.0, 0.0);
	unsigned long steps = 0;
	double target;
	double dstep;
	cout << "Enter target distance (q to quit): ";
	while (cin >> target)
	{
		cout << "Enter step length: ";
		if (!(cin >> dstep))
			break;
		while (result.magval() < target)
		{
			direction = rand() % 360;
			step.reset (dstep, direction, Vector::POL);
			result = result + step;
			steps++;
		}
		cout << "After " << steps << " steps, the subject "
			"has the following location:\n";
		cout << result << endl;
		result.polar_mode();
		cout << " or\n" << result << endl;
		cout << "Average outwatd distance step = "
		<< result.magval() / steps << endl;
		steps = 0;
		result.reset(0.0, 0.0);
		cout << "Enter target distance (q to quit): ";
	}

	cout << "Bye!\n";
	cin.clear();
	while (cin.get() != '\n')
		continue;
	return 0;
}
```

The program uses the `result` to keep track of the walker's progress. On each cycle of the inner loop, the program sets the `step` vector to a new direction and adds it to the current `result` vector.

**Incidentally, the following statement has the effect of placing `result` in the `RECT` mode, regardless of the initial mode of `result` and `step`:

```C++
result = result + step;
```

The addition operator creates and returns a **new vector that holds the sum of two arguments.** The function creates the vector by using the default constructor, which creates vectors in `RECT` mode. 

By default, **assignment assigns each member variable individually, so `RECT` is assigned to `result.mode`.**

If you would prefer some other behavior, such as `result` retaining its original mode, you can override default assignment by **defining an assginment operator for the class**.

