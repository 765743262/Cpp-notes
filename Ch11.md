# Chapter 11 Working with Classes

In this chapter you will learn about the following:

* Operator overloading
* Friend functions
* Overloading the  `<<` operator for output
* State members
* Using `rand()` to generate random values
* Automatic conversions and type casts for classes
* Class conversion functions

## Operator Overloading

_Operator overloading_ is an example of C++ polymorphism.

C++ lets you to extend operator overloading to user-defined types. The compiler **uses the number and type of operands to determine which definition of addition to use**.

You can define a class that represents arrays and that overloads the `+` operator so that you can do this:

```C++
evening = sam + janet;
```

The simple addition conceals the mechanics and emphasizes **what is essential**.

To overload an operator, you use a speicial function form called an _operator function_. **An operator function has the following form, where `_op_` is the symbol being overloaded**:

``` C++
opearator_op_(argument-list)
```

For example, `operator+()` overloads the `+` operator. **The `op` has to be valid C++ operator; you can't just make up a new symbol like @**. But the `operator[]()` function  would overload the `[]` operator because `[]` is the array-indexing operator.

Suppose you define an `operator+()` member function, then statement like

```C++
district2 = sid + sara;
```

may be replaced by

```C++
district2 = sid.operator+(sara);
```

## Time on Our Hands: Devoloping an Operator Overloading Example

Suppose you need a class to perform time addtion, you may have the following class declaration and method definition:


``` C++
// Listing 11.4
class Time
{
private:
	int hours;
	int minutes;
public:
	Time();
	Time(int h, int m = 0);
	
	Time Sum(const Time & t) const;
	Time operator+(const Time & t) const;
	void Show() const;
};
```

``` C++ 
// Listing 11.5
Time::Time()
{
	hours = minutes = 0;
}

// default values should not occur here
Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

// Time Time::Sum(const Time & t) const
Time Time::operator+(const Time & t) const
{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}

void Time::Show() const
{
	std::cout << hours << " hours, " << minutes << " minutes";
}
```

Note we define a regular method version  `Time Sum(const Time & t) const` and an `Time` operator version `Time operator+(const Time & t) const`. **Both these functions have exactly same pass-by-value return type, one argument, and the same code**.

Note the return type is `Time` rather than `Time &` because the **`sum` object is a local variable and is destroyed when the function terminates**. Using a `Time` return type means the program constructs a _copy_ of `sum` before destroying it.

You can invoke the `operator+()` method by using the same syntax that `Sum()` uses:

``` C++
total = coding.operator+(fixing);
```

or use the operator notation

``` C++
total = coding + fixing;
```

Either notation invokes the `operator+()` method. Note that with the operator notation, **the object to the left of the operator is the invoking object and the object to the right is the one passed as an argument.** Listing 11.6 illustrates this point.

``` C++
// Listing 11.6
#include <iostream>
#include "test.hpp"

int main(void)
{
	using std::cout;
	using std::endl;
	Time planning;
	Time coding(2, 40);
	Time fixing(5, 55);
	Time total;

	cout << "planning time = ";
	planning.Show();
	cout << endl;

	cout << "coding time = ";
	coding.Show();
	cout << endl;

	cout << "fixing time = ";
	fixing.Show();
	cout << endl;

	total = coding + fixing;
	cout << "coding + fixing = ";
	total.Show();
	cout << endl;

	Time morefixing(3, 28);
	cout << "more fixing time = ";
	morefixing.Show();
	cout << endl;

	// function notation
	total = morefixing.operator+(total);
	cout << "morefixing.operator+(total) = ";
	total.Show();
	cout << endl;
}
```

In short, the name of the `operator+()` function allows it to be invoked by using either function notation or operator notation. The compiler uses the operand types to figure out what to do:

``` C++
int a, b, c;
Time A, B, C;
c = a + b;		// use int addition
C = A + B;		// use addition as defined for Time objects
```

You can add more than two objects:

``` C++
t4 = t1 + t2 + t3;
```

**In this case, the statement is translated into**:

``` C++
t1.operator+(t2.operator+(t2));
```

### Overloading Restrications

Overloaded operator (with some exceptions) **don't necessarily have to be member functions**. However, **at least one operands has to be a user-defined type**. Let's take a closer look at the limits C++ imposed on user-defined operator overloading:

* The overloaded operator must have at least one operand that is a user-defined type. This prevents you from overloading operators for standard types.
* You can't create new operator symbols like `**`.
* You can't use an operator in a manner that violates the syntax rules for the original operator. For example, **you can't overload the modulus operator (%) so that it can be used with a single operand**.
* You cannot overload the following operators:

``` C++
sizeof
.
.*
::
?:
typeid
const_cast
dynamic_cast
reinterpre_cast
static_cast
```

* Most of the operators in Table 11.1 (see Table 11.1 in the text at p573) can be overloaded by using **either member or nonmember functions**. However, you can use **_only_ member functions to overload the following operators**:

``` C++
=
()
[]
->
```

In addition to these formal restrictions, you should use sensible restraint in overloading operators. For example, you shouldn't use `*` operator so that is swaps the data member of two  `Time` object. Nothing in the notation would suggest what the operator did, so it would better to define a class method with an explanotory name such as `Swap()`.

### More Overloaded Operators

We will introduce the subtraction and multiplication by a factor operations to the `Time` class:

```C++
Time operator-(const Time & t) const;
Time operator*(double n) const;
```

These prototypes should be placed in the `Time` class definition. Here's the definition for these functions:

``` C++
Time Time::operator-(const Time & t) const
{
	Time diff;
	int tot1, tot2;
	tot1 = t.minutes + 60 * t.hours;
	tot2 = minutes + 60 * hours;
	diff.minutes = (tot2 - tot1) % 60;
	diff.hours = (tot2 - tot1) / 60;
	return diff;
}
Time Time::operator*(double n) const
{
	Time result;
	long totalminutes = hours * mult * 60 + minutes * mult;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}
```

With these changes made, you can test the new definitions with the code shown in Listing 11.9:

```C++
#include <iostream>
#include "test.hpp"

int main(void)
{
	using std::cout;
	using std::endl;
	Time weeding(4, 35);
	Time waxing(2, 47);
	Time total;
	Time diff;
	Time adjusted;

	cout << "weeding time = ";
	weeding.Show();
	cout << endl;

	cout << "waxing time = ";
	waxing.Show();
	cout << endl;

	cout << "total work time = ";
	total = weeding + waxing;
	total.Show();
	cout << endl;

	diff = weeding - waxing;
	cout << "weeding time - waxing time = ";
	diff.Show();
	cout << endl;

	adjusted = total * 1.;
	cout << "adjusted work time = ";
	adjusted.Show();
	cout << endl;

	return 0;
}
```

## Introducing Friends

Friends comes in three varieties:

* Friend functions
* Friend classes
* Friend member functions

By makeing a function **a friend to a class**, you allow the function the same access privileges that a member function of the class has. We will only look at the friend functions in this chapter.

In the previous `Time` class example, the overloaded multiplication operator is different from the other two overloaded operators in that it combines two different types. Remember, the left operand is the invokign object. That is

```C++
A = B * 2.75;
```

translates to the following member function call:

```C++
A = B.operator*(2.75);
```

But consider the following statement:

```C++
A = 2.75 * B;
```

`2.75` is not a type `Time` object. The compiler cannot replace the expression with a member function call.

One way around this difficulty is to tell everyone that you can only write `B * 2.75`. This is a server-friendly, cliend-beware solution, and that's not what OOP is about.

Because operators can be overloaded using either member of nonmember functions, we consider using a nonmember function:

```C++
Time operator*(double m, const Time & t);
```

This will make the left operand the first argument of the operator function and the right operand the second argument of the function. But it raises a new problem: **nonmember functions can't directly access private data in a class.** But there is a special catagory of nonmember functions, called _friends_, that can access private members of a class.

### Creating Friends

**Step 1**: Place a prototype **in the class declaration** and prefix the declaration with the keyword `friend`:

```C++
friend Time operator*(double m, const Time & t);
```

The prototype has two implications:

* Although the `operator*()` function is declare in the class declaration, **it is not a member function and isn't invoked by using the membership operator**.
* Although the `operator*()` functions is not a member function, **it has the same access rights as a member function.**

**Step 2**: Write the function definition. Because it is not a member function, **you don't use the `Time::` qulifier**. Also **you don't use the keyword `friend`**. The definition should look like this:

```C++
Time operator*(double m, const Time & t)
{
  Time result;
  long totalminutes = t.hours * mult * 60 + t.minutes * mult;
  result.hours = totalminutes / 60;
  result.minutes = totalminutes % 60;
  return result;
}
```

With this declaration and definition, the statement

```C++
A = 2.75 * B;
```

translates to the following:

```C++
A = operator*(2.74, B);
```

In short, **a friend function to a class is a nonmember function that has the same access right as a membe function.**

> **Are Friends Unfaithful to OOP?**
> The friends function doesn't deviate from the OOP approach because only a class declaration can decide which functions are friends, so the class declaration still controls which functions access private data. In short, **class methods and friends are simply two different mechanisms for expressing a class interface**.

Actually, you can write this particular friend function as a non-friend function by altering the definition so that it swithces which value comes first in the multiplication:

```C++
Time operator*(double m, const Time & t)
{
	return t * m;		// use t.operator*(n)
}
```

The original version accessed `t.minutes` and `t.hours` explicitly, so it had to be a friend. This version uses the `Time` object `t` as a whole, letting a member function handle the private values, so this version have to be a friend. Nonetheless, there are reasons make this version a friend:

* Most importantly, a friend version ties the function in as part of the official class interface.
* If you later find a need for the function to access private data, you only have to alter the definition rather than the prototype.

> **Tip**
> If you want to overload an operator for a class and you want to use the operator with a non-class term as the first operand, you can use a friend function to reverse the operand order.

### A Common Kind of Friend: Overloading the `<<` Operator

You can overloaded the `<<` operator so that you can use it with `cout` to display an object's contents like:

```C++
cout << trip;
```

Actually `<<` is already heavily overloaded. The `ostream` class includes an overloaded `operator<<()` definition for each of the basic types. One way to teach `cout` to recognize a `Time` object is to add a new function operator definition to the `ostream` class declaration. But that's a dangerous idea. Instead, use the `Time` class declaration to teach the `Time` class how to use `cout`.

#### The First Version of Overloading `<<`

To teach the `Time` class to use `cout`, **you must use a friend function**. That's because if you use a `Time` member function to overload `<<`, **the `Time` object would come first**. That means you would have to sue the << operator this way:

```C++
trip << cout
```

which is confusing.

By using a friend function, you can overloaded the operator this way:

```C++
void operator<<(ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
}
```

This lets you use

```C++
cout << trip;
```

> **Friend or No Friend?**
> You should note that `operator<<()` function is a friend to the `Time` class but not a friend to the `ostream` class. That's because it accessed individual members of the `Time` object but only uses the `ostream` object as a whole. It accesses private `Time` object members directly, but it does not directly access private `ostream` object members.

Note that the function must use the `ostream` reference `os` as its first argument. Because it needs to **manipulate the object `cout` itself** rather that a copy. The second argument is a reference for efficiency.

> **What? You Don't Know of Any Other `ostream` Objects?**

> Another `ostream` object is `cerr`, which routes output to the standard error system. Also, `os` can refer to a `ofstream` object.

#### The Second Version of Overloading `<<`

The second version allows you to combine the redefined `<<` operator with the ones `cout` normally uses:

```C++
cout << "Trip time: " <<  trip << " (Tuesday)\n";
```

This can be done by making the operator function return a reference to an `ostream` object:

```C++
ostream & opearator<<(ostream & os, const Time & t)
{
	os << t.hours << " hours, " << t.minutes << " minutes";
	return os;
}
```

The fact that the return type is `ostream &` and the return value is `os` means the function's return value is just the object passed to it. Thus, you can do the following:

```C++
cout << "Trip time: " << trip << " (Tuesday)\n";
```

As a point of interest, this version of `operator<<()` also can be used for file output:

```C++
#include <fstream>
...
ofstream fout;
fout.open("savetime.txt");
Time trip(12, 40);
fout << trip;
```

In general, to overload the `<<` operator to display an object of class `c_name`, you use a friend function with a definition in this form:

```C++
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ... ;
	return os;
}
```

But note: in this definition, the object at the right of `<<` should be `os` but not `cout`. And the reference to `ostream` should not be `const`.

Listing 11.10 shows the class definition as modified to include the two friend functions `operator*()` and `operator<<()`. It implements the first of these as an inline function because the code is so short.

> Caution
> You use the `friend` keyword only in the prototype found in the class declaration. You don't use it in the function definition unless the definition is also the prototype.

```C++
// Listing 11.10
#ifndef MYTIME_H_
#define MYTIME_H_
#include <iostream>

class Time
{
private:
	int hours;
	int minutes;
public:
	Time();
	Time(int h, int m = 0);
	void AddMin(int m);
	void AddHr(int h);
	void Reset(int h = 0, int m = 0);
	Time operator+(const Time & t) const;
	Time operator-(const Time & t) const;
	Time operator*(double n) const;
	friend Time operator*(double m, const Time & t)
		{return t * m; }
	friend std::ostream & operator<<(std::ostream & os, const Time & t);
};
#endif
```

Listing 11.11 shows the revised set of definitions. Note again that the methods use the `Time::` qualifier, where as the friend function does not.

```C++
// Listing 11.11
#include <iostream>
#include "test.hpp"

Time::Time()
{
	hours = minutes = 0;
}

Time::Time(int h, int m)
{
	hours = h;
	minutes = m;
}

void Time::AddMin(int m)
{
	minutes += m;
	hours += minutes / 60;
	minutes %= 60;
}

void Time::AddHr(int h)
{
	hours += h;
}

void Time::Reset(int h, int m)
{
	hours = h;
	minutes = m;
}

// Time Time::Sum(const Time & t) const
Time Time::operator+(const Time & t) const
{
	Time sum;
	sum.minutes = minutes + t.minutes;
	sum.hours = hours + t.hours + sum.minutes / 60;
	sum.minutes %= 60;
	return sum;
}

Time Time::operator-(const Time & t) const
{
	Time diff;
	int tot1, tot2;
	tot1 = t.minutes + 60 * t.hours;
	tot2 = minutes + 60 * hours;
	diff.minutes = (tot2 - tot1) % 60;
	diff.hours = (tot2 - tot1) / 60;
	return diff;
}

Time Time::operator*(double mult) const
{
	Time result;
	long totalminutes = hours * mult * 60 + minutes * mult;
	result.hours = totalminutes / 60;
	result.minutes = totalminutes % 60;
	return result;
}

std::ostream & operator<<(std::ostream & os, const Time & t)
{
	os << t.hours << "hours, " << t.minutes << " minutes";
	return os;
}

```

Listing 11.12 shows a sample program:

```
#include <iostream>
#include "test.hpp"

int main(void)
{
	using std::cout;
	using std::endl;
	Time aida(3, 35);
	Time tosca(2, 48);
	Time temp;

	cout << "Aida and Tosca:\n";
	cout << aida << "; " << tosca << endl;
	temp = aida + tosca;
	cout << "Aida + Tosca: " << temp << endl;
	temp = aida * 1.17;
	cout << "Aida * 1.17: " << temp << endl;
	cout << "10.0 * Tosca: " << 10.0 * tosca << endl;

	return 0;
}
```

## Overloaded Operators: Member Versus Nonmember Functions

For many operators, you have a choice between using member functions or nonmember functions to implement operator overloading. Typically, the nonmember version is a friend function so that it can directly access the private data for a class. For example, consider the addition operator for the `Time` class. It has this prototype in the `Time` class declaration:

```
Time operator+(const Time & t) const;	// member version
```

Instead, the class could use the following prototype:

```
friend Time operator+(const Time & t1, const Time & t2);	// nonmemeber version
```

A nonmember version of an overloaded operator function requires as many formal parameters as the operator has operands. A member version requires **one fewer parameter** because one operand is passed implicitly as the invoking object.

Keep in mind that you must choose one or the other form when defining a given operator, but not both. Defining both forms is an ambiguity error, leading to a compilation error.

For some operators like `[]`, the member function is the only valid choice. Otherwise it often doesn't make much difference. Depending on the class design, the nonmember function may have an advantage especially if you defined type conversions for the class.

## More Overloading: A Vector Class

Let's look at another class design that uses operator overloading and friends---a class representing vectors. This class also illustrates further aspects of class design, such as incorporating two different ways of describing the same thing into an object.

Listing 11.13 presents a class declaration. To refresh your memory about namespaces, the listing places the class declaration inside the `VECTOR` namespace. Also the program uses `enum` to create a couple constants (`RECT` and `POL`) for identifying the two representations.



```C++
// Listing 11.13
#ifndef vetc_hpp
#define vetc_hpp

#include <iostream>
namespace VECTOR
{
	class Vector
	{
	public:
		enum Mode {RECT, POL};
	private:
		double x;
		double y;
		double mag;
		double ang;
		Mode mode;
		void set_mag();
		void set_ang();
		void set_x();
		void set_y();
	public:
		Vector();
		Vector(double n1, double n2, Mode form = RECT);
		void reset(double n1, double n2, Mode form = RECT);
		~Vector();
		double xval() const {return x;}
		double yval() const {return y;}
		double magval() const {return mag;}
		double angval() const {return ang;}
		void polar_mode();
		void rect_mode();
	// operator overloading
		Vector operator+(const Vector & b) const;
		Vector operator-(const Vector & b) const;
		Vector operator-() const;
		Vector operator*(double n) const;
	// friends
		friend Vector operator * (double n, const Vector & a);
		friend std::ostream & operator<<(std::ostream & os, const Vector & v);
	};
}

#endif /* vetc_hpp */

```

Notice that the four functions in Listing 11.13 that report component values are defined in the class declaration. This automatically makes them inline functions. None of them should alter object data, so they are declared using the `const` modifier.

Listing 11.14 shows all the methods and friend functions declared in Listing 11.13. The listing uses the open nature of namespaces to add the method definitions to the `VECTOR` namespace.

```
// Listing 11.14
#include "test.hpp"
#include <cmath>
using std::sqrt;
using std::sin;
using std::cos;
using std::atan;
using std::atan2;
using std::cout;

namespace VECTOR
{
    const double Rad_to_deg = 45.0 / atan(1.0);

	void Vector::set_mag()
	{
		mag = sqrt(x * x + y * y);
	}

	void Vector::set_ang()
	{
		if (x == 0 && y == 0)
			ang = 0.0;
		else
			ang = atan2(y, x);
	}

	void Vector::set_x()
	{
		x = mag * cos(ang);
	}

	void Vector::set_y()
	{
		y = mag * sin(ang);
	}

	Vector::Vector()
	{
		x = y = mag = ang = 0.0;
		mode = RECT;
	}

	Vector::Vector(double n1, double n2, Mode form)
	{
		mode = form;
		if (form == RECT)
		{
			x = n1;
			y = n2;
			set_mag();
			set_ang();
		}
		else if (form == POL)
		{
			mag = n1;
			ang = n2 / Rad_to_deg;
			set_x();
			set_y();
		}
		else
		{
			cout << "Incorrect 3rd argument to Vector() -- ";
			cout << "vecotr set to 0\n";
			x = y = mag = ang = 0.0;
			mode = RECT;
		}
	}

	void Vector::reset(double n1, double n2, Mode form)
	{
		mode = form;
		if (form == RECT)
		{
			x = n1;
			y = n2;
			set_mag();
			set_ang();
		}
		else if (form == POL)
		{
			mag = n1;
			ang = n2 / Rad_to_deg;
			set_x();
			set_y();
		}
		else
		{
			cout << "Incorrect 3rd argument to Vector() -- ";
			cout << "vecotr set to 0\n";
			x = y = mag = ang = 0.0;
			mode = RECT;
		}
	}

	Vector::~Vector()
	{
	}

	void Vector::polar_mode()
	{
		mode = POL;
	}

	void Vector::rect_mode()
	{
		mode = RECT;
	}

	Vector Vector::operator+(const Vector & b) const
	{
		return Vector(x + b.x, y + b.y);
	}

	Vector Vector::operator-(const Vector & b) const
	{
		return Vector(x - b.x, y - b.y);
	}

	Vector Vector::operator-() const
	{
		return Vector(-x, -y);
	}

	Vector Vector::operator*(double n) const
	{
		return Vector(x * n, y * n);
	}

	Vector operator*(double n, const Vector & a)
	{
		return a * n;
	}

	std::ostream & operator<<(std::ostream & os, const Vector & v)
	{
		if (v.mode == Vector::RECT)
			os << "(x, y) = (" << v.x << ", " << v.y << ")";
		else if (v.mode == Vector::POL)
		{
			os << "(m, a) = (" << v.mag << v.ang * Rad_to_deg << ")";
		}
		else
			os << "Vector object mode is invalid";
		return os;
	}

}


```

Features:

* **Has two representation for a vector at the same time**
* Puts the whole class in a namespace `VECTOR`
* Uses `enum` to create two constants (`RECT` and `POL`)
* Public portion appear first and last
* `set` series functions are all `const`

Note the `reset()` method isn't needed. It can be replaced with constructor like:

```C++
shove = Vector(100, 300);
```

But this will create and assign a temporary object, which is not so effiecient.

We'll look at some of the features in more detail.

### Using a State Member

The `Vector` class uses a _state member_ called `mode` to control which form the constructor, the `reset()` method, and the overloaded `operator<<()` function use with the enumerations `RECT` and `POL`.

The identifier has class scope. The fully qualified name is `VECTOR::Vector::POL`.

Note that the constructor delivers a warning if something other than `RECT` or `POL` is specified. Now it may seem rather difficult to sneak something other than `RECT` or `POL` to the constructor because the third argument is type `VECTOR::Vector::Mode`. A call such as the folling won't compile because an integer like `2` can't implicitly be converted to an `enum` type:

```
Vector rector(20.0, 30.0, 2);	// type mismatch - 2 not an enum type
```

Next, the `operator<<()` function uses the mode to determine how values are displayed:

```C++
std::ostream & operator<<(std::ostream & os, const Vector & v)
{
	if (v.mode == Vector::RECT)
		os << "(x,y) = " << v.x << ", " << v.y << ")";
	else if (v.mode == Vector::POL)
	{
		os << "(m,a) = (" << v.mag << ", "
		   << v.ang * Rad_to_deg << ")";
	}
	else
		os << "Vector object mode is invalid";
	return os;
}
```

Because `operator<<()` is a friend function and **not part of the class scope**, i has to use `Vector::RECT` instead of just `RECT`. 
> **Multiple Representations and Classes**
> Quantities that have different, but equivalent, representations are common. First, you can store multiple representations in one object. Second, **you can writed the class functions so that assigning values for one representation automatically assigns values fo the other representation.**

### Overloading Operators for the `Vector` Class

Adding two vectors is very simple. So **you might be tempted to use this code**:

```C++
Vector Vector::operator+(const Vector & b) const
{
	Vector sum;
	sum.x = x + b.x;
	sum.y = y + b.y;
	return sum;
}
```

First note **we can access private members in b because it's in the same class**.

This would be fine if the object stores only the x and y components. But this version fails to set the polar values. You could fix this by adding more code:

```C++
Vector Vector::operator+(const Vector & b) const
{
	Vector sum;
	sum.x = x + b.x;
	sum.y = y + b.y;
	sum.set_mag();
	sum.set_mag();
	return sum;
}
```

But **it is much simpler and more reliable to let a constructor do the work**:

```C++
Vector Vector::operator+(const Vector & b) const
{
	return Vector(x + b.x, y + b.y);	// return the constructed Vector
}
```

This way, you guaranteed that the new `Vector` object is created according to the **standard rules you lay down in the constructor**.

> **Tip**
> **If a method needs to compute a new class object, you should see if you can sue a class constructor to do the work. Not only does that save you trouble, it ensures that the new object is constructed in the proper fashion.**

#### Mutiplication

As with overloaded addition, the code lets a constructor create the correct `Vector` object from the new x and y components:

```C++
Vector Vector::operator*(double n) const
{
	return Vector(n * x, n * y);
}
```

And as in the `Time` example, you can use an inline friend function to handle `double` times `Vector`:

```C++
Vector operator*(double n, const Vector & a)
{
	return a * n;
}
```


#### More Refinement: Overloading an Overloaded Operator

You can define both binary and unary versions of the `-` operator because C++ provides both binary and unary versions of that operator.

First, look at the subtraction operator. The definition for overloading subtraction is quite similar to the one for addition:

```C++
Vector operator-(const Vector & b) const;
Vector Vector::operator-(const Vector & b) const 
{
	return Vector(x - b.x, y - b.y);
}
```

Next, consider the unary minus operator, which takes just one operand. Here are the prototype and definition for overloading negation:

```C++
Vector operator-() const;
Vector Vector::operator-() const
{
	return Vector(-x, -y);
}
```

Note that now there are two separate definitions for `operator-()`. That's find because the two definitions have different signatures. You can define both binary and unary versions of the `-` operator because C++ provides both binary and unary versions of that operator to begin with. An operator that has only a binary form, such as division (`/`), can only be overloaded as a binary operator.

> **Note**
> You can overload the same operator many times as long as each operator function has a **distinct signature** and as long as each operator function has **the same number of operands** as the corresponding built-in C++ operator.

### An Implementation Comment

You have two ways to implement these two representations, but the public interface doesn't depend on this. 

Storing the data means that the object occupies more memory and the code has to be careful to update both datas. But data look-up is faster.

Which is better depends on how often these two representations are used. **You would choose one implementation in one program and the second implementation in another, yet retain the same user interface for both.**

### Taking the `Vector` Class on a Random Walk

Listing 11.15 provides a short program that uses the revised `Vector` class. It simulates the famous Drunkard's Walk problem. The program uses the `result` to keep track of the walker's progress. On each cycle of the inner loop, the program sets the `step` vector to a new direction and adds it to the current `result` vector.

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "vect.hpp"
int main(void)
{
	using namespace std;
	using VECTOR::Vector;
	srand(time(0));
	double direction;
	Vector step;
	Vector result(0.0, 0.0);
	unsigned long steps = 0;
	double target;
	double dstep;
	cout << "Enter target distance (q to quit): ";
	while (cin >> target)
	{
		cout << "Enter step length: ";
		if (!(cin >> dstep))
			break;
		while (result.magval() < target)
		{
			direction = rand() % 360;
			step.reset (dstep, direction, Vector::POL);
			result = result + step;
			steps++;
		}
		cout << "After " << steps << " steps, the subject "
			"has the following location:\n";
		cout << result << endl;
		result.polar_mode();
		cout << " or\n" << result << endl;
		cout << "Average outwatd distance step = "
		<< result.magval() / steps << endl;
		steps = 0;
		result.reset(0.0, 0.0);
		cout << "Enter target distance (q to quit): ";
	}
	cout << "Bye!\n";
	cin.clear();
	while (cin.get() != '\n')
		continue;
	return 0;
}
```


Incidentally, the following statement has the effect of placing `result` in the `RECT` mode, regardless of the initial mode of `result` and `step`:

```C++
result = result + step;
```

The addition operator creates and returns a **new vector that holds the sum of two arguments.** The function creates the vector by using the selected constructor, which creates vectors in `RECT` mode. By default, assignment assigns each member variable individually, so `RECT` is assigned to `result.mode`. If you would prefer some other behavior, such as `result` retaining its original mode, you can override default assignment by **defining an assginment operator for the class**. Chapter 12 shows examples of this.

### Automatic Conversion and Type Casts for Classess

You may define a class sufficiently related to a basic type or to another class that it makes sense to convert from one form to another. In such a case, you can tell C++ how to make such conventions automatically or, perhaps, via a type cast. Too see how that works, you can recast the pounds-to-stone program from Chapter 3 into class form. Listing 11.16 provides the class header.


```C++
// Listing 11.16
#ifndef STONEWT_H_
#define STONEWT_H_
class Stonewt
{
private:
	enum {Lbs_per_stn = 14};		// pounds per stone
	int stone;						// whole stones
	double pds_left;				// fractional pounds
	double pounds;					// entire weight in pounds
public:	
	Stonewt(double lbs);			// constructor for double pounds
	Stonewt(int stn, double lbs);	// constructor for stone, lbs
	Stonewt();						// default constructor
	~Stonewt();						
	void show_lbs() const;			// show weight in pounds format
	void show_stn() const;			// show weight in stone format
};
#endif
```

As mentioned in Chapter 10, `enum` provides a convenient way to define class-specific constants, provided that they are integers. Or you could use the following alternative:

```C++
static const int Lbs_per_stn = 14;
```

Listing 11.17 shows the class methods implementation. Note that each constructor assigns values to all three private members.

```C++
// Listing 11.17
#include <iostream>
using std::cout;
#include "test.hpp"

// construct Stonewt object from double value
Stonewt::Stonewt(double lbs)
{
	stone = int (lbs) / Lbs_per_stn;
	pds_left = int (lbs) % Lbs_per_stn + lbs - int(lbs);
	pounds = lbs;
}

// construct Stonewt object from stone, double values
Stonewt::Stonewt(int stn, double lbs)
{
	stone = stn;
	pds_left = lbs;
	pounds = stn * Lbs_per_stn + lbs;
}

Stonewt::Stonewt()		// default constructor, wt = 0
{
	stone = pounds = pds_left = 0;
}

Stonewt::~Stonewt()		// destructor
{
}

// show weight in stones
void Stonewt::show_stn() const
{
	cout << stone << " stone, " << pds_left << " pounds\n";
}

// show weight in pounds
void Stonewt::show_lbs() const
{
	cout << pounds << " pounds\n";
}
```

Because a `Stonewt` object represents a single weight, it makes sense to provide ways to convert an integer or a floating-point value to a `Stonewt` object. And you have already done so! In C++, any constructor that **takes a single argument** acts as a blueprint for converting a value of that argument type to the class type. Thus the following constructor serves as instructions for converting a type `double` value to a type `Stonewt` value:

```C++
Stonewt(double lbs);	// for double-to-Stonewt conversion
```

That is, you can write code like the following:

```C++
Stonewt myCat;
myCat = 19.6;	// use Stonewt(double) to convert 19.6 to Stonewt
```

The program uses the `Stonewt(double)` constructor to **construct a temporary `Stonewt` object**, using `19.6` as the initialization value. Then **memberwise assignment** copies the contents of the temporary object into `myCat`. This process is termed an `implicit conversion` because it happens automatically, without the need of an explicit type cast.

The following constructor has two arguments, so it cannot be used to convert types:

```C++
Stonewt(int stn, double lbs); 	// not a conversion function
```

However, it would act as a guide to `int` conversion if it provides a default value for the second parameter:

```C++
Stonewt(int stn, double lbs = 0);	// int-to-Stonewt conversion
```

The automatic aspect is not always desirable because it can lead to unexpected converions. So C++ added a new keyword, `explicit`, to turn off the automatic aspect. That is, you can declare the constructor this way:

```C++
explicit Stonewt(double lbs);	// no implicit conversions allowed
```

This turns of implicit conversion such as the preceding example but still allows explicit conversions---that is, conversion using explicit type casts:

```C++
Stonewt myCat;				
myCat = 19.6;				// not valid
myCat = Stonewt(19.6);		// ok, an explicit conversion
myCat = (Stonewt) 19.6;		// ok, old form for explicit typecast
```

> **Note**
> A C++ constructor that contains one argument defines a type conversion from the argument type to the class type. If the contructor is qualified with the keyword `explicit`, the contructor is used for explicit conversions only; otherwise, it is also used for implicit conversions.

When does the compiler use the `Stone(double)` function? If the keyword `explicit` is used in the declaration, `Stone(double)` is used only for an explicit type cast; otherwise, it is also used for the following implicit conversions:

* When you initialize a `Stonewt` object to a type `double` value
* When you assign a type `double` value to a `Stonewt` object
* When you pass a type `double` value to a function that expects a `Stonewt` argument
* When a function that's declared to return a `Stone` value tries to return a `double` value
* When any of the preceding situations use a bulit-in type that can unambiguouly by converted to type `double`

Let's look at the last point in more detail. The argument-matching process provided by function prototyping lets the `Stone(double)` constructor acts as conversions for other numerical types. That is, both of the following statements work by first converting `int` to `double` and then using the `Stonewt(double)` constructor:

```C++
Stonewt Jumbo(7000);	// uses Stonewt(double), converting int to double
Jumbo = 7300;			// uses Stonewt(double), converting int to doulbe
```

However, this two-step conversion process works only if there is an unambiguous choice. That is, if the class also defined a `Stonewt(long)` constructor, the compiler would reject these statements, probably pointing out that an `int` can be converted to either a `long` or a `double`, so the call is ambiguous.

Listing 11.18 uses the class constructors to initialize some `Stonewt` objects and to handle type conversions. 

```C++
// Listing 11.18
#include <iostream>
#include "test.hpp"
using std::cout;
void display(const Stonewt & st, int n);
int main(void)
{
	Stonewt incognito = 275;
	Stonewt wolfe(285.7);
	Stonewt taft(21, 8);

	cout << "The celebrity weighed ";
	incognito.show_stn();
	cout << "The detective weighed ";
	wolfe.show_stn();
	cout << "The President weighed ";
	taft.show_lbs();
	incognito = 276.8;
	taft = 325;
	cout << "After dinner, the celebrity weighed ";
	incognito.show_stn();
	cout << "After dinner, the President weighed ";
	taft.show_lbs();
	display(taft, 2);
	cout << "The wrestler weighed even more.\n";
	display(422, 2);
	cout << "No stone left unearned\n";
	return 0;
}

void display(const Stonewt & st, int n)
{
	for (int i = 0; i < n; i++)
	{
		cout << "Wow! ";
		st.show_stn();
	}
}
```

Note that when a constructor has a single argument, you can use the following form when initializing a class object:

```C++
Stonewt incognito = 275;
```

This is equivalent to the other two forms shown earlier:

```C++
Stonewt incognito(275);
Stonewt incognito = Stonewt(275);
```

Note the following two assignments from Listing 11.18:

```C++
incognito = 276.8;
taft = 325;
```

Because it uses the constructor, this assignment **also sets the `stone` and `pds_left` members of the class.** And the second assignment converts a type `int` value to type `double` and then uses `Stone(double)` to set all three member values in the process.

Finally, note the following function call:

```C++
display(422, 2);
```

The prototype for `display()` indicates that its first argument should be a `Stonewt` object. Confronted with an `int` argument, the compiler looks for a `Stonewt(int)` constructor to convert the `int` to the desired `Stonewt` type. Failing to find that constructor, the compiler looks for a constructor with some other built-in type to which an `int` can be converted. So the compiler converts `int` to `double` and then uses `Stonewt(double)` to convert the result to a `Stonewt` object.

### Conversion Functions

We've introduce how to convert a number to a `Stonewt` object. However, it is also possible for us to do the reverse like this:

```C++
Stonewt wolfe(285.7);
double host = wolfe;
```

We do this not by using construtors. Constructors only provide for **converting another type to the class type**. To do the reverse, we have to use a special form of a C++ **operator** function called a _conversion function_.

Conversion functions are user-defined type casts, and you can use them you would use a type cast. For example, if you define a `Stonewt`-to-`double` conversion function, you can use the following conversions:

```C++
Stonewt wolfe(285.7);
double host = double (wolfe);
double thinker = (double) wolfe;

Stonewtwells(20, 3);
double star = wells; // implicit use of conversion function
```

The compiler, noting that the different types, **looks to see if you've defined a conversion function that matches this description.**

To convert type `typeName`, you use a conversion function in this form:

```C++
operator typename();
```

Note the following points:

* The conversion function **must be a class method. (like constructors)** 
* The conversion function **must not specify a return type. (like constructors)**
* The conversion function **must have no arguments (like member unary operators)**

For example, a function to convert to type `double` would have this prototype:

```C++
operator double();
```

The `typename` part tells the conversion the type to which to convert, so no return type is needed. The fact that the function is a class method means it has to be invoked by a particular class object, and tells the function which value to convert. Thus, the function doesn't need argument.

To add functions that convert `stone_wt` objects to type `int` and to type `double`, then, requires adding the following prototypes to the class declaration:

```
operator int();
operator double();
```

Listing 11.19 shows the modified class declaration.

```C++
// Listing 11.19

#ifndef TEST_H_
#define TEST_H_

class Stonewt
{
private:
	enum {Lbs_per_stn = 14};
	int stone;
	double pds_left;
	double pounds;
public:
	Stonewt(double lbs);
	Stonewt(int stn, double lbs);
	Stonewt();
	~Stonewt();
	void show_lbs() const;
	void show_stn() const;
// conversion functions
	operator int() const;
	operator double() const;
};

#endif
```

Listing 11.20 shows Listing 11.18 modified to include the definitions for these two conversion functions. Note that each function **do return the desired type, even though there is no declared return type**.

```C++
// Listing 11.17
#include <iostream>
using std::cout;
#include "test.hpp"

// construct Stonewt object from double value
Stonewt::Stonewt(double lbs)
{
	stone = int (lbs) / Lbs_per_stn;
	pds_left = int (lbs) % Lbs_per_stn + lbs - int(lbs);
	pounds = lbs;
}

// construct Stonewt object from stone, double values
Stonewt::Stonewt(int stn, double lbs)
{
	stone = stn;
	pds_left = lbs;
	pounds = stn * Lbs_per_stn + lbs;
}

Stonewt::Stonewt()		// default constructor, wt = 0
{
	stone = pounds = pds_left = 0;
}

Stonewt::~Stonewt()		// destructor
{
}

// show weight in stones
void Stonewt::show_stn() const
{
	cout << stone << " stone, " << pds_left << " pounds\n";
}

// show weight in pounds
void Stonewt::show_lbs() const
{
	cout << pounds << " pounds\n";
}


// conversion functions
Stonewt::operator int() const
{
	return int (pounds + 0.5);
}

Stonewt::operator double() const
{
	return pounds;
}
```

Listing 11.21 tests the new conversion functions. 

```
#include <iostream>
#include "test.hpp"

int main(void)
{
	using std::cout;
	Stonewt poppins(9, 2.8);
	double p_wt = poppins;
	cout << "Convert to double => ";
	cout << "Poppins: " << p_wt << " pounds.\n";
	cout << "Convert to int => ";
	cout << "Poppins: " << int (poppins) << " pounds.\n";
	return 0;
}
```

#### Applying Type Conversions Automatically

Listing 11.21 uses `int(poppins)` with `cout`. Suppose that, instead, it omitted the explicit type cast:

```
cout << "Poppins: " << poppins << " pounds.\n";
```

Would the program use an implicit conversion, as in the following statement?

```
double p_wt = poppins;
```

The answer is no. In the `p_wt` example, the context indicates that `poppins` should be converted to type `double`. But in the `cout` example, nothing indicates whether the conversion should be to `int` or to `double` Facing this lack of information, the compiler would complain that you were using an ambiguous conversion.

Interestingly, if the class defined **only** the `double` conversion function, the compiler would accept the statement.

You can have a similar situation with assignment. With the currrent class declarations, the compiler rejects the following statement as being ambiguous:

```
long gone = poppins;	// ambiguous
```


That's because in C++, you can assign both `int` and `double` values to a `long` variable.

When the class defines two or more conversions, you can still use an explicit type cast to indicate which conversion function to use. You can use either of these type cast notations:

```
long gone = (double) poppins;	// use double conversion
long gone = int (poppins);		// use int conversion
```

The moral is that often it's best to use explicit conversions and exclude the possibility of implicit conversions. In C++98, the keyword `explicit` doesn't work with conversions functions, but C++ removes that limitation. So with C++11, you can declare a conversion operator as explicit:

```C++
class Stonewt
{
...
// conversion functions
	explicit operator int() const;
	explicit operator double () const;
};
```

With these declarations in place, you would use a type cast to invoke the operators.

Another approach is to replace a conversion function with a regular nonconversion function like:

```C++
int Stonewt::Stone_to_Int() {return int (pounds + 0.5); }
```

In summary, C++ provides the following type conversions for classes:

* **A class constructor** that has but **a single argument** serves as an instruction for converting a value of **the argument type to the class type**. Using `explicit` in the constructor declaration eliminates implicit conversions.

* A special **class member operator function** called a _conversion function_ serves as an instruction for converting **a class object to some other type**. The conversion functionis a **class member**, has **no declared return type**, has **no arguments**, and is called `operator typeName()`, where `typeName` is the type to which the object is to be converted.

### Conversions and Friends

You can use either a member function or a friend function to overload addition, **but not both**:

```C++
// #1
Stonewt Stonewt::operator+(const Stonewt & st) const
{
	return sum(pounds + st.pounds);
} 
```

Or

```C++
// #2
Stonewt operator+(const Stonewt & st1, const Stonewt & st2)
{
	return sum(st1.pounds + st2.pounds);
}
```

Suppose we have defined `Stonewt(double)` constructor, given `st` a Stonewt object, `do` a double value, consider the following two cases:

```C++
st + do; // case 1
do + st; // case 2
```

Case 1 will translate into:

```C++
st.operator+(do);
```

or

```C++
operator+(st, do);
```

Both implementations of addition will lets you do case 1. 

By the way, **having an `operator double()` would create confusion** bacause that would create another option interpretation.

Now considering case 2. Member function doesn't work in this case, because only a class object can invoke a member function. **And conversion takes place for member function arguments, not for member function invokers**.

The lesson here is that **defining addition as a friend makes it easier for a program to accomadate automatic type conversion**. **The reason is that both operands become function arguments, so function prototyping comes into play for both operands**.

#### Choices in Implementing Addition

Given that you want to add `double` to `Stonewt`, you have two choices.

First, as mentioned, is to define the following as a friend function and have the `Stonewt(double)` constructor handle conversions:

â€‹```C++
friend Stonewt operator+(const Stonewt &, const Stonewt &);
```

The second choice is to further overload the addition operator with functions that explicitly use one type `double` argument:

```C++
Stonewt operator+(double x) const;
friend Stonewt operator+(double x, const Stone & s);
```

Each has advantages. The first is more simple, but there will be added overhead in time and memory to invoke the conversion constructor, thus slower. The second makes for a longer program and more work on your part, but it runs a bit faster. Depending on the intensity of use of this addition, you can choose either of them.

## Program Exercises

<< opeator overloading often needs a state member.

Arithmatic operator overloading often return by value rather than by reference.

Enumerators for state is often place in public portion

Functions in class declaration:

* Regular members
* Regular friends
* Constructors
* Destructor
* Operator function: member/friend
* Conversion functions
* I/O

Note: all method(other that friend) implementation header needs ::.

Don't use `friend` keyword in implementation file.
