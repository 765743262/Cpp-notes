# Classes and Dynamic Memory Allocation

Contents

* Using dynamic memory allocation for class members
* Implicit and explicit copy constructors
* Implicit and explicit overloaded assginment operators
* What you must do if you use `new` in a constructor
* Using `static` class members
* Using placement `new` with objects
* Using pointers to objects
* Implementing a queue abstract data type (ADT)

## Dynamic Memory and Classes

### A Review Example and Static Class Members

This is an example of some errors, and **a new storage class: the static class member**.

Listing 12.1

```C++
class StringBad
{
private:
	char * str;
	int len;
	static int num_strings;
public:
	StringBad(const char * s);
	StringBad();
	~StringBad();

	friend std::ostream & operator<<(std::ostream & os, const StringBad & st);

};
```

Listing 12.2

```C++
int StringBad::num_strings = 0;

StringBad::StringBad(const char * s)
{
	len = std::strlen(s);
	str = new char[len + 1];
	std::strcpy(str, s);
	num_strings++;
	cout << num_strings << ": \"" << str
		 << "\" object created\n";
}

StringBad::StringBad()
{
	len = 4;
	str = new char[4];
	std::strcpy(str, "C++");
	num_strings++;
	cout << num_strings << ": \"" << str
		 << "\" default object created\n";
}

StringBad::~StringBad()
{
	cout << "\"" << str << "\" object deleted, ";
	--num_strings;
	cout << num_strings << " left\n";
	delete [] str;
}

std::ostream & operator<<(std::ostream & os, const StringBad & st)
{
	os << st.str;
	return os;
}
```

**Program Notes:**

* It uses a pointer-to-char instead of a `char` array to represent a name. It uses `new` in the constructor. Note this way, **the string is not a member in the object**.

* The definition declares the `num_string` member as belonging to the _static storage class_. A _static class member_ has a special property: **A program creates only one copy of a static class variable, regardless of the number of objects created.

  For example, if you created 10 `StringBad` objects, there would be 10 `str` members, but just 1 shared num_strings member.

* Notice the following statment in the implementation file:

  ```C++
  int StringBad::num_strings = 0;
  ```

  This statement initializes the static `num_strings` member to `0`. Note that **you cannot initialize a static member variable inside the class declaration.** That's because the declaration is a description of how memory if to be allocated but it doesn't **allocate memory**.

  In the case of a static class member, you initilize the static member independently, **with a separate statement outside the declaration**. This initilization **goes into the methods file**. That's because the class declaration is in a header file, and a program may include a header file in several other file.

  Note the initialization statement uses **the scope operator**, but it doesn't use the static keyword.

> ##### Note

> A **static data member** is declared **in the class declaration** and is **initialized in the file containing the class methods**. The **scope operator** is used in the initialization. However, **if the static member is a `const` integral type of an enumeration type**, it can be initialized in the class declaration itself.

Let's look at the constructor:

```C++
StringBad::StringBad(const char * s)
{
	len = std::strlen(s);
	str = new char[len + 1];
	std::strcpy(str, s);
	num_strings++;
	cout << num_strings << ": \"" << str
		 << "\" object created\n";
}
```

It does the following thing:

* Initialize the `len` member.
* Uses `new` to allocate sufficient space to hold the string
* Copy the string into that memory.
* Increment `num_strings`

Note: it's necessary to copy the string rather than just copy the address. Otherwise **the two object may share the same string**, which may cause problems.

The destructor contains the example's most important addtion to the handling of classes:

```C++
StringBad::~StringBad()
{
	cout << "\"" << str << "\" object deleted, ";
	--num_strings;
	cout << num_strings << " left\n";
	delete [] str;
}
```

Deleting an object frees the memory occupied by the object **itself**, but it does not automatically free memory pointed by pointer members.

> ##### Warning

> Whenever you use `new` in a constructor to allocate memory, you should use `delete` in the destructor to free that memory. If you use `new []`, you should use `delete []`.

Listing 12.3

```C++
void callme1(StringBad &);
void callme2(StringBad);

int main(void)
{
	using std::endl;
	{
		cout << "Starting an inner block.\n";
		StringBad headline1("Celery Stalks at Midnight");
		StringBad headline2("Lettuce Prey");
		StringBad sports("Spanish Leaves Bowl for Dollars");
		cout << "headline1: " << headline1 << endl;
		cout << "headline2: " << headline2 << endl;
		cout << "sports: " << sports << endl;
		callme1(headline1);
		cout << "headline1: " << headline1 << endl;
		callme2(headline2);
		cout << "headline2: " << headline2 << endl;
		cout << "Initialize one object to another:\n";
		StringBad sailor = sports;
		cout << "sailor: " << sailor << endl;
		cout << "Assign one object to another:\n";
		StringBad knot;
		knot = headline1;
		cout << "knot: " << knot << endl;
		cout << "Exiting the block.\n";
	}	


    return 0;
}

void callme1(StringBad & rsb)
{
	cout << "String passed by reference:\n";
	cout << "	\"" << rsb << "\"\n";
}

void callme2(StringBad sb)
{
	cout << "String passed by value:\n";
	cout << "	\n" << sb << "\"\n";
}
```

Several problems occrurs:

* Passing `headline2` as a argument by value causes the default copy constructor to be called, as well as the destructor.

* The function messed up the original string

* `sailor` is altered somehow

* At the end of the output the counter go negative.

### Special Member Functions

These problems stems from _special member functions_. These are member functions that are defined **automatically. C++ automatically provides the following member functions:

* A default constructor if you define no constructors
* A default destructor if you don't define one
* A copy constructor is you don't define one
* An assignment operator if you don't define one 
* An address operator if you don't define one.

#### Default Constructors

* C++ provides you with a _defaulted_ default constructor if you failed to provide **any** constructors at all.

 It's needed because creating an object **always** invokes a constructor.

* If you want to create objects that aren't initialized explicitly, you then have to define a default constructor explicitly.

* A construcotr can be a default constructor if **all** its arguments have default values.

* However, you can have **only one** default constructor. You can't do this:

  ```C++
  Klunk() { klunk_ct = 0;}
  Klunk(int n = 0) { klunk_ct = n; }
  ```

#### Copy Constructors

A copy constructor is used to copy an object to a newly created object (initialization).

When a object is created, it needs a constructor. If you provides the same type object as the argument, it invokes the copy constructor.

##### When an Copy Constructor Is Used:

* Regular initialization:

  ```C++
  StringBad ditto(motto);
  StringBad metoo = motto;
  StringBad also = StringBad(motto);
  StringBad * pStringBad = new StringBad(motto);
  ```

  Depending on implementation, the middle two (which involve `=`) may use a copy constructor directly to create `metoo` and `also`, or they may use a copy constructor to generate a temporary objects, and then assigned that object to `metoo` and `also`.

  Both cases involve a copy constructor.

* Passing function argument by value
* Returning by value
* Generating a temporary object.

##### What a Default Copy Constructor Does

The default copy constructor performs a member-by-member copy of the **nonstatic** members (_memberwise copying_, or _shallow copying_). Each member is copied by value.

If a member is itself a class object, the **copy constructor for that class is used to copy one member object to another**. Static members are unaffected.

### Back to StringBad: Where the Copy Constructor Goes Wrong

1. The problem that two more objects destroyed than constructed is because the program does create two additional objects, **using the default copy constructor**. That's when passing `headline2` to `callme2()` and initialize `sailor` to `sports`

  The solution is to provide an explicit copy constructor that does update the count

  > Tip:

  > If your class has a **static data member** whose value changes when new objects are created, you should provide an explicit copy constructor that handles that accounting>

2. This weirdness is more subtle and dangerous.

  The `headline2` is messed up after the function call;

  The `sailor` altered somehow;

  The cause is that implicit copy constructor copies by value. In both cases, pointer member in two objects points to the same string. Then the destructor is called twice, performing `delete` on the same memory twice.

  This behavior is undefined. One possibility is the original string be messed up.

#### Fixing the problem by Defining an Explicit Copy Constructor.

The cure for the problems in the class design is to make a _deep copy_.

That is, rather than just copy the address, the copy constructor should duplicate the string and assign the address of the duplicate to the `str` member.

That way, each member gets **its own string rather than referring to another object's string.** Hers's how you can code the `String` copy cosntructor:

```C++
StringBad::StringBad(const StringBad & st)
{
	num_strings++;
	len = st.len;
	str = new char[len+1];
	std::strcpy(str, st.str);
	cout << num_strings << ": \n"" << str
		 << "\" object created\n";
}
```

What makes defining the copy constructor necessary is the fact that **some class members are `new`-initialized pointers to data rather than the data themselves.

> ##### Caution

> If a class contains members that are pointers initialized by `new`, you should define a copy constructor that copies the pointed-to data instead of copying the pointers themselves. This is termed `deep copying`.

### More `StringBad` Problems: Assignment Operators

C++ allows class object assignment. It does so by **automatically overloading an assginment operator for a class**. This operator has the following prototype:

Class_name & Class_name::operator=(const Class Class_name &);

#### When an Assignment Operator Is Used and What It Does

An overloaded assignment operator is used when you assign one object to another **existing** object:

```C++
StringBad headline1("Celery Stalks at Midnight");

StringBad knot;
knot = headline1;
```

**An assignment operator is not necessarily used when initializing an object:

```C++
StringBad metoo = knot;
```	

Since `metoo` is newly created, the copy constructor is used. But implementation have the option of handling this statement in two steps: using the copy constructor to create a temporary object and then using assignment to copy the values to the new object.

That is, **initialization always invokes a copy constructor, and forms using the = operator may also invoke an assignment operator.

Like a copy constructor, an implicit implementation of an assignment operator performs a member-to-member copy.

#### Where `StringBad` Assignment Goes Wrong

Once again the problem is memberwise copying.

#### Fixing Assignment

The solution is to provide your own assignment operator. The implementation is similar to that of the copy constructor, but there are some differences:

* Because the target object exists befor assignment and already refer to previously allocated data, the function **should use `delete []` to free former obligations

* The function should protect against assigning an object to itself.

* The function returns a reference to the invoking object. This allow the following code:

  ```C++
  S0 = S1 = S2;
  ```

A sample implementation:

```C++
StringBad & StringBad::operator=(const StringBad & st)
{
	if (this == &st)
		return *this;
	delete [] str;
	len = st.len;
	str = new char [len + 1];
	std::strcpy(str, st.str);
	return *this
}
```

The code checks for self-assignment by using `this`. Only a member operator function can use this. And **assignment operator is one of the operators that can be overloaded only by a class member function**.

## The New, Improved `String` Class

We will add the following methods:

```C++
int length () const {return len;}
friend bool operator<(const String & st1, const String & st2);
friend bool operator>(const String & st1, const String & st2);
friend bool operator==(const String & st1, const String & st2);
friend operator>>(istream & is, String & st);
char & operator[](int i);
const char & operator[](int i) const;
static int HowMany();
```

### The Revised Default Constructor

The new default constructor:

```C++
String::String()
{
	len = 0;
	str = new char [1];
	str[0] = '\0';
}
```

The reason we use `str = new char[1]` instead of `str = new char` is the first form is compatible with the class destructor and the second is not.

Or you can use `str = 0` instead. Null pointer is compatible with `delete`.

C++11 provides new keyword `nullptr` to denote null pointers.

### Comparison Members

Three of the methods in the `String` class perform comparisons. The simplest way to implement those is to use the standard `strcmp()` function. Then the function definition:

```C++
bool operator<(const String & st1, const String & st2)
{
	if (std::strcmp(st1.str, st2.str) < 0)
		return true;
	else
		return false;
}
```

You can simplify further:

```C++
bool operator<(const String & st1, const String & st2)
{
	return(strcmp(st1.str, st2.str) < 0);
}
```

Making the functions friends **facilitates comparisons between `String` objects and regular C strings. For example, the following code:

```C++
if ("love" == answer)
```

gets translated to+

```C++
if (operator==("love", answer))
```

then the compiler uses one of the constructors to convert the code to:

```C++
if (operator==(String("love"), answer));
```

### Accessing Characters by Using Bracket Notation

In C++ the two brackets symbols constitute a single operator, **the bracket operator. You can overload this operator by using a method `operator[]()`.

Here's a simple implementation:

```C++
char & String::operator[](int i)
{
	return str[i];
}
```

Declaring the return type as `char &` allows you to assign values to a particular elements. This seems to violate private access, but because `operator[]()` is a class method, this is allowed.

Suppose you have a constant object:

```C++
const String answer("futile");
```

Then, if the only available definition is the one you've just seen, the following code is labelled an error:

```C++
answer[1];
```

C++ distinguish between `const` and non-`const` function signature when overloading. So providing the following code would allow you to use the bracket notation:

```C++
const char & String::operator[](int i) const
{
	return str[i];
}
```

### Static Class Member Functions

The keyword `static` should appear in the class declaration but **not in the function definition if the latter is separate**. This has two important consequences.

* First, a static member function doesn't have to be invoked by an object. If the static member function is declared in the public section, it can be invoked **using the class name the the scope-resolution operator.
  
  For example, given the following prototype/definition in the class declaration:

  ```C++
  static int HowMany(){return num_strings;} 
  ```

  It could be invoked like this:

  ```C++
  int count = String::HowMany();

* The second consequence is because a static member is not associated with a particular object, the only data members it can use are the static data members.
  
  A static member function can be used to set a **classwide flag** that controls how some aspect of the class interface behaves.

### Further Assignment Operator Overloading

The class methods already allows you to do the following:

```C++
String name;
char temp[40];
cin.getline(temp, 40);
name = temp;
```

This is okey, but not a satisfactory solution. To see why, let's review the how the final statement works:

1. The program uses the `String(const char *)` constructor to construct a temporary `String` object containing a copy of that string.

2. The program uses the `String & String::operator=(const String & ) function to copy information from the temporary object to the `name` object.

3. The program calls the ~String() destructor to delete the temporary object.

The simplest way to make the process more efficient is to overload the assignment operator so that it works directly with ordinary strings:

```C++
String & String::operator=(const char *)
{
	delete [] str;
	len = std::strlen(s);
	str = new char [len + 1];
	std::strcpy(str, s);
	return *this;
}
```

As usual, you must **deallocate memory formerly mangaged by `str` and allocate enough memory for the new string.

Listing 12.4

```C++
#ifndef string1_hpp
#define string1_hpp

#include <iostream>

using namespace std;
class String
{
private:
    char * str;
    int len;
    static int num_strings;
    static const int CINLIM = 80;
public:
    // constructors and other methods
    String(const char * s);
    String();
    String(const String &); // copy constructor
    ~String();
    int length() const {return len;}
    // overloaded operator methods
    String & operator=(const String &);
    String & operator=(const char *);
    char & operator[] (int i);
    const char & operator[] (int i) const;
    // overloaded operator friends
    friend bool operator<(const String & st1, const String & st2);
    friend bool operator>(const String & st1, const String & st2);
    friend bool operator==(const String & st1, const String & st2);
    friend ostream & operator<<(ostream & os, const String & st);
    friend istream & operator>>(istream & is, String & st);
    // static function
    static int HowMany();
};
#endif /* string1_hpp */
```

Listing 12.5

```C++

#include "string1.hpp"
#include <iostream>

using std::cin;
using std::cout;

int String::num_strings = 0;

int String::HowMany()
{
	return num_strings;
}

String::String(const char * s)
{
	len = std::strlen(s);
	str = new char[len + 1];
	std::strcpy(str, s);
	num_strings++;
}

String::String()
{
	len = 4;
	str = new char[1];
	str[0] = '\0';
	num_strings++;
}

String::String(const String & st)
{
	num_strings++;
	len = st.len;
	str = new char[len + 1];
	std::strcpy(str, st.str);
}

String::~String()
{
	--num_strings;
	delete [] str;
}

String & String::operator=(const String & st)
{
	if (this == &st)
		return * this;
	delete [] str;
	len = st.len;
	str = new char[len + 1];
	std::strcpy(str, st.str);
	return *this;
}

String & String::operator=(const char * st)
{
	delete [] str;
	len = std::strlen(st);
	str = new char[len + 1];
	std::strcpy(str, st);
	return *this;
}

char & String::operator[](int i)
{
	return str[i];
}

const char & String::operator[](int i) const
{
	return str[i];
}

bool operator<(const String & st1, const String & st2)
{
	return (std::strcmp(st1.str, st2.str) < 0);
}

bool operator>(const String & st1, const String & st2)
{
	return (std::strcmp(st1.str, st2.str) > 0);
}

bool operator==(const String & st1, const String & st2)
{
	return (std::strcmp(st1.str, st2.str) == 0);
} 

std::ostream & operator<<(std::ostream & os, const String & st)
{
	os << st.str;
	return os;
}

std::istream & operator>>(std::istream & is, String & st)
{
	char temp[String::CINLIM];
	is.get(temp, String::CINLIM);
	if (is)
		st = temp;
	while (is && is.get() != '\n')
		continue;
	return is;
}
```

Listing 12.6

```C++
//
//  main.cpp
//  12L4
//
//  Created by lin on 07/09/2017.
//  Copyright Â© 2017 lin. All rights reserved.
//

#include <iostream>
#include "string1.hpp"

const int ArSize = 10;
const int MaxLen = 5;
int main(int argc, const char * argv[]) {
    // insert code here...
  	
  	using std::cout;
  	using std::cin;
  	using std::endl;
  	String name;
  	cout << "Hi, what's your name?\n>> ";
  	cin >> name;

  	cout << name << ", please enter up to " << ArSize
  		 << " short sayings <empty line to quit>:\n";
  	String sayings[ArSize];
  	char temp[MaxLen];
  	int i;
  	for (i = 0; i < ArSize; i++)
  	{
  		cout << i + 1 << ": ";
  		cin.get(temp, MaxLen);
  		while (cin && cin.get() != '\n')
  			continue; 
  		if (!cin || temp[0] == '\0')
  			break;
  		else
  			sayings[i] = temp;
  	}

  	int total = i;

  	if (total > 0)
  	{
  		cout << "Here are your sayings:\n";
  		for (i = 0; i < total; i++)
  		{
  			cout << sayings[i][0] << ": " << sayings[i] << endl;
  		}

  		int shortest = 0;
  		int first = 0;
  		for (i = 1; i < total; i++)
  		{
  			if (sayings[i].length() < sayings[shortest].length())
  				shortest = i;
  			if (sayings[i] < sayings[first])
  				first = i;
  		}

  		cout << "Shortest saying: \n" << sayings[shortest] << endl;
  		cout << "First alphabetically:\n" << sayings[first] << endl;
  		cout << "This program used " << String::HowMany()
  			 << " String objects. Bye.\n";
  	}

  	else
  		cout << "No input! Bye.\n";
    return 0;
}
```

Be careful to check for self-assignment in assignment overloading.

## Things to Remember When Using `new` in Constructors

By now you've noticed that you must take special care when using `new` to initialize pointer members of an object. In particular, you should do the following:

* If you use `new` to initialize a pointer member in a constructor, you should use `delete` in the destructor

* The uses of `new` and `delete` should be compatible. You should pair `new` with `delete` and `new []` with `delete []`.

* If there are mutiple constructors, **all should use the `new` the same way. That is, either all with brackets or all without brackets. That's because there's only one destructor, so all constructors have to be compativble with that destructor. However, it is permissible to initialize a pointer with `new` in one constructor and **with the null pointer` in another constructor**.

* You should define a copy constructor that initializes one object to another by doing **deep copying**. Typically, the constructor should emulate the following example:

 ```C++
 String::String(const String & st)
 {
  	num_strings++;
  	len = st.len;
  	str = new char [len + 1];
  	std::strcpy(str, st.str);
 }
 ```

* You should define an assignment operator that copies one object to another by doing deep copying. Typically, the method should follow the following example:

```C++
String & String::operator=(const String & st)
{
	if (this = &st)
		return *this;
	delete [] str;
	len = st.len;
	str = new char [len + 1];
	std::strcpy(str, st.str);
	return *this;
}
```

 In particular, the method should check for self-assignment; it should free memory formerly pointed to by the member pointer; it should copy the data. **Then it should return a reference to the invoking object.

> ##### NULL or 0 or nullptr?

> Historically, the null pointer can be represented by `0` or `NULL`. In C++ tradition, however, has favored a simple `0` instead of the equivalent `NULL`. And as mentioned earlier, C++11 offers the `nullptr` as a better alternative.

### Don'ts and Dos

The following excerpt contains two examples of what not to do and one example of a good constructor:

```C++
String::String()
{
	str = "default string"; // oops, no new[]
	len = std::strlen(str);
}

String::String(const char * s)
{
	len = std::strlen(s);
	str = new char;			// oops, no []
	std::strcpy(str, s);	// oops, no room
}

String::String(const String & st)
{
	len = st.len;
	str = new char[len + 1];
	std::strcpy(str, st.str);
}
```

The first constructor fails to use `new` to initialize `str`. However the destructor, when called for a default object, applies `delete` to `str`. Any of the following would be okay:

```C++
String::String()
{
	len = 0;
	str = new char[1];
	str[0] = '\0';
}

String::String()
{
	len = 0;
	str = 0;
}

String::String()
{
	static const char * s = "C++";  // initilized just once
	len = std::strlen(s);
	str = new char [len + 1];
	std::strcpy(str, s);
}
```

### Memberwise Copying for Classes with Class Members

Suppose you use the `String` class, or, the standard `string` class as a type for class members:

```C++
class Magzine
{
private:
	String title;
	string publisher;
...
};
```

The **default** memberwise copying and assignment behavior does have some smarts: If you copy or assign one `Magzine` object to another, memberwise copying uses the copy constructor and assignment operators defined for the member types. 

However, if the `Magzine` class needs a copy constructor and assignment operator for some other class member, **you need to call those functions explicitly**.

## Observation About Returning Objeccts

### Returning a Reference to a `const` Object

The usual reason for using a `const` reference is efficiency.

If a function returns an object that is passed to it, you can increase the efficiency of the method by having it return a reference.

Three points:

* Returning an object invokes the copy constructor, whereas returning  reference doesn't.
* The reference should be to **an object that exists when the calling function is executing**.
* If the passed argument reference is `const`, the return type has to be `const`

### Returning a Reference to a Non-`const` Object

Two common examples:

* Overloading the assignment operator.
* Overloading the `<<` operator for use with `cout`.

The first is done for reasons of efficiency, and the second for reasons of necessity.

In the first case, returning either a `String` object of a reference would be okey, but the second is more efficient.

In the second case, the return type has to be `ostream &` and not just `ostream` because **the `ostream` class does not have a public copy constructor**.

### Returning an Object

If the object being returned is local to the calling function then it must be returned as an object.

Typically, arithmatic operators fall into this categary.

There is an added expense of calling the copy constructor, but that is unavoidable.

### Returning a `const` Object

The preceding definition allows you to use the following:

```C++
force1 + force2 = net;
cout << (force1 + force2 = net).magval() << endl;
```

The code is possible because the copy constructor constructs a temporary object to represent the return value. After executing the preceding code, **the program discards the temporary object**.

You can declare the return type as a `const` object to avoid so.

In summary, if a method of function returns a **local object, it must return an object, not a reference**. If a method or function returns an object of a class for which there is no public copy constructor, it must return a reference. Finally, some methods and functions can return either an object or a reference. In this example, the reference is preferred for reasons of efficiency.

## Using Pointers to Objects

The following code uses pointers instead of index to find the shortest and alphabetically first sayings. Also, it gives a favorate saying:

```C++

String * shortest = &sayings[0];
String * first = &sayings[0];
for (i = 1; i < total; i++)
{
	if (sayings[i].length() < shortest->length())
		shortest = &sayings[i];
	if (sayings[i] < *first)
		first = &sayings[i];
}
cout << "Shortest saying: \n" << * shortest << endl;
cout << "First saying: \n" << *first<< endl;
srand(time(0));
int choice = rand() % total;
String * favorate = new String(sayings[choice]);
cout << "My favorate saying:\n" << *favorate << endl;
delete favorate;
```

> ##### Object Initialization with `new`

> In general, if `Class_name` is a class and if `value` is of type `Type_name`, the statement:

```C++
Class_name * pclass = new Class_name(value);
```

invokes this constructor:

```C++
Class_name (Type_name);
Class_name (const Type_name &);
```

An initialization in the following form invokes the default constructor:

```C++
Class_name * ptr = new Class_name;
```

### Looking Again at `new` and `delete`

Consider the following code+

```C++
String * favorate = new String(sayings[choice]);
```

First, the `new` allocates space not for the string to be stored but for the object itself. Also it doesn't allocate space for static member.

Second, creating the object, it calls the constructor, which allocates space for storing the string and assigns the string's address to `str`.

And the two calls of `delete` do the similar thing.

Again, destrucotrs are called in following situations:

* Automatic object's destructor is called when the program exits the block
* Static object (**external, static, static external, or from a namespace), its destructor is called when the program terminates.
* If an object is created by `new`, its destructor is called only when you explicitly use `delete` on that object.

### Pointers and Object Summary

* You declare a pointer to an object by using the usual notation:

```C++
String * glamour;
```

* You initialize a pointer to an existing object:

```C++
String * first = &sayings[0];
```

* You can initialize a pointer by useing new:

```C++
String * favorate = new String(sayings[choice])''
```

* Using `new` with a class invokes the approriate class constructor to **initialize the newly created object:

```C++
// invokes default constructor
String * gleep = new String;

// invokes the String(const char *) constructor
String * glop = new String("my my my");

// invokes the String(const String &) constructor
String * favorate = new String(sayings[choice]);

* You can **use the `->` operator to access a class method via a pointer:

```C++
if (sayings[i].length() < shortest->length())
```

* You apply the dereferencing operator(*) to a pointer to an object to obtain an object:

```C++
if (sayings[i] < * first)
	first = &sayings[i];
```

### Looking Again at Placement `new`

Recall that placement `new` allows you to specify the memory location used to allocate memory.

Listing 12.8 illustrate some problem of using placement `new` with class objects.

Listing 12.8

```C++
#include <iostream>
#include <string>
// necessary to include 
#include <new>

using namespace std;
const int BUF = 512;

class JustTesting
{
private:
	string words;
	int number;
public:
	JustTesting(const string & s = "Just Testing", int n = 0)
	{words = s; number = n; cout << words << " constructored\n";}
	~JustTesting() { cout << words << " destroyed\n";}
	void Show() const { cout << words << ", " << number << endl;}
};

int main(void)
{
	char * buffer = new char[BUF];

	JustTesting *pc1, *pc2;
	pc1 = new (buffer) JustTesting;
	pc2 = new JustTesting("Heap1", 20);

	cout << "Memory block addressses:\n" << "buffer: "
		 << (void * ) buffer << "	heap: " << pc2 << endl;
	cout << "Memory contents:\n";
	cout << pc1 << ": ";
	pc1->Show();
	cout << pc2 << ": ";
	pc2->Show();

	JustTesting *pc3, *pc4;
	pc3 = new (buffer) JustTesting("Bad idea", 6);
	pc4 = new JustTesting("Heap2", 10);

	cout << "Memory contents:\n";
	cout << pc3 << ": ";
	pc3->Show();
	cout << pc4 << ": ";
	pc4->Show();

	delete pc2;
	delete pc4;
	delete [] buffer;
	cout << "Done\n";
	return 0;
}
```

First, placement `new` simply overwrites the same location used for the first object with a new object.

This means that the `destructor` is not called for the first object.

To use two different locations, you provide two different addresses within the buffer, making sure that the two locations doesn't overlap. You can, for example, use this:

```C++
pc1 = new (buffer) JustTesting;
pc3 = new (buffer + sizeof (JustTesting)) JustTesting("Better Idea", 6);

The second lesson to be learned is that if you use a placement `new` to store objects, you need to **arrange for their destructors to be called. You can't do this:

```C++
delete pc1;
delete pc3;
```

where pc1, pc3 are assigned with placement `new`. The reason is that `delete` work in conjunction with `new` but with placement `new`.

Note that the program does free the buffer:

```C++
delete [] buffer;
```

But it doesn't call the destructors for any objects that placement `new` constructs in the block.

The solution is that **you must call the destructor explicitly for any object created by placement `new`**. This is one of the rare cases that require an explicit call of destructor. You can use those pointers:

```C++
pc3->~JustTesting();
pc1->~JustTesting();
```


There are still two things to note: first, **the objects constructed by placement `new` should be destroyed in order opposite that in which they are contructed**. The reason is a later object might have dependencies on an earlier object. The second is that the buffer used to hold the objects should be freed only after all the contained objects are destroyed.

## Reviewing Techniques

### Overloading the `<<` Operator

You define a **friend** operator function that has the following form:

```C++
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ...;
	return os;
}
```

Note:

* It must be a friend.
* You should use `os` instead of `cout`.
* You should return the reference.

### Conversion Functions

To convert a **single** value to a class type, you create a **class constructor** that has the following form:

```C++
c_name(type_name value);
```

To convert a class type to some other type, you create a **class member function** that has the following prototype:

```C++
operator type_name();
```

Note:

* This prototype has no return type.
* This is a operator.

You can use the keyword `explicit` with constructors.

### Classes Whose Constructors Use `new`

You need to take several precautions when designing classes that use the `new` operator to allocate memory pointed by a class member+

* Any class the points to memory allocated by `new` should have the `delete` operator applied to it in the destructor.

* If a destructor frees memory by appying `delete` to a pointer member, then **every constructor for that class should initialize that pointer, either by using `new` or by setting the pointer to the null pointer**.

* Constructors should settle on using either `new` or `new []`, but not a mixture of both. The destructor should use the corresponding form `delete` or `delete []`.

* You should define a copy constructor that allocates new memory (deep copying) rather that copying a pointer to existing memory. The constructor should normally have the following prototype:

Class_name(const Class_name &);

* You should define **a class member function** that overloads the assignment operator that has a function definition with the following form:

```C++
c_name & cname::operator=(const c_name & cn)
{
	if (this == & cn)
		return *this;
	delete [] c_pointer;
	c_pointer = new type_name[size];
	// then copy data

	return *this;
}
```

Note:

* The assignment operator function should checks for self-assignment by using `this`.
* The assignment should apply `delete` to original pointer.

## A Queue Simulation

### A Queue Class

#### The Queue Class Interface

```C++
class Queue
{
private:
	struct Node { Item item; Node * next;};
	enum {Q_SIZE = 10};
	Node * front;
	Node * rear;
	int items;
	const int qsize;
	...
public:
	...
};
```

The queue is implemented with linked list, with `front` and `rear` pointers point to the front and rear node. 

The declaration uses the C++ ability to nest a structure or class declaration inside a class. Here `Node` has _class scope_. That is you can use `Node` to declare class members and as a type name in the class methods. **You don't have to worry about this declaration of `Node` conflicting with some global declaration.

> ##### Nested Structures and Classes

> A structure, a class, or an **enumeration** declared within a class declaration is said to be _nested_ in the class. It has class scope. **Such a declaration doesn't create a data object. It specifies a type that can be used internally within the class. If the declaration is made in the public section, then the declared type can also be used out of the class, through use of the scope-resolution operator. For example, if `Node` were declared in the public section of the `Queue` class, you could declare variables of type `Queue::Node` outside the `Queue` class.

#### The class Methods

You are supposed to set the members `front`, `rear`, `items` and `qsize`.

But there is a problem. `qsize` is a `const`, so **it can be _initialized to_ a value, but it can't be _assigned_ a value**.

Conceptually, calling a constructor creates an object **before the code within the brackets is executed.** Thus, calling the constructor first causes the program to allocate space for the four variable, then uses **ordinary assignment** to place values into the allocated space. This is not allowed for `const`.

C++ provides speicial syntax for this: a _member initializer list_. This is a comma-separated list of initializers preceded by a colon placed after the closing parenthesis of the argument list.

If a data member is named `mdata` and if it's to be initialized to the value `val`, the initializer has the form `mdata(val)`. Using this notation, you can write the `Queue` constructor like this:

```C++
Queue::Queue(int qs) : qsize(qs)
{
	front = rear = NULL;
	items = 0;
}  
```

In general, the initial value can be constants and arguments from the constructor's argument list. The techique is not **limited to initializing constants. You can also do the following:

```C++
Queue::Queue(int qs) : qsize(qs), front(NULL), rear(NULL), items(0)
{
}
```

**Only constructors can use this initializer-list syntax.**

You have to use it for class members that are `const` or `reference`:


```C++
class Agency(..);
class Agent
{
private:
	Agency & belong;
	...
};
Agent::Agent(Agency & a) : belong(a) {...}
```

That's because references and `const` data can be initialized only when created.

> ##### The Member Initializer List Syntax

> If `mem1`, `mem2` and `mem3` are class data members, a class constructor can use the following syntax to initialize the data members:

```C++
Classy::Classy(int n, int m) : mem1(n), mem2(0), mem3(n*m + 2)
{

}
```

> Note the following+

> * This form can be used **only with constructors**.
> * You must use this form to initialize `const` data and references.

The parenthesized form used in the member initializer list can be used in ordinary initializations:

```C++
int games(162);
double talk(2.71828);
```

> ##### C++11 Member In-Class Initialization

> C++11 allows you to do what would seem to the intuitively obvious thing:

```C++
class Classy
{
	int mem1 = 10;
	const int mem2 = 20;
};
```

>This is equivalent to using a member initialization list in the constructors. But initialization list would override In-Class initialization.

#### Other Class Method?

The constructor doesn't use `new`. But we do need `delete` in the destructor to delete all remaining nodes.

Do we need copy constructors and assignment operators that do deep copying? **Memeberwise copying of a `Queue` object would do the wrong things**. If you're realy going to make copies or assign object, thing would go wrong.

But suppose you don't want to do any of these things, you can't simply ignore those concerns, though. They might generate puzzling results and crashes at some time in the future when you try to use a copy.

**You can define the required methods as dummy private methods**:

```C++
class Queue
{
private:
	Queue(const Queue & q) : qsize(0) {}
	Queue & operator= (const Queue & q) {return *this;};
...
};
```

This has two effects:

* First, it overrides the default method definitions that otherwise would be generated automatically.

* Second, because these methods are private, **they can't be used by the world at large**. The compiler won't allow the following:

```C++
Queue snick(nip);
tuck = nip;
```

This trick is useful when you define a class whose objects really should not be copied, like `cout`.

Another effect is **you can not return or pass objects by value. You have to use a reference**.

### The `Customer` Class

class Customer
{
private:
	long arrive;
	int processtime;
public:
	Customer() { arrive = processtime = 0;}
	void set(long when);
	long when() const {return arrive;}
	int ptime() const {return processtime;}
};

void Customer::set(long when)
{
	processtime = std::rand() % 3 + 1;
	arrive = when;
}



## Chapter Review

When dealing with string with new, you should allocate one more unit for 