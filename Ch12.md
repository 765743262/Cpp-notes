# Chapter 12 Classes and Dynamic Memory Allocation

In this chapter you'll learn about the following:

* Using dynamic memory allocation for class members
* Implicit and explicit copy constructors
* Implicit and explicit overloaded assginment operators
* What you must do if you use `new` in a constructor
* Using `static` class members
* Using placement `new` with objects
* Using pointers to objects
* Implementing a queue abstract data type (ADT)

## Dynamic Memory and Classes

### A Review Example and Static Class Members

This is an example with showing some horrible errors in using dynamic memory allocation with classes. Later, we will present a revised version, the `String` class. We'll use the two classes to give an inside look at how `new`, `delete` and `static` class members operate.



Listing 12.1 shows the class declaration.


```C++
// Listing 12.1
#ifndef TEST_H_
#define TEST_H_
#include <iostream>
class StringBad
{
private:
	char * str;
	int len;
	static int num_strings;
public:
	StringBad(const char * s);
	StringBad();
	~StringBad();

	friend std::ostream & operator<<(std::ostream & os, const StringBad & st);

};
#endif
```

We call the class `StringBad` to remind you that this is an example under development. It uses `new` and `delete` correctly in the constructors and destructor. It doesn't really do bad things, but the design omits doing some additional good things that are necessary but not at all obvious.

The definition declares the `num_strings` member as belonging to the `static` storage class. A **static class member** has a special property: A program creates **only one copy** of a static class variable, regardless of the number of objects created. That is, a static member is shared among all objects of that class. This is convenient for data that should be private to a class but that should have the same value for all class objects.

By the way, Listing 12.1 uses the `num_strings` member as a device to point out potential programming problems.

Take a look at the implementation of the class methods in Listing 12.2. Notice how it handles using a pointer and a static member.

```C++
// Listing 12.2
#include <cstring>
#include "test.hpp"
using std::cout;

// initializing static class member
int StringBad::num_strings = 0;

// class methods
// construct StringBad from C string
StringBad::StringBad(const char * s)
{
	len = std::strlen(s);			// set size
	str = new char[len + 1];		// allot storage
	std::strcpy(str, s);			// initilize pointer
	num_strings++;					// set object cout
	cout << num_strings << ": \"" << str
		 << "\" object created\n";	
}

StringBad::StringBad()				// default constructor
{
	len = 4;
	str = new char[4];
	std::strcpy(str, "C++");
	num_strings++;
	cout << num_strings << ": \"" << str
		 << "\" default object created\n";
}

StringBad::~StringBad()				// necessary destructor
{
	cout << "\"" << str << "\" object deleted, ";
	--num_strings;					// required
	cout << num_strings << " left\n";
	delete [] str;					// required
}

std::ostream & operator<<(std::ostream & os, const StringBad & st)
{
	os << st.str;
	return os;
}
```

**Program Notes:**

Notice the following statement from Listing 12.2:

```C++
int StringBad::num_strings = 0;
```

This statement initializes the static `num_strings` member to `0`. Note that **you cannot initialize a static member variable inside the class declaration.** That's because the declaration is a description of how memory if to be allocated but it doesn't **allocate memory**.

In the case of a static class member, you initilize the static member independently, **with a separate statement outside the class declaration**. This initilization **goes into the methods file**. That's because the class declaration is in a header file, and a program may include a header file in several other file.

Note the initialization statement uses **the scope operator**, but it doesn't use the static keyword.

> **Note**
> A **static data member** is declared **in the class declaration** and is **initialized in the file containing the class methods**. The **scope operator** is used in the initialization. However, **if the static member is a `const` integral type of an enumeration type**, it can be initialized in the class declaration itself.

Now look at the first construtor in Listing 12.2, which initializes a `String` object with a regular C string:

```C++
StringBad::StringBad(const char * s)
{
	len = std::strlen(s);			// set size
	str = new char[len + 1];		// allot storage
	std::strcpy(str, s);			// initialize pointer
	num_strings++;					// set object count
	cout << num_strings << ": \"" << str
		 << "\" object created\n";	// For Your Information
}
```

It does the following thing:

* Sets the `len` member.
* Uses `new` to allocate sufficient space to hold the string
* Copys the string into that memory.
* Increment `num_strings`

To understand this approach, you should realize that the string is not stored in the object. The string is stored separately, in heap memory. It's necessary to copy the string rather than just copy the address. Otherwise **the two object may share the same string**, which may cause problems.

The destructor contains the example's most important addtion to the handling of classes:

```C++
StringBad::~StringBad()		// necessary destructor
{
	cout << "\"" << str << "\" object deleted, ";
	--num_strings;
	cout << num_strings << " left\n";
	delete [] str;
}
```

The `delete` statement is vital. Deleting an object frees the memory occupied by the object **itself**, but it does not automatically free memory pointed by pointer members.

> **Warning**
> Whenever you use `new` in a constructor to allocate memory, you should use `delete` in the destructor to free that memory. If you use `new []`, you should use `delete []`.

Listing 12.3 illustrates illustrates when and how the `StringBad` constructors and destructors work.

```C++
// Listing 12.3
#include <iostream>
#include "test.hpp"
void callme1(StringBad &);
void callme2(StringBad);

int main(void)
{
	using std::endl;
    using std::cout;
	{
		cout << "Starting an inner block.\n";
		StringBad headline1("Celery Stalks at Midnight");
		StringBad headline2("Lettuce Prey");
		StringBad sports("Spanish Leaves Bowl for Dollars");
		cout << "headline1: " << headline1 << endl;
		cout << "headline2: " << headline2 << endl;
		cout << "sports: " << sports << endl;
		callme1(headline1);
		cout << "headline1: " << headline1 << endl;
		callme2(headline2);
		cout << "headline2: " << headline2 << endl;
		cout << "Initialize one object to another:\n";
		StringBad sailor = sports;
		cout << "sailor: " << sailor << endl;
		cout << "Assign one object to another:\n";
		StringBad knot;
		knot = headline1;
		cout << "knot: " << knot << endl;
		cout << "Exiting the block.\n";
	}	


    return 0;
}

void callme1(StringBad & rsb)
{
    using std::cout;
	cout << "String passed by reference:\n";
	cout << "	\"" << rsb << "\"\n";
}

void callme2(StringBad sb)
{
    using std::cout;
	cout << "String passed by value:\n";
	cout << "	\n" << sb << "\"\n";
}

```

Several problems occrurs:

* Passing `headline2` as a argument by value causes the default copy constructor to be called, as well as the destructor. 

* Although passing by value is supposed to protect the original argument from change, The function messed up the original string. Some other strings are also messed up.

* At the end of the output the counter go negative, which indicates something missing.

Actually, the peculiar counting is a clue. A constructor that doesn't increment `num_strings` must be creating two objects. Consider this line:

```C++
StringBad sailor = sports;
```

Remeber, initialization using this form is another syntax for the following:

```C++
StringBad sailor = StringBad(sports);	// constructor using sports
```

Because `sports` is type `StringBad`, a matching constructor could have this prototype:

```C++
StringBad(const StringBad &);
```

And it turns out that the compiler automatically generates this constructor, (called a **copy constructor**) if you initialize one object to another.


### Special Member Functions

The problems with the `StringBad` class stem from _special member functions_. These are member functions that are defined **automatically**. C++ automatically provides the following member functions:

* A default constructor if you define no constructors
* A default destructor if you don't define one
* A copy constructor is you don't define one
* An assignment operator if you don't define one 
* An address operator if you don't define one.

It turns out that the implicit copy constructor and the implicit assignment operator cause the `StringBad` class problems.

C++ provides two more special member functions---the **move constructor** and the **move assignment operator**. Chapter 18 discusses these further.

#### Default Constructors

C++ provides you with a _defaulted_ default constructor if you failed to provide **any** constructors at all. It's needed because creating an object **always** invokes a constructor.

After you define any constructor, C++ doesn't bother to define a defaut constructor. If you want to create objects that aren't initialized explicitly, you then have to define a default constructor explicitly.

A constructor can be a default constructor if **all** its arguments have default values.

However, you can have **only one** default constructor. You can't do this:

```C++
Klunk() { klunk_ct = 0;}
Klunk(int n = 0) { klunk_ct = n; }
```

This will cause the compiler to issue an error message.

#### Copy Constructors

A copy constructor is used to copy an object to a newly created object. That is, it's used during initialization, including passing function arguments by value and **not during ordinary assignment**. A copy constructor for a class normally has this prototype:

```C++
Class_name(const Class_name &);
```

When an object is created, it needs a constructor. If you provides the same type object as the argument, it invokes the copy constructor.

##### When an Copy Constructor Is Used:

The most obvious situation is when you explicitly initialize a new object to an existing object. For example, given that `motto` is a `StringBad` object, the following four defining declarations invoke a copy constructor:

```C++
StringBad ditto(motto);
StringBad metoo = motto;
StringBad also = StringBad(motto);
StringBad * pStringBad = new StringBad(motto);
```

Depending on implementation, the middle two may use a copy constructor directly to create `metoo` and `also`, or they may use a copy constructor to generate a temporary objects whose contents are then assigned that object to `metoo` and `also`.

Less obviously, a compiler uses a copy constructor whenever a program generates copies of an object. In particular, it's used when a function passes an object **by value** or when a function returns an object. Remember, passing by value means creating a copy of the original variable.

A compiler also uses a copy constructor whenever it generates temporary objects.

##### What a Default Copy Constructor Does

The default copy constructor performs a member-by-member copy of the **nonstatic** members (_memberwise copying_, or _shallow copying_). Each member is copied by value.

If a member is itself a class object, the **copy constructor for that class is used to copy one member object to another**. Static members, such as `num_strings` are unaffected because they belong to the class as a whole instead of to individual objects.

### Back to `StringBad`: Where the Copy Constructor Goes Wrong

The problem that two more objects destroyed than constructed is because the program does create two additional objects, **using the default copy constructor**. That's when passing `headline2` to `callme2()` and initializing `sailor` to `sports`

The solution is to provide an explicit copy constructor that does update the count:

```C++
StringBad::StringBad(const String & s)
{
	num_strings++;
	...// important stuff to go here
}
```

> **Tip**:
> If your class has a **static data member** whose value changes when new objects are created, you should provide an explicit copy constructor that handles that accounting.

The second weirdness is more subtle and dangerous. Consider the initialization statement:

```
StringBad sailor = sports;
```

The implicit copy constructor copies by value. This does not copy the string; it copies the pointer to a string. That is, you wind up with two pointers to the same string. This is a problem when the destructor is called: both destructor will be called once, trying to free the same memory twice, which leads to undefined behaviors.

#### Fixing the problem by Defining an Explicit Copy Constructor

The cure for the problems in the class design is to make a _deep copy_. That is, rather than just copy the address of the string, the copy constructor should duplicate the string and assign the address of the duplicate to the `str` member. That way, each object gets **its own string rather than referring to another object's string.** Hers's how you can code the `String` copy cosntructor:

```C++
StringBad::StringBad(const StringBad & st)
{
	num_strings++;				// handle static member update
	len = st.len;				// same length
	str = new char[len+1];		// allot space
	std::strcpy(str, st.str);	// copy string to new location
	cout << num_strings << ": \"" << str
		 << "\" object created\n";	// For Your Information
}
```

What makes defining the copy constructor necessary is the fact that **some class members are `new`-initialized pointers to data rather than the data themselves**.

> **Caution**
> If a class contains members that are pointers initialized by `new`, you should define a copy constructor that copies the pointed-to data instead of copying the pointers themselves. This is termed `deep copying`.

### More `StringBad` Problems: Assignment Operators

Not all problems in Listing 12.3 can be blamed on the default copy constructor; you have to look at the default assignment operator, too. C++ allows class object assignment. It does so by **automatically overloading an assginment operator for a class**. This operator has the following prototype:

```C++
Class_name & Class_name::operator=(const Class Class_name &);
```

For example, here's the prototype for the `StringBad` class:

```C++
StringBad & StringBad::operator=(const StringBad &);
```


#### When an Assignment Operator Is Used and What It Does

An overloaded assignment operator is used when you assign one object to another **existing** object:

```C++
StringBad headline1("Celery Stalks at Midnight");
...
StringBad knot;
knot = headline1;		// assignment operator invoked
```

An assignment operator is **not necessarily used** when initializing an object:

```C++
StringBad metoo = knot;		// use copy constructor, possibly assignment, too
```

Since `metoo` is newly created, the copy constructor is used. But implementation have the option of handling this statement in two steps: using the copy constructor to create a temporary object and then using assignment to copy the values to the new object. That is, initialization always invokes a copy constructor, and forms using the `=` operator may also invoke an assignment operator.

Like a copy constructor, an implicit implementation of an assignment operator performs a member-to-member copy. If a member is itself of some class, the program uses the assignment operator defined for that class to do the copying for that particular member. Static data members are unaffected.

#### Where `StringBad` Assignment Goes Wrong

Listing 12.3 assigns `headline1` to `knot`:

```C++
knot = headline1;
```

Once again the problem is memberwise copying.

#### Fixing Assignment

The solution is to provide your own assignment operator, one that makes a deep copy. The implementation is similar to that of the copy constructor, but there are some differences:

* Because the target object exists befor assignment and already refer to previously allocated data, the function **should use `delete []` to free former obligations**
* The function should protect against assigning an object to itself; 
* The order of the statement should be consider carefully to ensure both self-assignment safety and exception-safety
* The function returns a reference to the invoking object. This allows the following code:

```C++
S0 = S1 = S2;
```

Here's how you could write an assignment operator for the `StringBad` class:

```C++
String & String::operator=(const String & st)
{
	int newlen = st.len;
	auto newst = new char [newlen + 1];
	std::strcpy(newst, st.str);
	delete [] str;
	len = newlen;
	str = newst;
    return *this;
}
```

Note you must copy first, and then `delete` to ensure exception-safety. Happily, making the assignment exception-safe also makes it self-assignment safe.

Note when it is finished, the program returns `*this`.

## The New, Improved `String` Class

Now we can revise the `StringBad` class, renaming it `String`. First, add the copy constructor and the assignment operator just discussed. Next, we can add a few capabilities to the class. In particular, we'll add the following methods:

```C++
int length () const { return len; }
friend bool operator<(const String & st1, const String & st2);
friend bool operator>(const String & st1, const String & st2);
friend bool operator==(const String & st1, const String & st2);
friend operator>>(istream & is, String & st);
char & operator[](int i);
const char & operator[](int i) const;
static int HowMany();
```

In particular, the two `operator[]()` functions provide array-notation access to individual characters in a string. The static method `HowMany()` complements the static class data member `num_strings`. Let's look at some details.

### The Revised Default Constructor

The new default constructor merits notice. It look likes this:

```C++
String::String()
{
	len = 0;
	str = new char [1];
	str[0] = '\0';
}
```

The reason we use `str = new char[1]` instead of `str = new char` is the first form is compatible with the class destructor and the second is not.

Or you can use `str = 0` instead. Null pointer is compatible with `delete`.

C++11 provides a new keyword `nullptr` to denote null pointers:

```C++
str = nullptr;
```

### Comparison Members

Three of the methods in the `String` class perform comparisons. The simplest way to implement those is to use the standard `strcmp()` function. Then the function definition will be like this:

```C++
bool operator<(const String & st1, const String & st2)
{
	if (std::strcmp(st1.str, st2.str) < 0)
		return true;
	else
		return false;
}
```

You can simplify the code further to this:

```C++
bool operator<(const String & st1, const String & st2)
{
	return(strcmp(st1.str, st2.str) < 0);
}
```

Making the functions friends **facilitates comparisons between `String` objects and regular C strings**. For example, suppose `answer` is a `String` object and that you have the following code:

```C++
if ("love" == answer)
```

This gets translated to the following:

```C++
if (operator==("love", answer))
```

The compiler then uses one of the constructors to convert the code, in effect, to this:

```C++
if (operator==(String("love"), answer));
```

### Accessing Characters by Using Bracket Notation

In C++ the two bracket symbols constitute a single operator, **the bracket operator**. You can overload this operator by using a method called `operator[]()`.

Suppose that `opera` is a `String` object. If you use the expression `opera[4]`, C++ looks for a method with this name and signature:

```C++
String::operator[](int i)
```

If it finds a matching prototype, the compiler replaces the expression `opera[4]` with this function call:

```C++
opera.operator[](4)
```

Here's imple implementation:

```C++
char & String::operator[](int i)
{
	return str[i];
}
```

Declaring the return type as `char &` allows you to assign values to a particular elements. This seems to violate private access, but because `operator[]()` is a class method, it is allowed to alter the array contents.

Suppose you have a constant object:

```C++
const String answer("futile");
```

Then, if the only available definition for `operator[]()` is the one you've just seen, the following code is labeled an error:

```C++
cout << answer[1];	// compiler-time error
```

C++ distinguish between `const` and non-`const` function signature when overloading. So providing the following code would allow you to use the bracket notation:

```C++
const char & String::operator[](int i) const
{
	return str[i];
}
```

### Static Class Member Functions

It is possible to declare a member function as being static. The keyword `static` should appear in the class declaration but **not in the function definition if the latter is separate**. This has two important consequences.

First, a static member function doesn't have to be invoked by an object. If the static member function is declared in the public section, it can be invoked **using the class name the the scope-resolution operator**.

For instance, you can give the `String` class a static member function called `HowMany()` with the following prototype/definition in the class definition:

```C++
static int HowMany() { return num_strings; } 
```

It could be invoked like this:

```C++
int count = String::HowMany();
```

The second consequence is that because a static member is not associated with a particular object, **the only data members it can use are the static data members**. For example, the `HowMany()` static method can access the `num_strings` static member, but not `str` or `len`.

Similarly, a static member function can be used to set a classwide flag that controls how some aspect of the class interface behaves.

### Further Assignment Operator Overloading

The class methods already allow you to do the following:

```C++
String name;
char temp[40];
cin.getline(temp, 40);
name = temp;	// use constructor to convert type
```

This is okey, but not a satisfactory solution if you have to do it often. To see why, let's review the how the final statement works:

1. The program uses the `String(const char *)` constructor to construct a temporary `String` object containing a copy of that string.

2. The program uses the `String & String::operator=(const String & )` function to copy information from the temporary object to the `name` object.

3. The program calls the `~String()` destructor to delete the temporary object.

The simplest way to make the process more efficient is to overload the assignment operator so that it works directly with ordinary strings:

```C++
String & String::operator=(const char * s)
{
	int newlen = std::strlen(s);
	char * newstr = new char [newlen + 1];
	std::strcpy(newstr, s);
	len = newlen;
	delete [] str;
	str = newstr;
	return *this;
}
```

Listing 12.4 shows the revised class declaration. In addition to the changes already mentioned, it defines the constant `CINLIM`, which is used in implementing `operator>>()`.

```C++
// Listing 12.4

#ifndef STRING_H_
#define STRING_H_
#include <iostream>

class String
{
private:
	char * str;					// pointer to string
	int len;					// length of stirng
	static int num_strings;		// number of objects
	static const int CINLIM = 80;	// cin input limit
public:
// constructors and other methods
	String(const char * s);		// constructor
	String();					// default constructor
	String(const String &);		// copy constructor
	~String();					// destructor
	int length() const { return len; }
// overloaded operator methods
    String & operator=(const String & s);
	String & operator=(const char *);
	char & operator[](int i);
	const char & operator[](int i) const;
// overloaded operator friends
	friend bool operator<(const String & st1, const String & st2);
	friend bool operator>(const String & st1, const String & st2);
	friend bool operator==(const String & st1, const String & st2);
	friend std::ostream & operator<<(std::ostream & os, const String & st);
	friend std::istream & operator>>(std::istream & is, String & st);
// static function
	static int HowMany();
};

#endif
```

Listing 12.5 presents the revised method definitions.

```C++
// Listing 12.5
#include <cstring>
#include "test.hpp"

// intializing static class member
int String::num_strings = 0;

// static method
int String::HowMany()
{
	return num_strings;
}

// class methods
String::String(const char * s)
{
	len = std::strlen(s);
	str = new char[len + 1];
	std::strcpy(str, s);
	num_strings++;
}

String::String()
{
	len = 4;
	str = new char[1];
	str[0] = '\0';
	num_strings++;
}

String::String(const String & st)
{
	num_strings++;
	len = st.len;
	str = new char [len + 1];
	std::strcpy(str, st.str);
}

String::~String()
{
	--num_strings;
	delete [] str;
}

// overloaded operator methods
// assign a String to a String
String & String::operator=(const String & st)
{
	int newlen = st.len;
	auto newst = new char [newlen + 1];
	std::strcpy(newst, st.str);
	delete [] str;
	len = newlen;
	str = newst;
    return *this;
}

// assign a C string to a String
String & String::operator=(const char * s)
{
	int newlen = std::strlen(s);
	auto newstr = new char [newlen + 1];
	std::strcpy(newstr, s);
	delete [] str;
	len = newlen;
	str = newstr;
	return *this;
}

// read-write char access for non-const String
char & String::operator[](int i)
{
	return str[i];
}

// read-only char access for const String
const char & String::operator[](int i) const
{
	return str[i];
}

// overloaded operator friends
bool operator<(const String & st1, const String & st2)
{
	return (std::strcmp(st1.str, st2.str) < 0);
}

bool operator>(const String & st1, const String & st2)
{
	return st2 < st1;
}

bool operator==(const String & st1, const String & st2)
{
    return (std::strcmp(st1.str, st2.str) == 0);
}

// simple String output
std::ostream & operator<<(std::ostream & os, const String & st)
{
	os << st.str;
	return os;
}

// quick and dirty String input
std::istream & operator>>(std::istream & is, String & st)
{
	char temp[String::CINLIM];
	is.get(temp, String::CINLIM);
	if (is)
		st = temp;
	while (is && is.get() != '\n')
		continue;
	return is;
}
```

Listing 12.6 exercises the `String` class with a short program.

```C++
// Listing 12.6
#include <iostream>
#include "test.hpp"

const int ArSize = 10;
const int MaxLen = 5;
int main() 
{
  	using std::cout;
  	using std::cin;
  	using std::endl;
  	String name;
  	cout << "Hi, what's your name?\n>> ";
  	cin >> name;

  	cout << name << ", please enter up to " << ArSize
  		 << " short sayings <empty line to quit>:\n";
  	String sayings[ArSize];
  	char temp[MaxLen];
  	int i;
  	for (i = 0; i < ArSize; i++)
  	{
  		cout << i + 1 << ": ";
  		cin.get(temp, MaxLen);
  		while (cin && cin.get() != '\n')
  			continue; 
  		if (!cin || temp[0] == '\0')
  			break;
  		else
  			sayings[i] = temp;
  	}

  	int total = i;

  	if (total > 0)
  	{
  		cout << "Here are your sayings:\n";
  		for (i = 0; i < total; i++)
  		{
  			cout << sayings[i][0] << ": " << sayings[i] << endl;
  		}

  		int shortest = 0;
  		int first = 0;
  		for (i = 1; i < total; i++)
  		{
  			if (sayings[i].length() < sayings[shortest].length())
  				shortest = i;
  			if (sayings[i] < sayings[first])
  				first = i;
  		}

  		cout << "Shortest saying: \n" << sayings[shortest] << endl;
  		cout << "First alphabetically:\n" << sayings[first] << endl;
  		cout << "This program used " << String::HowMany()
  			 << " String objects. Bye.\n";
  	}

  	else
  		cout << "No input! Bye.\n";
    return 0;
}
```

Remember that `cin.get(char *, int)` evaluate to `false` upon reading an empty line.

## Things to Remember When Using `new` in Constructors

By now you've noticed that you must take special care when using `new` to initialize pointer members of an object. In particular, you should do the following:

* If you use `new` to initialize a pointer member in a constructor, you should use `delete` in the destructor

* The uses of `new` and `delete` should be compatible. You should pair `new` with `delete` and `new []` with `delete []`.

* If there are mutiple constructors, **all should use the `new` the same way**. That is, either all with brackets or all without brackets. That's because there's only one destructor, so all constructors have to be compativble with that destructor. However, it is permissible to initialize a pointer with `new` in one constructor and **with the null pointer` in another constructor**.

* You should define a copy constructor that initializes one object to another by doing **deep copying**. Typically, the constructor should emulate the following example:

```C++
String::String(const String & st)
{
	num_strings++;				// handle static member update if necessary
	len = st.len;				// same length as copied string
	str = new char [len + 1];	// allot space
	std::strcpy(str, st.str);	// copy string to new location
}
```

* You should define an assignment operator that copies one object to another by doing deep copying. Typically, the method should follow the following example:

```C++
String & String::operator=(const String & st)
{
	int newlen = st.length();
	auto newstr = new char [newlen + 1];
	strcpy(newstr, st.str);
	len = newlen;
	delete [] str;
	str = newstr;
	return *this;
}
```

it should return a reference to the invoking object.

### Don'ts and Dos

The following excerpt contains two examples of what not to do and one example of a good constructor:

```C++
String::String()
{
	str = "default string"; // oops, no new[]
	len = std::strlen(str);
}

String::String(const char * s)
{
	len = std::strlen(s);
	str = new char;			// oops, no []
	std::strcpy(str, s);	// oops, no room
}

String::String(const String & st)
{
	len = st.len;
	str = new char[len + 1];
	std::strcpy(str, st.str);
}
```

The first constructor fails to use `new` to initialize `str`. However the destructor, when called for a default object, applies `delete` to `str`. Any of the following would be okay:

```C++
String::String()
{
	len = 0;
	str = new char[1];
	str[0] = '\0';
}

String::String()
{
	len = 0;
	str = nullptr;
}

String::String()
{
	static const char * s = "C++";  // initilized just once
	len = std::strlen(s);
	str = new char [len + 1];
	std::strcpy(str, s);
}
```

### Memberwise Copying for Classes with Class Members

Suppose you use the `String` class, or, the standard `string` class as a type for class members:

```C++
class Magzine
{
private:
	String title;
	string publisher;
...
};
```

The **default** memberwise copying and assignment behavior does have some smarts: If you copy or assign one `Magzine` object to another, memberwise copying uses the copy constructor and assignment operators defined for the member types. 

However, if the `Magzine` class needs a copy constructor and assignment operator for some other class member, **you need to call those functions explicitly**.

## Observation About Returning Objeccts

When a member function or standalone function returns an object, you have choices. The function could return a reference to an object, a constant reference to an object, an object or a constant object. It's time to review these options.

### Returning a Reference to a `const` Object

The usual reason for using a `const` reference is efficiency, but there are restrictions on when this choice can be used.

If a function returns an object that is passed to it, you can increase the efficiency of the method by having it return a reference.

Three points:

* Returning an object invokes the copy constructor, whereas returning reference doesn't.
* The reference should be to **an object that exists when the calling function is executing**.
* If the passed argument reference is `const`, the return type has to be `const`

### Returning a Reference to a Non-`const` Object

Two common examples:

* Overloading the assignment operator.
* Overloading the `<<` operator for use with `cout`.

The first is done for reasons of efficiency, and the second for reasons of necessity.

In the first case, returning either a `String` object of a reference would be okey, but the second is more efficient.

In the second case, the return type has to be `ostream &` and not just `ostream` because **the `ostream` class does not have a public copy constructor**.

### Returning an Object

If the object being returned is local to the calling function, then it must be returned as an object. Typically, arithmatic operators fall into this categary.

Consider the `Vector::operator+()` method:

```C++
Vector Vector::operator+(const Vector & b) const
{
	return Vector(x + b.x, y + b.y);
}
```

The constructor call `Vector(x + b.x, y + b.y)` creates an object that is accessible to the `operator+()` methods; the implicit call to the copy constructor produced by the return statement, however, creates an object that is accessible to the calling program.

### Returning a `const` Object

The preceding definition of `Vector::operator+()` has a bizarre property. The intended use is this:

```
net = force1 + force2;
```

However, the definition also allows you to use the following:

```C++
force1 + force2 = net;
cout << (force1 + force2 = net).magval() << endl;
if (force1 + force2 = net)		// !!!
{
	...
}
```

The code is possible because the copy constructor constructs a temporary object to represent the return value. After executing the preceding code, **the program discards the temporary object**.

You can declare the return type as a `const` object to avoid so.

In summary, if a method of function returns a **local object, it must return an object, not a reference**. If a method or function returns an object of a class for which there is no public copy constructor, it must return a reference. Finally, some methods and functions can return either an object or a reference. In this example, the reference is preferred for reasons of efficiency.

## Using Pointers to Objects

Listing 12.7 uses pointers instead of index to find the shortest and alphabetically first sayings. Also, it gives a favorate saying. For variet, the program in Listing 12.7 uses a pointer that does keep track of a new object:

```C++
String * favorite = new String(sayings[choice]);
```

This particular syntax means to initialize the new `String` object by using the object `sayings[choice]`. That invokes the copy constructor.

```C++
// Listing 12.7
String * shortest = &sayings[0];
String * first = &sayings[0];
for (i = 1; i < total; i++)
{
	if (sayings[i].length() < shortest->length())
		shortest = &sayings[i];
	if (sayings[i] < *first)
		first = &sayings[i];
}
cout << "Shortest saying: \n" << * shortest << endl;
cout << "First saying: \n" << *first<< endl;
srand(time(0));
int choice = rand() % total;
String * favorate = new String(sayings[choice]);
cout << "My favorate saying:\n" << *favorate << endl;
delete favorate;
```

> **Object Initialization with `new`**
> In general, if `Class_name` is a class and if `value` is of type `Type_name`, the statement:

```C++
Class_name * pclass = new Class_name(value);
```

invokes this constructor:

```C++
Class_name (Type_name);
Class_name (const Type_name &);
```

Also the usual conversions invoked by prototype matching, such as from `int` to `double` takes place as long as there is no ambiguity. An initialization in the following form invokes the default constructor:

```C++
Class_name * ptr = new Class_name;
```

### Looking Again at `new` and `delete`

The code in Listing 12.7 uses `new` to allocate an entire object:

```C++
String * favorate = new String(sayings[choice]);
```

`new` allocates space not for the string to be stored but for the object itself. Also it doesn't allocate space for static member. Creating the object, in turn, calls the constructor, which allocates space for storing the string and assigns the string's address to `str`.

And the two calls of `delete` do the similar thing.

Again, destrucotrs are called in following situations:

* Automatic object's destructor is called when the program exits the block
* Static object (**external, static, static external, or from a namespace**), its destructor is called when the program terminates.
* If an object is created by `new`, its destructor is called only when you explicitly use `delete` on that object.

### Pointers and Object Summary

You declare a pointer to an object by using the usual notation:

```C++
String * glamour;
```

* You can initialize a pointer to an existing object:

```C++
String * first = &sayings[0];
```

* You can initialize a pointer by using `new`:

```C++
String * favorate = new String(sayings[choice])''
```

* Using `new` with a class invokes the approriate class constructor to initialize the newly created object:

```C++
// invokes default constructor
String * gleep = new String;

// invokes the String(const char *) constructor
String * glop = new String("my my my");

// invokes the String(const String &) constructor
String * favorate = new String(sayings[choice]);
```

* You can **use the `->` operator to access a class method** via a pointer:

窶義``C++
if (sayings[i].length() < shortest->length())
```

* You apply the dereferencing operator(`*`) to a pointer to an object to obtain an object:

窶義``C++
if (sayings[i] < * first)
	first = &sayings[i];
```

### Looking Again at Placement `new`

Recall that placement `new` allows you to specify the memory location used to allocate memory.

Listing 12.8 illustrate some problem of using placement `new` with class objects.

Listing 12.8

```C++
// Listing 12.8
#include <iostream>
#include <string>
// necessary to include 
#include <new>

using namespace std;
const int BUF = 512;

class JustTesting
{
private:
	string words;
	int number;
public:
	JustTesting(const string & s = "Just Testing", int n = 0)
	{words = s; number = n; cout << words << " constructored\n";}
	~JustTesting() { cout << words << " destroyed\n";}
	void Show() const { cout << words << ", " << number << endl;}
};

int main(void)
{
	char * buffer = new char[BUF];

	JustTesting *pc1, *pc2;
	pc1 = new (buffer) JustTesting;
	pc2 = new JustTesting("Heap1", 20);

	cout << "Memory block addressses:\n" << "buffer: "
		 << (void * ) buffer << "	heap: " << pc2 << endl;
	cout << "Memory contents:\n";
	cout << pc1 << ": ";
	pc1->Show();
	cout << pc2 << ": ";
	pc2->Show();

	JustTesting *pc3, *pc4;
	pc3 = new (buffer) JustTesting("Bad idea", 6);
	pc4 = new JustTesting("Heap2", 10);

	cout << "Memory contents:\n";
	cout << pc3 << ": ";
	pc3->Show();
	cout << pc4 << ": ";
	pc4->Show();

	delete pc2;
	delete pc4;
	delete [] buffer;
	cout << "Done\n";
	return 0;
}
```

There are a couple problems with placement `new` as used in Listing 12.8. First, placement `new` simply overwrites the same location used for the first object with a new object. Not only is this rude, it means that the `destructor` is not called for the first object.

To use two different locations, you provide two different addresses within the buffer, making sure that the two locations doesn't overlap. You can, for example, use this:

```C++
pc1 = new (buffer) JustTesting;
pc3 = new (buffer + sizeof (JustTesting)) JustTesting("Better Idea", 6);
```

The second lesson to be learned is that if you use a placement `new` to store objects, you need to **arrange for their destructors to be called**. You can't use this:

窶義``C++
delete pc1;
delete pc3;
```

where pc1, pc3 are assigned with placement `new`. The reason is that `delete` work in conjunction with `new` but with placement `new`.

Note that the program does free the buffer:

窶義``C++
delete [] buffer;
```

But it doesn't call the destructors for any objects that placement `new` constructs in the block.

The solution is that **you must call the destructor explicitly for any object created by placement `new`**. This is one of the rare cases that require an explicit call. You can use those pointers:

```C++
pc3->~JustTesting();
pc1->~JustTesting();
```


There are still two things to note: first, **the objects constructed by placement `new` should be destroyed in order opposite that in which they are contructed**. The reason is a later object might have dependencies on an earlier object. The second is that the buffer used to hold the objects should be freed only after all the contained objects are destroyed.

Listing 12.9 fixes Listing 12.8 by managing memory locations used by placement `new` and by adding appropiate uses of `delete` and of explicit destructor calls.

```C++
// Listing 12.9
#include <iostream>
#include <string>
#include <new>
using namespace std;
const int BUF = 512;
class JustTesting
{
private:
	string words;
	int number;
public:
	JustTesting(const string & s = "Just Testing", int n = 0)
	{ words = s; number = n; cout << words << " constructed\n"; }
	~JustTesting() { cout << words << " destroyed\n"; }
	void Show() const { cout << words << ", " << number << endl; }
};

int main(void)
{
	char * buffer = new char [BUF];		// get a block of memory
	JustTesting *pc1, *pc2;

	pc1 = new (buffer) JustTesting;		// place object in buffer
	pc2 = new JustTesting("Heap1", 20);	// place object on heap

	cout << "Memory block addresss:\n" << "buffer "
		 << (void *) buffer << "	heap: " << pc2 << endl;
	cout << "Memory contents:\n";
	cout << pc1 << ": ";
	pc1->Show();
	cout << pc2 << ": ";
	pc2->Show();

	JustTesting *pc3, *pc4;
// fix placement new location
	pc3 = new (buffer + sizeof(JustTesting)) JustTesting("Bad Idea", 6);
	pc4 = new JustTesting("Heap2", 10);

	cout << "Memory contents:\n";
	cout << pc3 << ": ";
	pc3->Show();
	cout << pc4 << ": ";
	pc4->Show();

	delete pc2;
	delete pc4;
// explicitly destroy placement new objects
	pc3->~JustTesting();
	pc1->~JustTesting();
	delete [] buffer;
	cout << "Done\n";
	return 0;
}
```

## Reviewing Techniques

### Overloading the `<<` Operator

To redefine the `<<` operator so that you can use it with `cout` to display an object's contents, you define a **friend** operator function that has the following form:

```C++
ostream & operator<<(ostream & os, const c_name & obj)
{
	os << ...;	// display object contents
	return os;
}
```

Note:

* It must be a friend.
* You should use `os` instead of `cout`.
* You should return a non-`const` reference.

### Conversion Functions

To convert a **single** value to a class type, you create a **class constructor** that has the following prototype:

```C++
c_name(type_name value);
```

To convert a class type to some other type, you create a **class member function** that has the following prototype:

```C++
operator type_name();
```

Although this function has no declared return type, it should return a value of the desired type.

Remeber to use conversion functions with care. You can use the keyword `explicit` with constructors and conversion functions to prevent it from being used for implicit conversions.

### Classes Whose Constructors Use `new`

You need to take several precautions when designing classes that use the `new` operator to allocate memory pointed by a class member:

* Any class the points to memory allocated by `new` should have the `delete` operator applied to it in the destructor.

* If a destructor frees memory by appying `delete` to a pointer member, then **every constructor for that class should initialize that pointer, either by using `new` or by setting the pointer to the null pointer**.

* Constructors should settle on using either `new` or `new []`, but not a mixture of both. The destructor should use the corresponding form `delete` or `delete []`.

* You should define a copy constructor that allocates new memory (deep copying) rather that copying a pointer to existing memory. The constructor should normally have the following prototype:

```
Class_name(const Class_name &);
```

* You should define **a class member function** that overloads the assignment operator that has a function definition with the following form:

```C++
c_name & cname::operator=(const c_name & cn)
{
	auto new_ptr = new typename[size];
	// copy data
	delete [] ptr;
	ptr = new_ptr

	return *this;
}
```

Note you should return `*this`.

## A Queue Simulation

### A Queue Class

#### The Queue Class Interface

```C++
class Queue
{
private:
	struct Node { Item item; Node * next;};
	enum {Q_SIZE = 10};
	Node * front;
	Node * rear;
	int items;
	const int qsize;
	...
public:
	...
};
```

The queue is implemented with linked list, with `front` and `rear` pointers point to the front and rear node. 

The declaration uses the C++ ability to nest a structure or class declaration inside a class. Here `Node` has _class scope_. That is you can use `Node` to declare class members and as a type name in the class methods. You don't have to worry about this declaration of `Node` conflicting with some global declaration.

> ##### Nested Structures and Classes

> A structure, a class, or an **enumeration** declared within a class declaration is said to be _nested_ in the class. It has class scope. Such a declaration doesn't create a data object. It specifies a type that can be used internally within the class. If the declaration is made in the public section, then the declared type can also be used out of the class, through use of the scope-resolution operator. For example, if `Node` were declared in the public section of the `Queue` class, you could declare variables of type `Queue::Node` outside the `Queue` class.

#### The class Methods

You are supposed to set the members `front`, `rear`, `items` and `qsize`.

But there is a problem. `qsize` is a `const`, so **it can be _initialized to_ a value, but it can't be _assigned_ a value**.

Conceptually, calling a constructor creates an object **before the code within the brackets is executed.** Thus, calling the constructor first causes the program to allocate space for the four variable, then uses **ordinary assignment** to place values into the allocated space. This is not allowed for `const`.

C++ provides speicial syntax for this: a _member initializer list_. This is a comma-separated list of initializers preceded by a colon placed after the closing parenthesis of the argument list.

If a data member is named `mdata` and if it's to be initialized to the value `val`, the initializer has the form `mdata(val)`. Using this notation, you can write the `Queue` constructor like this:

```C++
Queue::Queue(int qs) : qsize(qs)
{
	front = rear = NULL;
	items = 0;
}  
```

In general, the initial value can be constants and arguments from the constructor's argument list. The techique is not **limited to initializing constants. You can also do the following**:

```C++
Queue::Queue(int qs) : qsize(qs), front(nullptr), rear(nullptr), items(0)
{
}
```

**Only constructors can use this initializer-list syntax.**

You have to use it for class members that are `const` or `reference`:


```C++
class Agency(..);
class Agent
{
private:
	Agency & belong;
	...
};
Agent::Agent(Agency & a) : belong(a) {...}
```

That's because references and `const` data can be initialized only when created. For simple data members, such as `front` and `items`, it dosen't make much difference whether you use a member initializer list or use assignment in the function body. As you'll see in Chapter 14, however, it's more efficient to use the member initializer list for members that are themselves class objects.

> **The Member Initializer List Syntax**
> If `mem1`, `mem2` and `mem3` are class data members, a class constructor can use the following syntax to initialize the data members:

```C++
Classy::Classy(int n, int m) : mem1(n), mem2(0), mem3(n*m + 2)
{

}
```

> Conceptually, these initilization take place when the object is created and **before** any code within brackets is executed. No the following:

> * This form can be used **only with constructors**.
> * You must (at least, in pre-C++11) use this form to initialize a nonstatic `const` data member.
> * You must use this form to initialize a reference data member.

**Data members are initialized in the order in which they appear in the class declaration**, not in the order in which initializers are listed.

> **Caution**
> You can't use the member initializer list syntax with class methods other than constructors.

The parenthesized form used in the member initializer list can be used in ordinary initializations:

```C++
int games(162);
double talk(2.71828);
```

> **C++11 Member In-Class Initialization**
> C++11 allows you to do what would seem to the intuitively obvious thing:

```C++
class Classy
{
	int mem1 = 10;			// in-class initilization
	const int mem2 = 20;	// in-class initialization
	...
};
```

> This is equivalent to using a member initialization list in the constructors:

```
Classy::Classy() : mem1(10), mem2(2) {...}
```

> But initialization list would override n-class initialization. The members `mem1` and `mem2` get initialized to `10` and `20`, respectively, unless a constructor using a member initialization list is called.

#### Other Class Method?

The constructor doesn't use `new`. But we do need `delete` in the destructor to delete all remaining nodes.

Do we need copy constructors and assignment operators that do deep copying? **Memeberwise copying of a `Queue` object would do the wrong things**. If you're realy going to make copies or assign object, things would go wrong.

But suppose you don't want to do any of these things, you can't simply ignore those concerns, though. They might generate puzzling results and crashes at some time in the future when you try to use a copy.

However, **you can define the required methods as dummy private methods**:

```C++
class Queue
{
private:
	Queue(const Queue & q) : qsize(0) {}
	Queue & operator= (const Queue & q) {return *this;};
...
};
```

This has two effects:

* First, it overrides the default method definitions that otherwise would be generated automatically.

* Second, because these methods are private, **they can't be used by the world at large**. The compiler won't allow the following:

```C++
Queue snick(nip);	// not allowed
tuck = nip;			// not allowed
```

This trick is useful when you define a class whose objects really should not be copied, like `cout`.

Another effect is **you can not return or pass objects by value. You have to use a reference**.

C++11 provides an alternative way to disable a method by using the keyword `delete`; Chapter 18 returns to this topic.

### The `Customer` Class

```C++
class Customer
{
private:
	long arrive;
	int processtime;
public:
	Customer() { arrive = processtime = 0;}
	void set(long when);
	long when() const {return arrive;}
	int ptime() const {return processtime;}
};

void Customer::set(long when)
{
	processtime = std::rand() % 3 + 1;
	arrive = when;
}
```


