# Chapter 15 Friends, Exceptions, and More

In this chapter you'll learn about the following:

* Friend classes
* Friend class methods
* Nested classes
* Throwing exceptions, `try` blocks, and `catch` blocks
* Exception classes
* Runtime type identification (RTTI)
* `dynamic_cast` and `typeid`
* `static_cast`, `const_cast`, and `reinterpret_cast`

## Friends

A class also can be a friend. In that case, any method of the friend class can access private and protected members of the original class. Also you can be more restrictive and designate just particular member functions of a class to be friends to another class. 

A class defines which functions, member functions, or classes are friends; friendship cannot by imposed from the outside.

### Friend Classes

Suppose you must program a simple simulation of a television and a remote control. You decide to define a `Tv` class representing a television and a `Remote` class representing a remote control. Clearly, there should be some sort of relationship between these classes. What is true is that a remote control can modify the state of a television, and this suggests making the `Remote` class a friend to the `Tv` class.

You can represent a televion with a set of members. And you must provide the class with methods for altering the settings, without a remote control. And a remote control should duplicate the controls built in to the television. In addition, a remote control typically provides random access channel selection.

These considerations suggest a definition like that shown in Listing 15.1. The following statement makes `Remote` a friend class:

```C++
friend class Remote;
```

A friend declaration can appear in a public, private, or protected section; the location makes no difference.

```C++
// Listing 15.1
#ifndef TEST_HPP_
#define TEST_HPP_
class Tv
{
public:
	friend class Remote; // Remote can access Tv private parts
	enum {Off, On};
	enum {MinVal, MaxVal = 20};
	enum {Antenna, Cable};
	enum {TV, DVD};

	Tv(int s = Off, int mc = 125)
		: state(s), volume(5), maxchannel(mc),
		  channel(2), mode(Cable), input(TV) {}
	void onoff() { state = (state == On)? Off : On; }
	bool ison() const { return state == On; }
	bool volup();
	bool voldown();
	void chanup();
	void chandown();
	void set_mode() { mode = (mode == Antenna) ? Cable : Antenna; }
	void set_input() { input = (input == TV) ? DVD : TV; }
	void settings() const; // display all settins
private:
	int state;			// on or off
	int volume;			// assumed to be digitized
	int maxchannel;		// maximum number of channels
	int channel;		// current channel setting
	int mode;			// broadcast or cable
	int input;			// TV or DVD
};

class Remote
{
public:
	Remote(int m = Tv::TV) : mode(m) {}
	bool volup(Tv & t) { return t.volup(); }
	bool voldown(Tv & t) { return t.voldown(); }
	void onoff(Tv & t) { t.onoff(); }
	void chanup(Tv & t) { t.chanup(); }
	void chandown(Tv & t) { t.chandown(); }
	void set_chan(Tv & t, int c) { t.channel = c; }
	void set_mode(Tv & t) {t.set_mode(); }
	void set_input(Tv & t) { t.set_input(); }
private:
	int mode;		// controls TV or DVD
};
#endif
```

Note that each `Remote` method other than the constructor takes a reference to a `Tv` object as an argument. This reflects that a remote has to be **aimed at a particular TV**. Listing 15.2 shows the remaining definitions.

```C++
// Listing 15.2
#include <iostream>
#include "test.hpp"

bool Tv::volup()
{
	if (volume < MaxVal)
	{
		volume++;
		return true;
	}
	else
		return false;
}

bool Tv::voldown()
{
	if (volume > MinVal)
	{
		volume--;
		return true;
	}
	else
		return false;
}

void Tv::chanup()
{
	if (channel < maxchannel)
        channel++;
	else
		channel = 1;
}

void Tv::chandown()
{
	if (channel > 1)
		channel--;
	else
		channel = maxchannel;
}

void Tv::settings() const
{
	using std::cout;
	using std::endl;
	cout << "TV is " << (state == Off? "Off" : "On") << endl;
	if (state == On)
	{
		cout << "Volume setting = " << volume << endl;
		cout << "Channel setting = " << channel << endl;
		cout << "Mode = "
			 << (mode == Antenna? "antenna" : "cable") << endl;
		cout << "Input = "
			 << (input == TV ? "TV" : "DVD") << endl;
	}
	
}
```

Listing 15.3 is a short program that tests some of the features of the program so far. The same controller is used to control two separate televisions.

```C++
// Listing 15.3
#include <iostream>
#include "test.hpp"

int main()
{
	using std::cout;
	Tv s42;
    cout << "Initial settings for 42\" TV:\n";
	s42.settings();
	s42.onoff();
	s42.chanup();
	cout << "\nAdjusted settings for 42\" TV:\n";
	s42.settings();

	Remote grey;

	grey.set_chan(s42, 10);
	grey.volup(s42);
	grey.volup(s42);
	cout << "\n42\" settings after using remote:\n";
	s42.settings();

	Tv s58(Tv::On);
	s58.set_mode();
	grey.set_chan(s58, 28);
	cout << "\n58\" settings:\n";
	s58.settings();
	return 0;
}
```

The main point to this exercise is that class friendship is a natural idiom in which to express some relationships. Without some form of friendship, you would either have to make the private parts of the `Tv` class public or else construct some awkward, larger class that encompasses both a television and a remote control. And that solution wouldn't reflect the fact that **a single remote control can be used with several televisions**.

### Friend Member Functions

Looking at the code for the last example, you may notice that most of the `Remote` methods are implemented by using the public interface for the `Tv` class. Indeed, the only `Remote` method that accesses a private `Tv` member directly is `Remote::set_chan()`, so that's the only methods that needs to be a friend. You do have the option of making just selected class members friends to another class rather than making the entire class a friend, but you need to be careful about the order in which you arrange the various declarations and definitions. Let's look at why.

The way to make `Remote::set_chan()` a friend to the `Tv` class is to declare it as a friend in the `Tv` class declaration:

```C++
class Tv
{
	friend void Remote::set_chan(Tv & t, int c);
	...
};
```

However, for the compiler to process this statement, it needs to have already seen the `Remote` definition. This suggests putting the `Remote` definition above the `Tv` definition. But the fact that `Remote` methods mention `Tv` objects means that the `Tv` definition should appear above the `Remote` definition. Part of the way around the circular dependence is to use a _forward declaration_. To do so, you insert the following statement above the `Remote` definition:

```C++
class Tv;	// forward declaration
```

This provides the following arrangement:

```C++
class Tv;
class Remote {...};
class Tv {...};
```

Could you use the following statement instead?

```C++
class Remote;
class Tv {...};
class Remote {...};
```

The answer is no. The reason, as mentioned earlier, is that when the compiler sees that a `Remote` method is declared as a friend in the `TV` class declaration, the compiler needs to have already viewed the declaration of the `Remote` class in general and of the `set_chan()` methods in particular. The forward declaration provides information no more than that the name `Remote` is a class.

Another difficulty remains. In Listing 15.1, the `Remote` declaration contains inline code such as the following:

```C++
void onoff(Tv & t) { t.onoff(); }
```

Because this calls a `Tv` method, the compiler needs to have seen the `Tv` class declaration at this point. But as you've seen, that declaration necessarily follows the `Remote` declaration. The solution to this problem is to restrict `Remote` to method _declarations_ and to place the actual _definitions_ after the `Tv` class. This leads to the following ordering:

```C++
class Tv;			// forward declaration
class Remote {...};	// Tv-using methods as prototypes only
class Tv {...};
// put Remote method definitions here
```

The `Remote` prototypes look like this:

```C++
void onoff(Tv & t);
```

All the compiler needs to know when inspecting this prototype is that `Tv` is a class, and the forward declaration supplies that information. By the time the compiler reaches the actual method definitions, it has already read the `Tv` class declaration. By using the `inline` keyword in the method definitions, you can still make the methods inline methods. Listing 15.4 shows the revised header file.

```C++
#ifndef TEST_HPP_
#define TEST_HPP_


class Tv;	// forward declaration

class Remote
{
public:
	enum State{Off, On};
	enum {MinVal, MaxVal = 20};
	enum {Antenna, Cable};
	enum {TV, DVD};
private:
	int mode;
public:
	Remote(int m = TV) : mode(m) {}
	bool volup(Tv & t);	// prototype only
	bool voldown(Tv & t);
	void onoff(Tv & t);
	void chanup(Tv & t);
	void chandown(Tv & t);
	void set_mode(Tv & t);
	void set_input(Tv & t);
	void set_chan(Tv & t, int c);
};

class Tv
{
public:
	friend void Remote::set_chan(Tv & t, int c);
	enum State{Off, On};
	enum {MinVal, MaxVal = 20};
	enum {Antenna, Cable};
	enum{TV, DVD};

	Tv(int s = Off, int mc = 125) : state(s), volume(5),
		maxchannel(mc), channel(2), mode(Cable), input(TV) {}
	void onoff() {state = (state == On)? Off : On;}
	bool ison() const {return state == On;}
	bool volup();
    bool voldown();
	void chanup();
	void chandown();
	void set_mode() { mode = (mode == Antenna) ? Cable : Antenna; }
	void set_input() {input = (input == TV)? DVD : TV; }
	void settings() const;
private:
	int state;
	int volume;
    int channel;
	int maxchannel;
	int mode;
	int input;
};

// Remote methods as inline functions
inline bool Remote::volup(Tv & t) { return t.volup(); }
inline bool Remote::voldown(Tv & t) { return t.voldown();}
inline void Remote::onoff(Tv & t) { t.onoff(); }
inline void Remote::chanup(Tv & t) { t.chanup(); }
inline void Remote::chandown(Tv & t) { t.chandown(); }
inline void Remote::set_mode(Tv & t) { t.set_mode(); }
inline void Remote::set_input(Tv & t) { t.set_input(); }
inline void Remote::set_chan(Tv & t, int c) { t.channel = c; }

#endif
```

Recall that inline functions have internal linkage so the inline definitions are in the header file.

By the way, making the entire `Remote` class a friend doesn't need a forward declaration because the friend statement itself identifies `Remote` as a class:

```C++
friend class Remote;
```

### Other Friendly Relationships

Let's consdier mutual friendship. For example, an interactive remote control unit might let you enter a response to some question posed on a television program, and the televison might activate a buzzer in your remote control if your response is wrong. This can be accomplished by making the classes friends to each other. One point to keep in mind is that a `Tv` method that uses a `Remote` object can be prototyped _before_ the `Remote` class declaration but must be defined _after_ the declaration so that the compiler will have enough information to compile the method. The setup will look like this:

```C++
class Tv
{
	friend class Remote;
public:
	void buzz(Remote & r);
	...
};

class Remote
{
	friend class Tv;
public:
	void Bool volup(Tv & t) { t.volup(); }
	...
};

inline void Tv::buzz(Remote & r)
{
	...
}
```

Because the `Remote` declaration follows the `Tv` declaration, `Remote::volup()` can be defined in the class declaration. However, the `Tv::buzz()` method has to be defined outside the `Tv` declaration so that the definition can follow the `Remote` declaration.

### Shared Friends

Another use for friends is when a function needs to access private data in two separate classes. Suppose, for example, that you have a `Probe` class that represents some sort of programmable measuring device and an `Analyzer` class that represents some sort of programmable analyzing device. Each has an internal clock, and you would like to be able to synchronize the two clocks. You could use something along the following lines:

```C++
class Analyzer;		// forward declaration
class Probe
{
	friend void sync(Analyzer & a, const Probe & p);	// sync a to p
	friend void sync(Probe & p, const Analyzer & a);	   // sync p to a
};

class Analyzer
{
	friend void sync(Analyzer & a, const Probe & p);	// sync a to p
	friend void sync(Probe & p, const Analyzer & a);	   // sync p to a
	...
};


// define the friend functions
inline void sync(Analyzer & a, const Probe & p)
{
	...
}
inline void sync(Probe & p, cosnt Analyzer & a)
{
	...
}
```

The forward declaration enables the compiler to know that `Analyzer` is a type when it reaches the friend declarations in the `Probe` class declaration.

## Nested Classes

In C++, you can place a class declaration inside another class. The class declared within another class is called a _nested class_. Member functions of the class containing the declaration can create and use objects of the nested class. The outside world can use the nested class only if the declaration is in the public section and if you use the scope-resolution operator.

Nesting classes is not the same as containment. Containment means having a class object as a member of another class. Nesting a class does not create a class member. Instead, it defines a type that is knonw just locally the class that contains the nested class declaration.

The `Queue` class example in Listing 12.10 provides a disguised case of nested classes by nesting a structure definition:

```C++
class Queue
{
private:
// class scope definitions
	// Node is a nested structure definition local to this class
	struct Node {Item item; struct Node * next; };
	...	
};
```

However, this definition doesn't take advantage of class abilities. In particular, it lacks an explicit constructor. Let's remedy that now.

Actually, the `Node` objects are only created in the `Queue::enqueue()` method:

```C++
bool Queue::enqueue(cosnt Item & item)
{
	if (isfull())
		return false;
	Node * add = new Node;
// on failure, new throws std::bad_alloc exception
	add->item = item;
	add->next = nullptr;
	...
}
```

This code explicitly assigns values to the `Node` members after creating a `Node`. This is the sort of work that is more properly done by a constructor.

Knowing now where and how a constructor should be used, you can provide an appropiate constructor definition:

```C++
class Queue
{
// class scope definitions
	// Node is a nested class definition local to this class
	class Node
	{
	public:
		Item item;
		Node * next;
		Node(const Item & i) : item(i), next(nullptr) {}
	};
	...
};
```

Next, you need to rewrite `enqueue()` by using the constructor

```C++
bool Queue::enqueue(const Item & item)
{
	if (isfull())
		return false;
	Node * add = new Node(item);
// on failure, new throws std::bad_alloc exception
	...
}
```

This example defines the contrucotr in the class declaration. Suppose you wanted to define it in a methods file, instead. This is accomplished by using the scope-resolution operator twice:

```C++
Queue::Node::Node(const Item & i) : item(i), next(nullptr) {}
```

### Nested Classes and Access

#### Scope

If a nested class is declared in a private section of a second class, it is known only to that second class.

If the nested class is declared in a protected section of a second class, it is visible to that class but invisible to the outside world. However, in this case, a derived class would know about the nested class and could directly create objects of that type.

If a nested class is declared in a public section of a second class, it is available to the second class, to classes derived from the second class, and, because it’s public, to the outside world. However, because the nested class has class scope, it has to be used with a class qualifier in the outside world. For example, suppose you have this declaration:

```C++
class Team
{
public:
	class Coach { ... };
	...
};
```

Now suppose you have a unemployed coach, one who belongs to no team. To create a `Coach` object outside the `Team` class, you can use this:

```C++
Team::Coach forhire;	// create a Coach object outside the Team class
```

Table 15.1 on page 892 summarizes scope properties for nested classes, structures, and enumerations.

#### Access Control

After a class is in scope, access control comes into play. Declaring the `Node` class in the `Queue` class declaration does **not** grant the `Queue` class any special access privileges to the `Node` class, nor does it grant the `Node` class any special access privileges to the `Queue` class. Thus, a `Queue` class object can access **only** the public members of a `Node` object explicitly.  For that reason, the `Queue` example makes all the members of the `Node` class public. This violates the usual practice of making data members private, but the `Node` class is an internal implementation feature of the `Queue` class and is not visible to the outside world. That’s because the `Node` class is declared in the private section of the Queue class.Thus, although `Queue` methods can access `Node` members directly, a client using the Queue class cannot do so.

### Nesting in a Template

It is possible for a template class to have a nested class. Listing 15.5 shows how this can be accomplished. As is common for class templates, the header file include the class template, along with method function templates.

```C++
// Listing 15.5
#ifndef TEST_HPP_
#define TEST_HPP_

template <class Item>
class QueueTP
{
public:
	QueueTP(int qs = Q_SIZE);
	~QueueTP();
	bool isempty() const { return items == 0; }
	bool isfull() const { return items == qsize; }
	int queuecount() const { return items; }
	bool enqueue(const Item & item);
	bool dequeue(Item & item);
private:
	enum {Q_SIZE = 10};
	// Node is a nested class definition
	class Node
	{
	public:
		Item item;
		Node * next;
		Node(const Item & i) : item(i), next(nullptr) {}
	};
	Node * front;
	Node * rear;
	int items;
	const int qsize;
	QueueTP(const QueueTP & q) : qsize(0) {}
	QueueTP & operator=(const QueueTP & q) { return *this; }
};

// QueueTP methods

template <class Item>
QueueTP<Item>::QueueTP(int qs) : qsize(qs)
{
	front = rear = nullptr;
	items = 0;
}

template <class Item>
QueueTP<Item>::~QueueTP()
{
	Node * temp;
	while (front)
	{
		temp = front;
		front = front->next;
		delete temp;
	}
}

template <class Item>
bool QueueTP<Item>::enqueue(const Item & item)
{
	if (isfull())
		return false;
	Node * add = new Node(item);
    items++;
	if (front)
		rear->next = add;
	else
		front = add;
	rear = add;
	return true;
}

template <class Item>
bool QueueTP<Item>::dequeue(Item & item)
{
	if (isempty())
		return false;
	item = front->item;
	items--;
	Node * temp = front;
	front = front->next;
	delete temp;
	if (!front)
		rear = nullptr;
	return true;
}

#endif
```

One interesting thing about the template Listing 15.5 is that `Node` is defined in terms of the generic type `Item`. Thus, a declaration like the following leads to a `Node` defined to hold type `double` values:

```C++
QueueTp<double> dq;
```

And the following declaration leads to a `Node` defined to hold type `char` values:

```C++
QueueTp<char> cq;
```

These two `Node` classes are defined in two **separate `QueueTp` classes**, so there is no name conflict between the two. That is, one node is type `QueueTp<double>::Node`, and the other is type `QueueTp<char>::Node`.

Listing 15.6 offers a short program for testing the new class

```C++
// Listing 15.6
#include <iostream>
#include <string>
#include "test.hpp"

int main()
{
	using std::string;
	using std::cin;
	using std::cout;

	QueueTP<string> cs(5);
	string temp;

	while (!cs.isfull())
	{
		cout << "Please enter your name. You will be "
			    "served in the order of arrival.\n"
			    "name: ";
		getline(cin, temp);
		cs.enqueue(temp);
	}
	cout << "The queue is full. Processing begins!\n";

	while (!cs.isempty())
	{
		cs.dequeue(temp);
		cout << "Now processing " << temp << "...\n";
	}

	return 0;
}
```

## Exceptions

Programs sometimes encounter runtime problems that prevent them from continuing normally. Before examining exceptions, let's look at some of the more rudimentary options available to prgrammers. As a test case, let's look at a function that calculates the harmonic mean of two numbers. This can be reduced to the following expression:

```
2.0 * x * y / (x + y)
```

Note that if `y` is the negative of `x`, this formula results in division by zero. Many newer compilers handle division by zero by generating a special floating-point value that represents infinity; `cout` displays this value as `Inf`, `inf`, `INF`, or something similar. Other compilers may produce programs that crash when divi- sion by zero occurs. It is best to write code that behaves in the same controlled fashion on all systems.

### Calling `abort()`
### Returning an Error Code
### The Exception Mechanism

A C++ _exception_ is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero. Exceptions provide a way to transfer control from one part of a program to another. Handling an exception has three components:

* Throwing an exception
* Catching an exception with a handler
* Using a `try` block

For example, you can modify `hmean()` in Listing 15.7 to throw an exception instead of call the `abort()` function. A throw statement, in essence, is a jump; that is, it tells a program to jump to statement at another location. The `throw` keyword indicates the throwing of an exception. It's followed by a value, such as a character string or an object, that indicates the nature of the exception.

A program catches an exception with an _exception handler_ at the place in the program where you want to handle the problem. The `catch` keywork indicates the catching of an exception. A handler begins with the keywork `catch`, followed by a type declaration (in parentheses) that indicates the type of exception to which it responds. That, in turn, is followed by a brace-enclosed block of code that indicates the actions to take. The `catch` keywork, along with the exception type, serves as a label that identifies the point in a program to which execution should jump when an exception is thrown. An exception handler is also called a _`catch` block_.

A _`try` block_ identifies a block of code for which particular exceptions will be activated. **It's followed by one or more `catch` blocks.** The `try` block itself is indicated by the keywork `try`, followed by a brace-enclosed block of code indicating the code for which exceptions will be noticed.

The easiest way to see how these three elements fit together is to look at a short example, such as the one in Listing 15.9.

```C++
// Listing 15.9
#include <iostream>
double hmean(double a, double b);

int main()
{
	double x, y, z;
	std::cout << "Enter two numbers: ";
	while (cin >> x >> y)
	{
		try						// start of try block
		{
			z = hmean(x, y);
		}						// end of try block
		catch (const char * s)	// start of catch block
		{
			std::cout << s << std::endl;
			std::cout << "Enter a new pair of numbers: ";
			continue;
		}						// end of handler
		std::cout << "Harmonic mean of " << x << " and " << y
				  << " is " << z << std::endl;
		std::cout << "Enter next set of numbers <q to quit>: ";
	}
	std::cout << "Bye!\n";
	return 0;
}

double hmean(double a, double b)
{
	if (a == -b)
		throw "bad hmean() arguments: a = -b not allowed";
	return 2.0 * a * b / (a + b);
}
```

The `try` block in Listing 15.9 looks like this:

```C++
try						// start of try block
{
	z = hmean(x, y);
}						// end of try block
```

If any statement in this block leads to an exception to be thrown, the `catch` blocks after this block will handle the exception. However, if the program calls `hmean()` somewhere else outside this (**and any other**) try block, it won’t have the opportunity to handle an exception.

Throwing an exception looks like this:

```C++
if (a == -b)
	throw "bad hmean() arguments: a = -b not allowed";
```

In this case, **the throw exception is the string `"bad hmean() arguments: a = -b not alloed"`.** The exception type can be a string, as in this case, or other C++ types. A class type is the usual choice, as later examples in this chapter illustrate.

Executing the `throw` is a bit like executing a return statement in that it terminates function execution. However, instead of returning control to the calling program, a throw causes a program to back up through the sequence of current function calls **until it finds the function that contains the try block**. In this case, the `throw` passes program control back to `main()`. There, the program looks for an exception handler (following the `try` block) that matches the type of exception thrown.

The handler, or `catch` block, looks like this:

```C++
catch (const char * s)	// start of exception handler
{
	std::cout << s << std::endl;
	std::cout << "Enter a new pair of numbers: ";
	continue;
}						// end of handler
```

The keyword `catch` identifies this as a handler, and `const char * s` means that this handler matches a thrown exception that is a string. This declaration of `s` acts much like a function argument definition in that a matching thrown exception is assigned to `s`. Also, if an exception does match this handler, the program executes the code within the braces.

If a program completes executing statements in a `try` block without any exceptions being thrown, it skips the `catch` block or blocks after the try block and **goes to the first statement following the handlers**. So when the sample run of the program in Listing 15.9 processes the values `3` and `6`, program execution goes directly to the output statement and reports the result.

You might wonder what happens if a function throws an exception and there’s **no `try` block or else no matching handler**. By default, the program eventually calls the `abort()` function, but you can modify that behavior.We’ll return to this topic later in this chapter.

### Using Objects as Exceptions

Typically, functions that throw exceptions throw objects. One important advantage of this is that you can use different exception types to distinguish among different functions and situations that produce exceptions. Also an object can carry information with it, and you can use this information to help identify the conditions that caused the exception to be thrown. Also in principle a `catch` block could use that information to decide which course of action to pursue. Here, for example, is one possible design for an exception to be thrown by the `hmean()` function:

```C++
class bad_mean
{
private:
	double v1;
	double v2;
public:
	bad_mean(int a = 0, int b = 0) : v1(a), v2(b) {}
	void mesg();
};

inline void bad_hmean::mesg()
{
	std::cout << "hmean(" << v1 << ", " << v2 << "): "
			  << "invalid arguments: a = -b\n";
}
```

A `bad_hmean` object can be initialized to the values passed to `hmean()`, and the `mesg()` method can be used to report the problem, including the values.The `hmean()` function can use code like this:

```C++
if (a == -b)
	throw bad_hmean(a, b);
```

This calls the `bad_hmeans()` constructor, intializing the object to hold the argument values.

Listing 15.10 and Listing 15.11 add a second exception class, `bad_gmean` and a second function, called `gmean()`, that throws a `bad_gmean` exception. Listing 15.10 is a header file that holds the exception class definitions, and Listing 15.11 is a sample program that uses that header file. Note that the `try` block is followed by two consecutive `catch` blocks:

```C++
try						// start of try block
{
	...
}
catch (bad_hmean & bg)	// start of catch block
{
	...
}
catch (bad_gmean & hg)	
{
	...
}						// end of catch block
```

If, say, `hmean()` throws a `bad_hmean` exception, the first `catch` block catches it. If `gmean()` throws a `bad_gmean` exception, **the exception falls through the first `catch` block and gets caught by the second.**

```C++
// Listing 15.10

#include <iostream>
class bad_hmean
{
private:
	double v1;
	double v2;
public:
	bad_hmean(double a = 0, double b = 0) : v1(a), v2(b) {}
	void mesg();
};

inline void bad_hmean::mesg()
{
	std::cout << "hmean(" << v1 << ", " << v2 << "): "
			  << "invalid arguments: a = -b\n";
}

class bad_gmean
{
public:
	double v1;
	double v2;
	bad_gmean(double a = 0, double b = 0) : v1(a), v2(b) {}
	const char * mesg();
};

inline const char * bad_gmean::mesg()
{
	return "gmean() arguments should be >= 0\n";
}
```

```C++
// Listing 15.11
#include <iostream>
#include <cmath>
#include "test.hpp"

double hmean(double a, double b);
double gmean(double a, double b);

int main()
{
	using std::cout;
	using std::cin;
	using std::endl;

	double x, y, z;

	cout << "Enter two numbers: ";
	while (cin >> x >> y)
	{
		try						// start of try block
		{
			z = hmean(x, y);
			cout << "Harmonic mean of " << x << " and " << y
				 << " is " << z << endl;
			cout << "Geometric mean of " << x << " and " << y
				 << " is " << gmean(x, y) << endl;
			cout << "Enter next set of numbers <q to quit>: ";
		}						// end of try block
		catch (bad_hmean & bg)	// start of catch block
		{
			bg.mesg();
            cout << "Try again.\n";
			continue;
		}
		catch (bad_gmean & hg)
		{
			cout << hg.mesg();
			cout << "Values used: " << hg.v1 << ", "
				 << hg.v2 << endl;
			cout << "Sorry, you don't get to play any more.\n";
			break;
		}						// end of catch block
	}
	cout << "Bye!\n";
	return 0;
}

double hmean(double a, double b)
{
	if (a == -b)
		throw bad_hmean(a, b);
	return 2.0 * a * b / (a + b);
}

double gmean(double a, double b)
{
	if (a < 0 || b < 0)
		throw bad_gmean(a, b);
	return std::sqrt(a * b);
}
```

One point to notice is that the `bad_mean` handler uses a `continue` statement, whereas the `bad_gmean` handler uses a `break` statement. Thus, bad input to `hmean()` leads the program to skip the rest of the loop and start the next loop cycle. But bad input for `gmean()` terminates the loop. This illustrates how a program can determien which exception is thrown (by the exception type) and tailor the response to the exception.

### Exception Specifications Meet C++11

C++11 allows for one special specificaion---the new keywork `noexcept` can be used to indicate a function that does not throw an exception:

```C++
double marm() noexcept;	// marn() doesn't throw an exception
```

### Unwinding the Stack

Suppose a `try` block doesn’t contain a direct call to a function that throws an exception but that it calls a function that calls a function that throws an exception. Execution still jumps from the function in which the exception is thrown to the function that contains the `try` block and handlers. Doing so involves **unwinding the stack**, which we’ll discuss now.

Suppose a function terminates via a thrown exception instead of via a return call. The program frees memory from the stack. But instead of stopping at the first return address on the stack, the program continues freeing the stack until it reaches a return address that resides in a `try` block. Control then passes to the exception handler at the end of the block **rather than to the first statement following the function call in the `try` block**. This process is called _unwinding the stack_. 

One very important feature of the `throw` mechanism is that, just as with function returns, **the class destructors are called for any automatic class objects on the stack**. However, a function return just processes objects put on the stack by that function, whereas the `throw` statement processes objects put on the stack by the entire sequence of function calls between the `try` block and the `throw`. 

Listing 15.12 provides an example of unwinding the stack. The `catch` block has the following code:

```C++
catch (bad_hmean & bg)	// start of catch block
{
	bg.mesg();
	std::cout << "Caught in means()\n";
	throw;		// rethrows the exception
}
```

After the code responds by displaying meassges, it rethrows the exception, which means, in this case, sending the exception on up to `main()`. (In general, a rethrown exception rises to the next `try-catch` combination that catches that particular type of exception. If no handler is found, the program, by default, aborts.) Listing 15.12 uses the same header file as Listing 15.11.

```C++
// Listing 15.12

#include <iostream>
#include <cmath>
#include <string>
#include "test.hpp"

class demo
{
private:
	std::string word;
public:
	demo(const std::string & str)
	{
		word = str;
		std::cout << "demo " << word << " created\n";
	}		
	~demo()
	{
		std::cout << "demo " << word << " destroyed\n";
	}
	void show() const
	{
		std::cout << "demo " << word << " lives!\n";
	}
};

// function prototypes
double hmean(double a, double b);
double gmean(double a, double b);
double means(double a, double b);

int main()
{
	using std::cout;
	using std::cin;
	using std::endl;

	double x, y, z;
	{
		demo d1("found in block in main()");
		cout << "Enter two numbers: ";
		while (cin >> x >> y)
		{
			try
			{
				z = means(x, y);
				cout << "The mean mean of " << x << " and " << y
					 << " is " << z << endl;
				cout << "Enter next pair: ";
			}	// end of try block
			catch (bad_hmean & bg)		// start of catch block
			{
				bg.mesg();
				cout << "Try again.\n";
                continue;
			}
			catch (bad_gmean & hg)
			{
				cout << hg.mesg();
				cout << "Values used: " << hg.v1 << ", "
					 << hg.v2 << endl;
				cout << "Sorry, you don't get to play any more.\n";
				break;
			}							// end of catch block
		}
		d1.show();
	}
	cout << "Bye!\n";
	cin.get();
	cin.get();
	return 0;
}

double hmean(double a, double b)
{
	if (a == -b)
		throw bad_hmean(a, b);
	return 2.0 * a * b / (a + b);
}

double gmean(double a, double b)
{
	if (a < 0 || b < 0)
		throw bad_gmean(a, b);
	return std::sqrt(a * b);
}

double means(double a, double b)
{
	double am, hm, gm;
	demo d2("found in means()");
    am = (a + b) / 2.0;
	try
	{
		hm = hmean(a, b);
		gm = gmean(a, b);
	}
	catch (bad_hmean & bg)
	{
		bg.mesg();
		std::cout << "Caught in means()\n";
		throw;
	}
	d2.show();
	return (am + hm + gm) / 3.0;
}
```

Here's a sample run of the program:

```
demo found in block in main() created Enter two numbers: 6 12
demo found in means() created
demo found in means() lives!
demo found in means() destroyed
The mean mean of 6 and 12 is 8.49509
6 -6
demo found in means() created
hmean(6, -6): invalid arguments: a = -b Caught in means()
demo found in means() destroyed hmean(6, -6): invalid arguments: a = -b Try again.
6 -8
demo found in means() created
demo found in means() destroyed gmean() arguments should be >= 0 Values used: 6, -8
Sorry, you don't get to play any more. demo found in block in main() lives! demo found in block in main() destroyed Bye!
```

The first loop runs without problem. The next input cycle sends the values `6` and `-6` to `means()`, and then `measn()` creates a new `demo` object and relays the values to `hmean()`. The `hmean()` function tehn throws a `bad_hmean` exception, which is caught by the `catch` block in `means()`, as is shown by the output. 

The `throw` statement in this block then terminates `means()` and sends the exception up to `main()`. The fact that `d2.show()` isn't called demonstrate that the execution of `means()` is terminated. But note that the destructor for `d2` is called:

```
demo found in means() destroyed
```

This illustrates an extremely important aspect of exceptions: As the program unwinds the stack to reach where an exception is caught, it frees automatic storage class varialbes on the stack.

Meanwhile, the rethrown exception reaches `main()`, where the appropriate `catch` block catches and handles it:

```
hmean(6, -6): invalid arguments: a = -b
Try again.
```

Now the third input cycle begins, with `6` and `-8` sent on to `means()`. It passes `6` and `-8` to `hmean()`, which processes them without a problem. Then `means()` passes `6` and `-8` to `gmean()`, which throws a `bad_gmean` exception. **Because `means()` doesn't catch `bad_gmean` exceptions, the exception is passed on up to `main()`**, and no further code in `means()` is executed. However, once again, as the program unwinds the stack, it frees local automatic variables, so the destructor for `d2` is called:

```
demo found in means() destroyed
```

Finally, the `bad_gmean` handler in `main()` catches the exception and terminates the loop:

```
gmean() arguments should be >= 0 Values used: 6, -8
Sorry, you don't get to play any more.
```

Then the program terminates normally, displaying a few messages and automatically calling the destructor for `d1`.

### More Exception Features

Although the `throw-catch` mechanism is similar to function arguments and the function return mechanism, there are a few differences. One, which you’ve already encountered, is that a return statement in a function `fun()` transfers execution to the function that called `fun()`, but a `throw` transfers execution all the way up to the first function having a `try-catch` combination that **catches the exception**. For example, in Listing 15.12, when `hmean()` throws an exception, control passes up to `means()`, but when `gmean()` throws an exception, control passes up to `main()`.

Another difference is that the compiler **always** creates a temporary copy when throwing an exception, **even if the exception specifier and `catch` blocks specify a reference.** For instance, consider this code:

```C++
class problem {...};
...
void super() throw (problem)
{
	...
	if (oh_no)
	{
		problem oops;	// construct object
		throw oops;		// throw it
	}
}
...
try
{
	super();
}
catch (problem & p)
{
// statements
}
```


Here, **`p` would refer to a copy of `oops` rather than to `oops`.** That’s a good thing because `oops` no longer exists after `super()` terminates. By the way, it is simpler to combine construction with the `throw`:

```C++
throw problem();	// construct and throw default problem object
```

At this point you might wonder why the code uses a reference if the throw generates a copy. After all, the usual reason for using a reference return value is the efficiency of not having to make a copy. The answer is that references have another important property: A base-class reference can also refer to derived-class objects. Suppose you have a collection of exception types that are related by inheritance. In that case, the exception speicification (deprecated in C++11) need only list a reference to the base type, and that would also match any derived objects thrown.

Suppose you have a class hierarchy of exceptions and you want to **handle the different types separately**. A base-class reference can catch all objects of a family, but a derived-class object can only catch that object and objects of classes derived from that class. 

**A thrown object is caught by the first `catch` block that matches it.** This suggess arranging the `catch` blocks in inverse order of derivation:

```C++
class bad_1 {...};
class bad_2 : public bad_1 {...};
class bad_3 : public bad_2 {...};
...
void duper()
{
	...
	if (oh_no)
		throw bad_1();
	if (rats)
		throw bad_2();
	if (drat)
		throw bad_3();
}
...
try
{
	duper();
}
catch (bad_3 & be)
{...}
catch (bad_2 & be)
{...}
catch (bad_1 & be)
{...}
```

If the `bad_1 &` handler were first, it would catch the `bad_1`, `bad_3` exceptions. With the inverse order, a `bad_3` exception would be caught by the `bad_3 &` handler.

> **Tip**

> If you have an inheritance hierarchy of exception classes, you should arrange the order of the `catch` blocks so that the exception of the most-derived class (that is, the class furthest down the class hierarchy sequence) is caught first and the base-class exception is caught last.

Arranging `catch` blocks in the proper sequence allows you to be selective about how each type of exception is handled. But sometimes you might not know what type of exception to expect. For instance, say you write a function that calls another function, and you don’t know whether that other function throws exceptions. You can still catch the exception even if you don’t know the type. The trick to catching any exception is to **use an ellipsis for the exception type**:

```C++
catch (...) { // statements}	// catches any type exception
```

If you do know some exceptions that are thrown, you can place this catchall form at the end of the `catch` block sequence, a bit like the `default` case for a `switch`:

```C++
try
{
	duper();
}
catch (bad_3 & be)
{ // statements }
catch (bad_2 & be)
{ // statements }
catch (bad_1 & be)
{ // statements }
catch (bad_hmean & h)
{ // statements }
catch (...)			// catch whatever is left
{ // statements }
```

You can set up a handler to catch an object instead of a reference. A base-class object will catch a derived class object, but the derived aspects will by stripped off. Thus, base-class versions of virtual methods will be used.

### The `exception` Class

The `exception` header file defines an `exception` class that C++ uses as a base class for other exception classes used to support the language. Your code, too, can throw an `exception` object or use the `exception` class as a base class. One virtual member function is named `what()`, and it returns a string, the nature of which is implementation dependent. However, because this method is virtual, you can redefine it in a class derived from `exception`:

```C++
#include <exception>
class bad_hmean : public exception
{
public:
	const char * what() const noexcept { return "bad arguments to hmean()"; }
...
};
class bad_gmean : public std::exception
{
public:
	const char * what() const noexcept { return "bad arguments to gmean()"; }
...
};
```

If you don't want to handle these derived exceptions differently from one another, you can catch them with the same base-class handler:

```C++
try { ... }
catch (std::exception & e)
{
	cout < e.what() << endl;
...
}
```

Or you could catch the different types separately.

The C++ library defines many exception types based on `exception`.

#### The `stdexcept` Exception Classes

The `stdexcept` header file defines several more exception classes. First, the file defines the `logic_error` and `runtime_error` classes, both of which derive publicly from `exception`:

```C++
class logic_error : public exception
{
public:
	explicit logic_error(const string & what_arg);
	...
};

class runtime_error : public exception
{
public:
	explicit runtime_error(const string & what_arg);
	...
};
```

These two classes serve, in turn, as bases for two families of derived classes. The `logic_error` family describes typical logic errors. The name of each class indicates the sort of error it is intended to report:

```
domain_error
invalid_argument
length_error
out_of_bound
```

Each class has a constructor like that of `logic_error` that allows you to provide string to be returned by the `what()` method.

If you wrote a function that passed an argument to the `std::arcsin()` function, you could have your function throw a `domain_error object` if the argument were outside the `-1` to `+1` domain.

The `invalid_argument` exception alerts you that an unexpected value has been passed to a function. For example, if a function expects to receive a string for which each character is either a `'0'` or `'1'`, it could throw the `invalid_argument` exception if some other character appeared in the string.

The `length_error` exception is used to indicate that not enough space is available for the desired action. For example, the string class has an `append()` method that throws a `length_error` exception if the resulting string would be larger than the maximum possible string length.

The `out_of_bounds` exception is typically used to indicate indexing errors. For example, you could define an array-like class for which `operator()[]` throws the `out_of_bounds` exception if the index used is invalid for that array.

Next, the `runtime_error` family describes erros that might show up during runtime but that could not easily be predicted and prevented. The name of each class indicates the sort of error it is intended to report:

```
range_error
overflow_error
underflow_error
```

Each class has a constructor like that of `runtime_error` that allows you to provide the string to be returned by the `what()` method.

An underflow error can occur in floating-point calculations. In general, there is a smallest nonzero magnitude that a floating-point type can represent. A calculation that would produce a smaller value would cause an underflow error. An overflow error can occur with either integer or floating-point types when the magnitude of the result of a calculation would exceed the largest representable value for that type. A computational result can lie outside the valid range of a function without being an underflow or overflow, and you can use the `range_error` exception for such situations.

All these error classes have the same general characterisctics. The main distinction is that the different class names allow you to handle each type of exception individually. On the other hand, the inheritance relationships allow you to lump them together if you prefer. For example, the following code catches the `out_of_bound` excpetion individually, treats the remaining `logic_error` family of exceptions as a group and treats `exception` objects, the `runtime_error` family of objects and any remaining exception types derived from `exception` collectively:

```C++
try 
{
	...
}
catch (out_of_bounds & oe)	// catch out_of_bounds error
{...}
catch(logic_error & oe)		// catch remaining logic_error family
{...}
catch (exception & oe)		// catch runtime_error, exception objects
{...}
```

#### The `bad_alloc` Exception and `new`

The current C++ way to handle memory allocation problems with `new` is to have `new` throw a `bad_alloc` exception. The `new` header includes a declaration for the `bad_alloc` class, which is publicly derived from the `exception` class. 

Listing 15.13 demonstrates the current approach. If the exception is caught, the program displays the **implementation-dependent message** returned by the inherited `what()` method and terminates early.

```C++
// Listing 15.13
#include <iostream>
#include <new>
#include <cstdlib>
using namespace std;

struct Big
{
	double stuff[2000000000];
};

int main()
{
	Big * pb;
	try
	{
		cout << "Trying to get a big block of memory:\n";
		pb = new Big[10000];
		cout << "Got past thew new request:\n";
	}
	catch (bad_alloc & ba)
	{
		cout << "Caught the exception!\n";
		cout << ba.what() << endl;
		exit(EXIT_FAILURE);
	}
	cout << "Memory successfully allocated\n";
	pb[0].stuff[0] = 4;
	cout << pb[0].stuff[0] << endl;
	delete [] pb;
	return 0;
}
```

#### The Null Pointer and `new`

Much code was written when `new` (the old `new`) returned a null pointer upon failure. Some compilers handled the transition to the new `new` by letting the user set a flag or switch to choose which behavior she wanted. Currently, the standard provides for an alternative form of new that still returns a null pointer. Its use looks like this:

```C++
int * pi = new (std::nothrow) int;
int * pa = new (std::nothrow) int[500];
```

Using this form, you could rewrite the core of Listing 15.13 this way'

```C++ 
Big * pb;
pb = new (std::nothrow) Big[10000];
if (!pb)
{
	cout << "Could not allocate memory. Bye.\n";
	exit(EXIT_FAILURE);
}
```

### Exceptions, Classes, and Inheritance

Exceptions, classes, and inheritance interact in a couple ways. First, you can derive one exception class from another, as the standard C++ library does. Second, you can incorporate exceptions into classes by nesting exception class declarations inside a class definition. Third, such nested declarations can be inherited and can serve as base classes themselves.

Listing 15.14 starts us on the way to exploring some of these possbilities. This header file declares a rudimentary `Sales` class that holds a year value and an array of 12 monthly sales figures.The `LabeledSales` class derives from `Sales` and adds a member to hold a label for the data.

```C++
// Listing 15.14
#include <stdexcept>
#include <string>

class Sales
{
public:
	enum {MONTHS = 12};
	class bad_index : public std::logic_error
	{
	public:
		explicit bad_index(int ix,
			const std::string & s = "Index error in Sales object\n");
		int bi_val() const { return bi; }
		virtual ~bad_index() noexcept {}
	private:
		int bi;	// bad index value
	};
	explicit Sales(int yy = 0);
	Sales(int yy, const double * gr, int n);
	virtual ~Sales() {}
	int Year() const { return year; }
	virtual double operator[](int i) const;
	virtual double & operator[](int i);
private:
	double gross[MONTHS];
	int year;
};

class LabeledSales : public Sales
{
public:
	class nbad_index : public Sales::bad_index
	{
	public:
		nbad_index(const std::string & lb, int ix,
			const std::string & s = "Index error in LabeledSales object\n");
		const std::string & label_val() const {return lbl; }
		virtual ~nbad_index() noexcept {}
    private:
        std::string lbl;
	};
	explicit LabeledSales(const std::string & lb = "none", int yy = 0);
	LabeledSales(const std::string & lb, int yy, const double * gr, int n);
	virtual ~LabeledSales() {}
	const std::string & Label() const { return label; }
	virtual double operator[](int i) const;
	virtual double & operator[](int i);
private:
	std::string label;
};
```

The `bad_index` class is nested in the public section of `Sales`; this makes the class available as a type to client `catch` blocks. This class derives from the standard `logic_error` class. the `bad_index` class has the ability to store and report an out-of-bounds value for an array index.

The `nbad_index` class is nested in the public section of `LabeledSales`, making it available to client code as `LabeledSales::nbad_index`. It derives from `bad_index`, adding the ability to store and report the label of a `LabeledSales` object. Because `bad_index` derives from `logic_error`, `nbad_index` also ultimately derives from `logic_error`.

Both classes have overloaded `operator[]()` methods that are designed to access the individual array elements stored in an object and to throw an exception if an index is out of bounds.

Listing 15.15 shows the implementation of the methods that weren’t already defined inline in Listing 15.14. Note that nested classes require using the scope-resolution operator more than once. Also note that the `operator[]()` functions throw exceptions if the array index is out of bounds.

```C++
#include "test.hpp"
using std::string;

Sales::bad_index::bad_index(int ix, const string & s)
	: std::logic_error(s), bi(ix) {}

Sales::Sales(int yy) : year(yy)
{
	for (int i = 0; i < MONTHS; i++)
		gross[i] = 0;
}

Sales::Sales(int yy, const double * gr, int n) : year(yy)
{
	for (int i = 0; i < MONTHS; i++)
	{
		if (i < n)
			gross[i] = gr[i];
		else
			gross[i] = 0;
	}
}

double Sales::operator[](int i) const
{
	if (i < 0 || i >= MONTHS)
		throw bad_index(i);
	return gross[i];
}

double & Sales::operator[](int i)
{
	if (i < 0 || i >= MONTHS)
		throw bad_index(i);
	return gross[i];
}

LabeledSales::nbad_index::nbad_index(const string & lb, int ix,
		const string & s) : Sales::bad_index(ix, s), lbl(lb) {}

LabeledSales::LabeledSales(const string & lb, int yy)
	: Sales(yy), label(lb) {}

LabeledSales::LabeledSales(const string & lb, int yy,
		const double * gr, int n) : Sales(yy, gr, n), label(lb) {}

double LabeledSales::operator[](int i) const
{
	if (i < 0 || i >= MONTHS)
		throw nbad_index(Label(), i);
	return Sales::operator[](i);
}

double & LabeledSales::operator[](int i)
{
	if (i < 0 || i >= MONTHS)
		throw nbad_index(Label(), i);
	return Sales::operator[](i);
	
}
```

Listing 15.16 uses the classes in a program that first tries to go beyond the end of the array in the `LabeledSales` object `sales2` and then beyond the end of the array in the `Sales` object `sales1`. These attempts are made in two separate `try` blocks that test for each kind of exception.


```C++
// Listing 15.16
#include <iostream>
#include "test.hpp"

int main()
{
	using std::cout;
	using std::cin;
	using std::endl;

	double vals1[12] =
	{
		1220, 1100, 1122, 2212, 1232, 2334,
		2884, 2393, 3302, 2922, 3002, 3544
	};

	double vals2[12] =
	{
		12, 11, 22, 21, 32, 34,
		28, 29, 33, 29, 32, 35
	};

	Sales sales1(2011, vals1, 12);
	LabeledSales sales2("Blogstar", 2012, vals2, 12);

	cout << "First try block:\n";
	try
	{
		cout << "Year = " << sales1.Year() << endl;
		for (int i = 0; i < 12; i++)
		{
			cout << sales1[i] << ' ';
			if (i % 6 == 5)
				cout << endl;
		}
		cout << "Year = " << sales2.Year() << endl;
		cout << "Label = " << sales2.Label() << endl;
		for (int i = 0; i <= 12; i++)
		{
			cout << sales2[i] << ' ';
			if (i % 6 == 5)
				cout << endl;
		}
		cout << "End of try block 1.\n";
	}
	catch(LabeledSales::nbad_index & bad)
	{
		cout << bad.what();
		cout << "Company: " << bad.label_val() << endl;
		cout << "bad index: " << bad.bi_val() << endl;
	}
	catch (Sales::bad_index & bad)
	{
		cout << bad.what();
		cout << "bad index: " << bad.bi_val() << endl;
	}
	cout << "\nNext try block:\n";
	try
	{
		sales2[2] = 37.5;
		sales1[20] = 23345;
		cout << "End of try block 2.\n";
	}
	catch(LabeledSales::nbad_index & bad)
	{
		cout << bad.what();
		cout << "Company: " << bad.label_val() << endl;
		cout << "bad index: " << bad.bi_val() << endl;
	}
	catch (Sales::bad_index & bad)
	{
		cout << bad.what();
		cout << "bad index: " << bad.bi_val() << endl;
	}
	cout << "done\n";

	return 0;
}
```

### When Exceptions Go Astray

### Exception Cautions

Exception specifications don't work well with templates because template functions might throw different kinds of exceptions, depending on the particular speicilization used. Exceptions and dynamic memory allocation don't always work that well together.

First, consider the following function:

```C++
void test1(int n)
{
	string mesg("I'm trapped in an endless loop");
	...
	if (oh_no)
		throw exception();
	...
	return;
}
```

Thanks to stack unwinding, the throw statement, even though it terminates the function prematurely, still allows the destructor to be called. So in this case, memory is managed properly.

Now consider this function:

```C++
void test2(int n)
{
	double * ar = new double[n];
	...
	if (oh_no)
		throw exception();
	...
	delete [] ar;
	return;
}
```

Here there is a problem. Unwinding the stack removes the variable ar from the stack. But the premature termination of the function means that the `delete []` statement at the end of the function is skipped. The pointer is gone, but the memory block it pointed to is still intact and inaccessible. In short, there is a memory leak.

The leak can be avoided. For example, you can catch the exception in the same function that throws it, put some cleanup code into the `catch` block, and rethrow the exception:

```C++
void test3(int n)
{
	double * ar = new double[n];
	...
	try
	{
		if (oh_no)
			throw exception();
	}
	catch (exception & ex)
	{
		delete [] ar;
		throw;
	}
	...
	delete [] ar;
	return;
}
```

However, this clearly enhances the opportunities for oversights and other errors. Another solution is to use one of the smart pointer templates discussed in Chapter 16, “The string Class and the Standard Template Library.”

## Runtime Type Identification

### What Is RTTI For?

Suppose you have a hierarchy of classes descended from a common base class and a base-class pointer that points to one of these class objects. How can you tell what kind of object it points to?

We need to think about why you would want to know the type. It could be that a derirved object has an uninherited method. In that case, only some objects could use the method. Or maybe, for debugging purposes, you would like to keep track of which kinds of objects were generated. For these last two cases, RTTI provides an answer.

### How Does RTTI Work?

C++ has three components supporting RTTI:

* The `dynamic_cast` operator generates a pointer to a derived type from a pointer to a base type, if possible. Otherwise, the operator returns `0`, the null pointer.
* The `typeid` operator returns a value identifying the exact type of an object.
* A `type_info` structure holds information about a particular type.

You can use RTTI only with **a class hierarchy that has virtual functions**. The reason for this is that these are the only class hierarchies for which you should be assigning the addresses of derived objects to base-class pointers.

> **Caution**

> RTTI works only for classes that have virtual functions

Let's examine the three components of RTTI

#### The `dynamic_cast` operator

The `dynamic_cast` operator is intended to be the most heavily used RTTI component. It doesn't answer the question of what type of object a pointer points to. Instead, it answers the question of whether you can safely assign the address of an object to a pointer of a particular type. Let's look at what that means. Suppose you have the following hierarchy:

```C++
class Grand { // has virtual methods};
class Superb : public Grand { ... };
class Magnificent : public Superb { ... };
```

Next, suppose you have the following pointers:

```C++
Grand * pg = new Grand;
Grand * ps = new Superb;
Grand * pm = new Magnificent;
```

Finally, consider the following type casts:

```C++
Magnificent * p1 = (Magnificent *) pm;		// #1
Magnificent * p2 = (Magnificent *) pg;		// #2
Superb * p3 = (Superb *) pm;			// #3
```

Depending on the class declarations, all of them could be safe, but the only ones guaranteed to be safe are the ones in which the pointer is the same ype as the object or else a direct or indirect base type for the object. In this example, Type Cast #1 and #3 is safe but #2 is not safe because it assigns the address of a base-class object to a derived-class pointer.

Note that the question of whether a type conversion is safe is both more general and useful that the question of what kind of object is pointed to. The usual reason for wanting to know the type is so that **you can know if it's safe to invoke a particular method**.

Let's look at the `dynamic_cast` syntax. The operator is used like this, where `pg` points to an object:

```C++
Superb * pm = dynamic_cast<Superb *>(pg);
```

This code asks whether pointer `pg` can be type cast safely to the type `Superb *`. If it can, the operator returns the address of the object. Otherwise it returns `0`, or `nullptr`.

> **Note**

> In general, the following expression converts the pointer `pt` to a pointer of type `Type *` if the pointed-to object (`*pt`) is of type `Type` or else derived directly or indirectly from type `Type`:

```C++
dynamic_cast<Type *>(pt)
```

> Otherwise, the expression evaluates to `0`, or `nullptr`.

Listing 15.7 illustrates the process. First it defiens three classes, named `Grand`, `Superb` and `Magnificent`. The `Grand` class defines a virtual `Speak()` function, which each of the other classes redefines. The `Superb` class defines a virtual `Say()` function, which `Magnificent` redefines. The program defines a `GetOne()` function that randomly creates and initializes an object of one of these three types and then returns the address as a type `Grand *` pointer. A loop assigns this pointer to a type `Grand *` variable called `pg` and then uses `pg` to invoke the `Speak()` function. Because this function is virtual, the code correctly invokes the `Speak()` version that is appropiate to the pointed-to object:

```C++
for (int i = 0; i < 5; i++)
{
	pg = GetOne();
	pg->Speak();
}
```

**You cannot use this exact approach to invoke the `Say()` function;** it is not defined for the `Grand` class. However, **you can use the `dynamic_cast` operator to see if `pg` can be type cast to a pointer `Superb`.** This will be true if the object is either type `Superb` or `Magnificent`. In either cast, you can invoke the `Say()` function safely:

```C++
if (ps = dynamic_cast<Superb *>(pg))
	ps->Say();
```

Listing 15.17 shows the full code

```C++
// Listing 15.17
#include <iostream>
#include <cstdlib>
#include <ctime>

using std::cout;
class Grand
{
private:
	int hold;
public:
	Grand(int h = 0) : hold(h) {}
	virtual void Speak() const { cout << "I am a grand class!\n"; }
	virtual int Value() const { return hold; }
};

class Superb : public Grand
{
public:
	Superb(int h = 0) : Grand(h) {}
	void Speak() const { cout << "I am a superb class!!\n"; }
	virtual void Say() const
		{ cout << "I hold the superb value of " << Value() << "!\n"; }
};

class Magnificent : public Superb
{
private:
	char ch;
public:
	Magnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}
	void Speak() const { cout << "I am a magnificent class!!!\n"; }
	void Say() const { cout << "I hold the character " << ch <<
				" and the integer " << Value() << "!\n"; }
};

Grand * GetOne();

int main()
{
	std::srand(std::time(0));
	Grand * pg;
	Superb * ps;
	for (int i = 0; i < 5; i++)
	{
		pg = GetOne();
		pg->Speak();
		if (ps = dynamic_cast<Superb *>(pg))
			ps->Say();
	}
	return 0;
}


Grand * GetOne()
{
	Grand * p;
	switch (std::rand() % 3)
	{
		case 0:
			p = new Grand(std::rand() % 100);
			break;
		case 1:
			p = new Superb(std::rand() % 100);
			break;
		case 2:
			p = new Magnificent(std::rand() % 100, 'A' + std::rand() % 26);
			break;
	}
	return p;
}
```

Here is some sample output:

```
I am a superb class!!
I hold the superb value of 68!
I am a magnificent class!!!
I hold the character R and the integer 68! I am a magnificent class!!!
I hold the character D and the integer 12! I am a magnificent class!!!
I hold the character V and the integer 59! I am a grand class!
```

As you can see, the `Say()` methods were invoked just for the `Superb` and `Magnificent` classes.

You can use `dynamic_cast` with references, too. The usage is slightly different since there is no special reference value that can used to indicate failure. Instead, when goaded by an improper request, `dynamic_cast` throws a type `bad_cast` exception, which is derived from the `exception` class and defined in the `typeinfo` header file. Thus, the operator can be used as follows, where `rg` is a reference to a `Grand` object:

```C++
#include <typeinfo> // for bad_cast
...
try
{
	Superb & rs = dynamic_cast<Superb &>(rg);
	...
}
catch (bad_cast &)
{
	...
}
```

#### The `typeid` Operator and `type_info` Class

The `typeid` operator lets you determine whether two objects are the same type. Somewhat like `sizeof`, it accepts two kinds of arguments:

* The name of a class
* An expression that evaluates to an object

The `typeid` operator returns a reference to a `type_info` object, where `type_info` is a class defined in the `typeinfo` header file. The `type_info` class overloads the `==` and `!=` operators so that you can use these operators to compare types. For example, the following expression evaluates to the `bool` value `true` if `pg` points to a `Magnificent` object and to `false` otherwise:

```C++
typeid(Magnificent) == typeid(*pg)
```

If `pg` happens to be a null pointer, the program throws a `bad_typeid` exception. This exception type is derived from the `exception` class and is declared in the `typeinfo` header file.

The `type_info` class includes a `name()` member that returns an implementation-dependent string that is typically )but not necessarily) the name of the class. For example, the following statement displays the string defiend for the class of the object to which the pointer `pg` points:

```C++
cout << "Now processing type " << typeid(*pg).name() << ".\n";
```

Listing 15.18 modifies Listing 15.17 so that is uses the `typeid` operator and the `name()` member function. Note that they are used for situations that `dynamic_cast` and `virtual` functions don't handle. The `typeid` test is used to select an action that isn't even a class method, so it can't be invoked by a class pointer. The `name()` method statement shows how the methods can be used in debuggin. Note that the program includes the `typeinfo` header file.

```C++
// Listing 15.18
#include <iostream>
#include <cstdlib>
#include <ctime>
#include <typeinfo>
using namespace std;

using std::cout;
class Grand
{
private:
	int hold;
public:
	Grand(int h = 0) : hold(h) {}
	virtual void Speak() const { cout << "I am a grand class!\n"; }
	virtual int Value() const { return hold; }
};

class Superb : public Grand
{
public:
	Superb(int h = 0) : Grand(h) {}
	void Speak() const { cout << "I am a superb class!!\n"; }
	virtual void Say() const
		{ cout << "I hold the superb value of " << Value() << "!\n"; }
};

class Magnificent : public Superb
{
private:
	char ch;
public:
	Magnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}
	void Speak() const { cout << "I am a magnificent class!!!\n"; }
	void Say() const { cout << "I hold the character " << ch <<
				" and the integer " << Value() << "!\n"; }
};

Grand * GetOne();

int main()
{
	srand(time(0));
	Grand * pg;
	Superb * ps;
	for (int i = 0; i < 5; i++)
	{
		pg = GetOne();
		cout << "Now processing type " << typeid(*pg).name() << ".\n";
		pg->Speak();
		if (ps = dynamic_cast<Superb *>(pg))
			ps->Say();
		if (typeid(Magnificent) == typeid(*pg))
			cout << "Yes, you're really magnificent.\n";
	}
	return 0;
}


Grand * GetOne()
{
	Grand * p;
	switch (std::rand() % 3)
	{
		case 0:
			p = new Grand(std::rand() % 100);
			break;
		case 1:
			p = new Superb(std::rand() % 100);
			break;
		case 2:
			p = new Magnificent(std::rand() % 100, 'A' + std::rand() % 26);
			break;
	}
	return p;
}
```

### Misusing RTTI

RTTI has many vocal critics within the C++ community. Without delving into the debate over RTTI, let's look at the sort of programming that you should avoid.

Consider the core of Listing 15.17

```C++
Grand * pg;
Superb * ps;
for (int i = 0; i < 5; i++)
{
	ps = GetOne();
	ps->Speak();
	if (ps = dynamic_cast<Superb *>(pg))
		ps->Say();
}
```

By using `typeid` and ignoring `dynamic_cast` and virtual functions, you can rewrite this code as follows:

```C++
Grand * pg;
Superb * ps;
Magnificent * pm;
for (int i = 0; i < 5; i++)
{
	pg = GetOne();
	if (typeid(Magnificent) == typeid(*pg))
	{
		pm = (Magnificent *) pg;
		pm->Speak();
		pm->Say();
	}
	else if (typeid(Superb) == typeid(*pg))
	{
		ps = (Superb *) pg;
		ps->Speak();
		ps->Say();
	}
	else
		pg->Speak();
}
```

Note only is this uglier and longer than the original, it has the serious flaw of naming each class explicitly. Suppose, for example, that you find it necessary to derive an `Insufferable` class from the `Magnificent` class. And suppose the new class redefines `Speak()` and `Say()`. With the version that uses `typeid` to test explicitly for each type, you would have to modify the `for` loop code, adding a new `else if` section. The original version, however, requires no changes at all. The following statement works for all classes derived from `Grand`:

```C++
pg->Speak();
```

And this statement works for all classes derived from `Superb`:

```C++
if (ps = dynamic_cast<Superb *>(pg))
	ps->Say();
```

> **Tip**

> If you find yourself using `typeid` in an extended series of `if else` statements, you should check whether you should instead use virtual functions and `dynamic_cast`

## Type Cast Operators

C++ add four type cast operators that provide more discipline for the casting process:

```C++
dynamic_cast
const_cast
static_cast
reinterpret_cast
```

Instead of using general type cast, you can select an operator that is suited to a particular purpose. 

You've already seen the `dynamic_cast` operator. To summarize, suppose `High` and `Low` are two classes, that `ph` points to a `High` object, and `pl` is type `Low *`. Then the following statement assigns a `Low *` pointer to `pl` only if `Low` is an accessible base class to `High`:

```C++
pl = dynamic_cast<Low *> ph;
```

Otherwise, the statement assigns the null pointer to `pl`. In general, the operator has this syntax:

```C++
dynamic_cast<type-name> (expression)
```

The `const_cast` operator is for making a type cast with the sole purpose of changing whether a value is `const`. It has the same syntax as the `dynamic_cast` operator:

```C++
const_cast<typename>(expression)
```

The result of making such a type cast is an error if any other aspect of the type is altered. This is, `typename` and `expression` must by of the same type, except that they can differ in the presence or absence of `const`. Again, suppose `High` and `Low` and two classes:

```C++
High bar;
const High * pbar = &bar;
High * pb = const_cast<High *> (pbar);		// valid
const Low * pl = const_cast<const Low *> (pbar);	// invalid
```

The reason for this operator is that occasionally you may have a need for a value that is constant most of the time but that can be changed occasionaly. The `const_cast` is not all powerful. It can change the pointer access to a quantity, but the effect of attempting to change a quantity that is declared `const` is undefined. Let's clarify this statement with the short example shown in Lisitng 15.19

```C++
// Listing 15.19
#include <iostream>
using std::cout;
using std::endl;
void change(const int * pt, int n);

int main()
{
	int pop1 = 38383;
	const int pop2 = 2000;

	cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;
	change(&pop1, -103);
	change(&pop2, -103);
	cout << "pop1, pop2: " << pop1 << ", " << pop2 << endl;
	return 0;
}

void change(const int * pt, int n)
{
	int * pc;
	pc = const_cast<int *>(pt);
	*pc += n;
}
```

The `const_cast` operator can remove the `const` from `const int * pt`, thus allowing the compiler to accept the following statement in `change()`:

```C++
*pc += n;
```

However, because `pop2` is declared as `const`, the compiler may protect it from any change. The pointer `pc` has the `const` cast away, so it can be used to chang the pointed-to value, but only if that value wasn't itself `const`. Therefore, `pc` can be used to alter `pop1` but not `pop2`.

The `static_cast` operator has the same syntax as the other operators:

```C++
static_cast<typename> (expression)
```

It's valid only if `typename` can be converted implicitly to the same type that `expression` has, **or vice versa**. Suppose the `High` is a base class to `Low` and that `Pond` is an unrelated class. Then conversions from `High` to `Low` and `Low` to `High` are valid, but a conversion from `Low` to `Pond` is disallowed:

```C++
High bar;
Low blow;
...
High * pb = static_cast<Hight *> (&blow);		// valid upcast
Low * pl = static_cast<Low *> (&bar);		// valid downcast
Pond * pmer = static_cast<Pond *> (&blow);		// invalid, Pond unrelated.
```

The first conversion here is valid because an upcast can be done explicitly. The second conversion, from a base-class pointer to a derived-class pointer, can't be done without an explicit type conversion. But **because the type cast in the other direction can be made without a type cast**, it's valid to use `static_cast` for a downcast.

Similarly, because an enumeration value can be converted to an integral type without a typecast, an integral type can be converted to an enumeration value with `static_cast`.

The `reinterpret_cast` operator is for inherently risky type casts. It doesn't let you cast away `const`, but it does allow other unsavory things. For example,

```C++
struct dat {short a; short b;};
long value = 0xA224B118;
dat * pd = reinterpret_cast<dat *> (&value);
cout << hex << pd->a;	// display first 2 bytes of value.
```




