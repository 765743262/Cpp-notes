# Reusing Code in C++

Contents:

* _Has-a_ realtionships
* Classes with member objects (containment)
* The `vlarray` template class
* Private and protected inheritance
* Multiple inheritance
* Virtual base classes
* Creating class templates
* Using class templates
* Template specializations

## Classes with Object Members

What is a student? We give a definition : someone with an identifying name and a set of quiz scores. 

Both members can be implemented with a class object that is defined yourself or the standard library class.

### The `valarray` Class: A Quick Look

The template aspect means you have to provide a specific type when declaring an object. The class aspect means that to use `valarray` object, you need to know something about class constructors and other class methods. Here are some examples:

```C++
double gpa[5] = {3.1, 3.5, 3.8. 2.9. 3.3};
valarray<double> v1; 			// an array of double, size 0
valarray<int> v2(8);			// an array of 8 int elements
valarray<int> v3(10, 8);		// an array of 8 int elements, each set to 10
valarray<double> v4(gpa, 4);	// an array of 4 elements, initialized to the first 4 elements of gpa
```

As you can see, you can

* Create an empty array of zero size
* An empty array of a given size
* An array with all elements initialized to the same value
* An array initialized using the values from an ordinary array.

Here are a few of the methods:

* The `operator[] ()` method provides access to individual elements
* The `size()` method returns the number of elements
* The `sum()` method returns the sum of the elements
* The `max()` method returns the largest element
* The `min()` method returns the smallest element.

### The `Student` Class Design

Listing 14.1

```C++
#include <iostream>
#include <string>
#include <valarray>
class Student
{
private:
	typedef std::valarray<double> ArrayDb;
	std::string name;
	ArrayDb scores;
	std::ostream & arr_out(std::ostream & os) const;
public:
	Student() : name("Null Student"), scores() {}
	explicit Student(const std::string & s) : name(s), scores() {}
	explicit Student(int n) : name("Nully"), scores(n) {}
	Student(const std::string & s, int n) : name(s), scores(n) {}
    Student(const std::string & s, const ArrayDb & a) : name(s), scores(a) {}
	Student(const char * str, const double * pd, int n) : name(str), scores(pd, n) {}
	~Student() {}
	double Average() const;
	const std::string & Name() const;
	double & operator[](int i);
	double operator[](int i) const;

	// friends
	// input
	friend std::istream & operator>>(std::istream & is, Student & stu);
	friend std::istream & getline(std::istream & is, Student & stu);

	// output
	friend std::ostream & operator<<(std::ostream & os, const Student & stu);
};
```

The student class contains this `typedef`:

```C++
typedef std::valarray<double> ArrayDb;
```

Placing this `typedef` in the private portion of the class definition means that it can be use internally in the `Student` implementation but not by outside users of the `Student` class.

Note the use of the keyword `explicit`:

```C++
explicit Student(const std::string & s) : name(s), scores() {}
explicti Student(int n) : name("Nully"), scores(n) {}
```

#### Initializing Contained Objects

We can use a member initializer list to initialize the base-class portion of a derived object, or a data member.

**For _inherited_ objects, construcotors use the _class_ name in the member initializer list to invoke a specific base-class constructor. For _member_ objects, constructors use the _member_ name.** For example, look at the last constructor in Listing 14.1:

```C++
Student(const char * str, const double * pd, int n) : name(str), scores(pd, n) {}
```

Here, this constructor ues the member names, not the class names. Each item in this initialization list **invokes the matching constructor**. For example, `scores(pd, n)` invokes the `ArrayDb(const double *, int)` constructor.

As with inherited components, **C++ requires that all member objects be constructed before the rest of an object is constructed**. So if you omit the initialization list, **C++ uses the default constructors defined for the member objects classes.**

> ##### Initialization Order

> When you have a member initializer list that initializes more than one item, the items are initialized in the order **in which they were declared**, not in the order in which they appear in the initializer list. For example, suppose you write a `Student` constructor this way:

```C++
Student(const char * str, const double * pd, int n) : scores(pd, n), name(str) {}
```

The `name` member would still be intialized first.

#### Using an Interface for a Contained Object

The interface for a contained class isn't public, but it can be used within the class methods. For example, here is how you can define a function that returns the average of a student's scores:

```C++
double Student::Average() const
{
	if (scores.size() > 0)
		return scores.sum() / scores.size();
	else
		return 0;
}
```

Listing 14.2

```C++

using std::ostream;
using std::endl;
using std::istream;
using std::string;

double Student::Average() const
{
	if (scores.size() > 0)
		return scores.sum() / scores.size();
	else
		return 0;
}

const string & Student::Name() const
{
	return name;
}

double & Student::operator[] (int i)
{
	return scores[i];
}

double Student::operator[](int i) const
{
	return scores[i];
}

ostream & Student::arr_out(ostream & os) const
{
	int i;
	int lim = scores.size();
	if (lim > 0)
	{
		for (i = 0; i < lim; i++)
		{
			os << scores[i] << " ";
			if (i % 5 == 4)
				os << endl;
		}
		if (i % 5 != 0)
			os << endl;
	}
	else
		os << " empty array ";
	return os;
}

istream & operator>>(istream & is, Student & stu)
{
	is >> stu.name;
	return is;
}

istream & getline(istream & is, Student & stu)
{
	getline(is, stu.name);
	return is;
}

ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << stu.name << ":\n";
	stu.arr_out(os);
	return os;
}
```

Note how this implementation implements the `[]` operator and `getline` friend for `Student` Class.

#### Using the New `Student` Class

Listint 14.3

```C++
using std::cin;
using std::cout;
using std::endl;

void set(Student & sa, int n);
const int pupils = 3;
const int quizzes = 5;

int main(void)
{
	Student ada[pupils] = 
		{ Student(quizzes), Student(quizzes), Student(quizzes)};

	int i;
	for (i = 0; i < pupils; i++)
	{
		set(ada[i], quizzes);
	}
	cout << "\nStudent List:\n";
	for (i = 0; i < pupils; i++)
		cout << ada[i].Name() << endl;
	cout << "\nResults:";
	for (i = 0; i < pupils; ++i)
	{
		cout << endl << ada[i];
		cout << "average: " << ada[i].Average() << endl;
	}
	cout << "Done.\n";
	return 0;
}

void set(Student & sa, int n)
{
	cout << "Please enter the student's name: ";
	getline(cin, sa);
	cout << "Please enter " << n << "quiz scores:\n";
	for (int i = 0; i < n; i++)
		cin >> sa[i];
	while (cin.get() != '\n')
		continue;
}
```



## Private Inheritance

_Private inheritance_ is a second means of implementing the _has-a_ relationship. With _private inheritance_, **public and protected members of the base class become private members of the derived class.** This means the methods of the base class do not become part of the public inter face of the derived object.

**With public inheritance, the derived class inherits the base-class interface. With private inheritance, the public methods of the base class become private methods of the derived class.**

Containment adds an object to a class as a **named member object**, whereas private inheritance adds an object to a class as an **unnamed inherited object.** This book uses the term _subobject_ to denote an object added by inheritance or by containment.

You can produce a `Student` class that uses private inheritance and has the same public interface as the containment version. **Thus the difference between the two approaches affect the implementation, not the interface**.

### A New Version of the `Student` Class Example

To get private inheritance, the keyword `private` instead of `public` when defining the class. (**Actually, private is the default, so omitting an access qulifier also leads to private inheritance**) The `Student` class inherit from two classes, so the declaration should list both:

```C++
class Student : private std::string, private std::valarray<double>
{
public:
	...
};
```

Having more than one base class is called _multiple inheritance_ (MI).

Note that the new class **doesn't need private data**. **The containment version of of this example provides two explicitly named objects as members**. Private inheritance however, provides two **nameless subobjects as inherited members**. 

#### Initializing Base-Class Components

You can no longer use `name` and `scores` to describe the objects. Similar to public inheritance, the code should use **the _class name_ instead of a _member name_ to identify a constructor**:

```C++
Student(const char * str, const double * pd, int n) : std::string(str), ArrayDb(pd, n) {}
```

Listing 14.4

```C++
#include <iostream>
#include <valarray>
#include <string>
class Student : private std::string, private std::valarray<double>
{
private:
	typedef std::valarray<double> ArrayDb;
	std::ostream & arr_out(std::ostream & os) const;
public:
	Student();
	explicit Student(const std::string & s) : std::string(s), ArrayDb() {}
	explicit Student(int n) : std::string("Nully"), ArrayDb(n) {}
	Student(const std::string & s, int n) : std::string(s), ArrayDb(n) {}
	Student(const char * str, const double * pd, int n) : std::string(str), ArrayDb(pd, n) {}
	~Student() {}
	double Average() const;
	double & operator[](int i);
	double operator[](int i) const;
	const std::string & Name() const;

	friend std::istream & operator>>(std::istream & is, Student & stu);
	friend std::istream & getline(std::istream & is, Student & stu);
	friend std::ostream & operator<<(std::ostream & s, const Student & stu);
};
```

#### Accessing Base-Class Methods

Containment invoked the methods with an object. However, inheritance lets you use the **class name** and the **scope-resolution** operator to invoke base-class methods:

```C++
double Student::Average() const
{
	if (ArrayDb::size() > 0)
		return ArrayDb::sum() / ArrayDb::size();
	else
		return 0;
}
```

#### Accessing Base-Class Objects

The containment version of the `Student` class implements the `Name()` method by having the method return the `name` member. But with private inheritance, the `string` object has no name. How can `Student` code access the inner `string` object?

Because `Student` is derived from `string`, it's possible to type cast a Student object to a `string` object. **Use a type cast to create a reference avoids invoking constructors:**

```C++
const string & Student::Name() const
{
	return (const string &) *this;
}
```

#### Accessing Base-Class Friends

Accessing base-class frineds uses basically the same technique used to access a base-class object in a class method, but with friends you have a name for the `Student` object, so the code uses the name instead of `*this`.

```C++
ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << (const String &) stu << ":\n";
}
```

**With private inheritance, a reference or pointer to a base class cannot be assigned a reference or pointer to derived class without an explicit type cast.**

Listing 14.5

```C++
using std::cin;
using std::cout;
using std::endl;
using std::ostream;
using std::istream;
using std::string;

double Student::Average() const
{
	if (ArrayDb::size() > 0)
		return ArrayDb::sum() / ArrayDb::size();
	else
		return 0;
}

const string & Student::Name() const
{
	return (const string &) *this;
}

double & Student::operator[](int i)
{
	return ArrayDb::operator[](i);
}

double Student::operator[](int i) const
{
	return ArrayDb::operator[](i);
}

ostream & Student::arr_out(ostream & os) const
{
	int i;
	int lim = ArrayDb::size();
	if (lim > 0)
	{
		for (i = 0; i < lim; i++)
		{
			os << ArrayDb::operator[](i) << " ";
			if (i % 5 == 4)
				os << endl;
		}
		if (i % 5 != 0)
			os << endl;
	}
	else
		os << " empty array ";
	return os;
}

istream & operator>>(istream & is, Student & stu)
{
	is >> (string &) stu;
	return is;
}

istream & getline(istream & is, Student & stu)
{
	getline(is, (string &) stu);
	return is;
}

ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << (const string & ) stu << ":\n";
	stu.arr_out(os);
	return os;
}
```

#### Using the Revised `Student` Class

Because both approaches have the same interface, you can test the two verions with exactly the same program.

### Containment or Private Inheritance?

In general, you should use containment to model a _has-a_ relationship. One privilege is that containment allows you to **include more that one subobject of the same class.**

You should use private inheritance if the new class needs to access protected members in the original class of if it needs to redefine virtual functions.

### Protected Inheritance

Protected inheritance is a variation on private inheritance. It uses the keyword `protected` when listing a base class:

```C++
class Student : protected std::string, protected std::valarray<double>
{...};
```

With protected inheritance, **public and protected members of a base class become protected members of the derived class**.

**The main difference between private and protected inheritance occurs when you derive another class from the derived class.** 

Table 14.1 summarizes public, private, and protected inheritance. The term _implicit upcasting_ means that you can have a base-class pointer or reference refer to a derived class object without using an explicit type cast:

Property | Public Inheritance | Protected Inheritance | Private Inheritance

 --- | --- | --- | --- 


