# Chapter 8

## Content

* Inline functions
* Reference variables
* Pass argument by reference
* Default arguments
* Function overloading
* Function templates
* Function templates specializations

## Inline Functions

The difference between normal and inline functions is how compiler incorporates them:

* Normal functions:

	The program will jump to the function's address and then jump back.

	This includes:

	* Reach call
	* Stores memory address of instructions *following* the call
	* **Copy function arguments** to the stacks
	* Jump to the address of function and execute
	* Jump back.

* Inline functions:
	
	The compiler put the compiled code in the program. So we do not need to jump back and forth.

**A disavantage:**

Comes with a memory penalty if an inline function is called at several locations.

To use inline, you must take at least two actions:

* Preface the function declaration with the keyword inline
* Preface the function definition with the keyword inline.

C's macros are not real functions. **Always** convert a macro to an inline function if you can.

## Reference Variables

### Creating a Reference Variable

"**Reference**" is a type. So "**reference variable**" makes sense.

The main use is as a formal argument.

**Declaration:**
		
	int rats;
	int & rodents = rats;

Note you place "&" just as how you will place a "*".

**NOTE: YOU MUST INITIALIZE A REFERENCE VARIABLE WHEN YOU DECLARE IT**, code like

	int rat;
	int & rodent;
	rodent = rat;

isn't allowed.

### References as Function Parameters

* **Passing by reference**:
  
  Allows a called function to access variables in the calling function.

* Passing by value:
  
  Just make a copy of that variable.

A function using reference as arguments may look like this:

	void swap(int & a, int & b);

And to use, you use:
	
	int first, second;
	swap(first, second);

Note passing by value and passing by reference may look identical. The **only** way to distinguish them is to look at the prototype or the definition.

### Reference Properties and Oddities

Functions that pass by value can use many kinds of actual argument like expressions. But this is not the case for contemporary C++.

But in early years of C++, 

	refcude(x + 3.);

is allowed. This will create a temporary, nameless variable with the value of x + 3.0. Then ra becomes a reference to that variable.

#### Temporary Variables, Reference Arguments, and const

Currently, a temporary variable can be permitted **only when the argument is a const reference.**

Provided that the reference parameter is a const (**and only in this case the following two applies**):

* When the actual argument is the corret type but not lvalue. **Non-const variable IS of correct type**
* When the actual argument is the wrong type, but it's of a type that can be converted to correct type

**Note:**

* Lvalue: all variables with an address. Const variables are non-modifiable lvalue.
* Non-lvalue: literal constants, expressions.

Consider codes:

	double side = 3.0;
	long edge = 5L;
	double refcude(double & d);

	double(side);
	double(edge);
	double(side + 10.0);

The latter two are the cases. But note double(side) is a exact match.

Note what compiler do: create a temporary and anonymous variable and **makes ra refer to it**.

The reason why **only this is okey for constant reference** is non-const reference is for modification, but a temporary variable cannot achieve that.

So in short, temporary variable is created when parameter is const reference and the argument isn't an lvalue or of the wrong type.

* refcube(a_long_variable);
* refcube(3.0 + x);

Const: const parameter accepts both non-const and const argument as exact match.

### Using References with a Structure

Suppose a structure definition:

	struct free_throws
	{
		std::string name;
		int made;
		int attempts;
		float percent;
	};

Then a function using a reference could be prototyped as follows:
	
	void set_pc(free_throws & ft);

Note we replace built-int types like int with "free_throws".

We can return a reference to the structure: 

	free_throws & accumulate(free_throw & target, const free_throw & source);

In the return statement, we just return the variable we want to refer to. In this case
the function call can be use as if it were the variable it refer to like:

	display(accumulate(a, b));

or

	accumulate(a, b) = k;
	accumulate(a, b).member
	accumulate(accumulate(a, b), c);

### Why Return a Reference?

This is similar to the difference between passing by value and passing by reference.

Consider
	
	dup = accumulate(team, five);

If accumulate() returns a structre, this could involve copying the entire structure. This is inefficient.

**Note: a function that returns a reference is actually an alias for the referred-to variable.**

### Being Careful About What a Return Reference Refers To

**NEVER return a reference to a temporary variable.**

There are two ways to avoid this:

1. Return a reference that was passed as an argument to the function.
2. Use new to create new storage.

One example of the second way:

	const free_throw & clone(free_throws & ft)
	{
		free_throw * ft = new free_throw;

		*pt = ft;
		return *pt;
	}

Note *pt is a lvalue so it can be assign to a reference variable.

Then you can use this function like:

	free_throw & jolly = clone(three);

**Remeber to use delete to free momery allocated.**

### Why Use const with a Reference Return?

Regular return types are _rvalues. Non-const reference return types are modifiable lvalues. Const reference are non-modifiable lvalues.

Also note in the prototype, first argument isn't const but the second is.

### Using References with a Class Object

**The usual C++ practice for passing class objects to a function is to use references.**

Look at an example:

**Listing 8.7 strquote.cpp**

	#include <iostream>
	#include <string>
	// Because we use string in the prototype, this is necessary
	using namespace std;
	string version1(const string &s1, const string &s2);
	// Return string reference such that you can use function as a string variable
	const string & version2(string & s1, const string & s2);
	const string & version3(string & s1, const string & s2);

	int main(void)
	{
	    string input;
	    string copy;
	    string result;

	    cout << "Enter a string: ";
	    // Getline will discard the newline character
	    getline(cin, input);
	    copy = input;
	    cout << "Your string as entered: " << input << endl;
	    result = version1(input, "***");
	    cout << "Your string enhanced: " << result << endl;
	    cout << "Your original string: " << input << endl;

	    result = version2(input, "###");

	    cout << "Your string enhanced: " << result << endl;
	    cout << "Your original string: " << input << endl;

	    cout << "Resetting original string.\n";
	    input = copy;
	    result = version3(input, "@@@");
	    cout << "Your string enhanced: " << result << endl;
	    cout << "Your original string: " << input << endl;

	    return 0;
	}

	string version1(const string & s1, const string & s2)
	{
	    string temp;

	    temp = s2 + s1 + s2;

	    // This is save because we actually return a copy of temp
	    return temp;
	}

	const string & version2(string & s1, const string & s2)
	{
	    // s1 is changed
	    s1 = s2 + s1 + s2;
	    // Safe bacause s1 exists in the calling routine
	    return s1;
	}

	const string & version3(string & s1, const string & s2)
	{
	    string temp;

	    temp = s2  + s1 + s2;

	    // Unsafe to return reference to local variable
	    return temp;
	}

We can use

	string version4(string s1, string s2);

instead but using references is more efficient.

The return type of version 1 is string. But if we return a string &, it will be an error.

### Passing a C-Style String Argument to a string Object Reference Parameter

You may notice in _version1()_ both formal parameters are type _const string &_, but the actual arguments are type _string_ and _const char *_.

Note, "fdsfaf" is always a C-style not string object.

So two things are going on here:

1. String class defines a char *-to-string conversion, which make it possible to ** initialize a string object to a C-style string like

	string greeting = "Hi";

2. Because of the property of const reference formal parameter, the type doesn't match but can be converted. Then the program **created a temporary string variable and converted the C-style string.**

   Thus, **a const string & type can hangdle a char * or const char * in this function.

The convenient outcome of this is that if the formal parameter is type const string &, the actual argument used in the function call can be a string object or a C-style string.

### Another Object Lesson: Objects, Inheritance, and References

You may have notice that the ofstream type can use ostream methods. The alnguage feature that makes it possible is _inheritance_. In this case

* _ostream_ is a _base class_;
* _ofstream_ is a derived class_

We say **a derived class inherits the base class methods**, which means that an ofstream object can use base class features such as precision() and setf() formating methods.

Another aspect of inheritance is that **a base class _references_ can refer to a derived class object without requiring a type cast**. (Because they have the same structure)

The pratical upshot of this is that you can define a function having a base class **reference parameter**(note must be reference), and that function can be used with base class objects and also with derived objects. 

For example, **a function with a type ostream & parameter can accept an ostream object, such as cout, or an ofstream object.**

Listing 8.8

	
In this example, we see os parameter, which is type ostream &, can refer to an ostream object such as cout and to an ofstream object such as fout. And methods can be used for both types.

#### Some Methods

* _setf()_ is a method of ostream class which allows you to set various _formatting states_. The method call _setf(ios_base::fixed) places an object in the mode of using _fixed decimal-point notation_ .
	
  Fixed are designed to specify mode to handle floating numbers. There are three mode:

  * Default(automaticly)
  * Fixed
  * Scientific

  And fixed mode always come along with a precision setting.

* setf(ios_base::showpoint) is also for floating types. It places an object in the mode of showing a trailing decimal point even if the following digits are zeros, like 
	
	19.

* **Providing the object is in _fixed_ mode, precision method can be used to specified the number of figures to be shown to the right of the decimal.

* The _width()_ calls sets _field width_ for the next output action. This setting holds for displaying one value only.

**Summary**: formatting regarding floating numbers holds forever, like setf(ios_base::fixed/showpoint), and precision. But width() holds for one display only.

The file_it() function uses an interseting pair of method call:

	ios_base::fmtflags initial;
	initial = os.setf(ios_base::fixed);
	...
	os.setf(initial);

The setf() method returns a copy of all the formatting settings in effect **before** the call is made. **ios_base::fmtflags is a name for the type needed to store this information.** Then it can be used as an argument to setf() to reset all formatting settings.

One final point: **each object stores its own formatting settings.** That's why we use _objectname.method()_

### When to Use Reference Arguments

There are two main reasons:

* To allow you to alter a data object in the calling funciton
* To speed up a program by passing a reference instead of an entire data object.

#### Making Choices

* Passing data without modification

	* Built-in data object is small, pass by value

	* Otherwise a const must be used

	  Array: const pointer

	  Good-sized structure: const pointer of reference

	  Class object: reference.

* A function modifies data in the calling function:

	* Built-in data: pointer **bacause this make the intention more clear**

	* Array: const pointer

	  Structure: reference of pointer

	  Class object: reference


So basically there are four cases: built-in, array, structure, class.

## Default Arguments

A _default argument is a **value** that's used automatically if you **omit the corresponding actual argument.

You MUST use the prototype to establish a default value. **The method is to assign a value to the argument like:

	char * left(const char * str, int n = 1);

You MUST add defaults from right to left. Prototypes like

	int harpo(int n, int m = 1, int p);

isn't allowed.

**Note call the omits the default argument is still an exact match**.

Listing 8.9 left.cpp

	#include <iostream>
	const int ARSIZE = 80;
	// Default argument
	char * left(const char * str, int n = 1);
	int main(void)
	{
	    // Always remember to using namespace std
	    using namespace std;
	    char sample[ARSIZE];
	    cout << "Enter a string:\n";
	    // Safe way to read entire line to a C-style string
	    cin.get(sample, ARSIZE);
	    char * ps = left(sample, 4);
	    cout << ps << endl;
	    // [] precedes variable name
	    delete [] ps;
	    ps = left(sample);
	    cout << ps << endl;
	    delete [] ps;
	    return 0;
	}

	char * left(const char * str, int n)
	{
	    if (n < 0)
	    {
	        n = 0;
	    }

	    char * p = new char[n+1];
	    int i;
	    for (i = 0; i < n && str[i]; i++)
	    {
	        p[i] = str[i];
	    }
	    while (i <= n)
	        p[i++] = '\0';
	    return p;
	}

Note in this program, we use _cin.get(sample, ARSIZE)_ to read a C-style string, which will discard the newline. Also we use _delete [] ps.

## Function Overloading

_Function polymorphism_, also called _function overloading_ lets you use multiple functions with the same name. _Polymorphism_ means having many forms.

**Function signature**: a function's argument list. If two functions use **the same number** and **same types** of arguements in the same order, they have the same signature.

The call of a function also has a **well-defined** signature. So it's easy to find the matching signature. For example:

	print("Pancakes", 15); // (const char *, int)
	printf(1999.0, 10); // (double, int)
	printf(1999L, 15); // (long, int);

Note: reference and normal variable cannot coexist. For example,

	double cube(double x);
	double cube(double & x);

may cause an error.

But const and non-const variable did make a difference. For example,

	double dribble(char * bits);
	void dribble(const char * bits);

is different. But this will only occur to references or pointers.

### Overloading Reference Parameters

There's a bit twists about reference parameters.

	void sink(double & r1); // matches modifiable lvalue;
	void sank(const double & r2); // matches const or modifiable lvalue, rvalue (there's priority)
	void sunk(double && r3); // matches rvalue

For const double & r2, both const lvalue, modifiable lvalue, rvalue **are exact math, but latter two have lower priority.** Exact match means the right basic type, only a matter of const or lvalue or rvalue.

### When to Use Function Overloading

You should reserve function overloading for functions that perform the basically the same task but with different forms of data.

Always use a default argument if possible.

### What is Name Decoration?

The compiler will encrypt function name based on the signature, which is known as name decoration.

## Function Templates

A _function templates_ is a generic function description. **It defines a function to handle a _generic type_, wherever this type appear in the function.

When **passing a type as a parameter** to a template, you cause the compiler to generate a function for the particular type. This process is sometimes called _generic programming_.

Basic syntax:

	template <typename Anytype> // Self-defined as template head
	void Swap(Anytype & a, AnyType &b)
	{
		AntType temp;
		temp = a;
		a = b;
		b = temp;
	}

Note the first line is **like a function header**, with name template, argument type _typename_ and <> instead of ().

That's why the book say template and typename are obligatory, because we can name those ourselves in function headers.

So a template defineition consists of:

	* Template header
	* Function description

The template doesn't create any function.

The use the template you just made a call. You can think it as two things happened:

1. We **pass the type** to the template and create a function
2. We call the function.

The keywords _template_ and _typename_ are obligatory, unlike in regular function we can choose as we like.

Listing 8.11

	#include <iostream>
	// Template header with space
	template <typename T>
	void Swap(T &a, T &b); // Prototype

	int main(void)
	{
	    // Because we are using cout
	    using namespace std;
	    int i = 10;
	    int j = 20;

	    cout << "i, j = " << i << ", " << j << ".\n";
	    cout << "Using compiler-generated int swapper:\n";
	    // Send signature (int, int) to template
	    Swap(i, j);
	    cout << "Now i, j = " << i << ", " << j << ".\n";

	    double x = 24.5;
	    double y = 81.7;
	    cout << "x, y = " << x << ", " << y << ".\n";
	    cout << "Using compiler-generated double swapper:\n";
	    // Send signature (int, int) to template
	    Swap(x, y);
	    cout << "Now x, y = " << x << ", " << y << ".\n";
	    return 0;
	}

	template <typename T>
	void Swap(T &a, T &b)
	{
	    T temp;
	    temp = a;
	    a = b;
	    b = temp;
	}

Note that function templates don't make executable programs any shorter. You still wind up with two separate function definitions. **And the final code doesn't contain any templates; it just contains the actual functions generated.**

### Overloaded Templates

Listing 8.12

	#include <iostream>
	template <typename T>
	void Swap(T &a, T &b);

	template <typename T>
	void Swap(T *a, T *b, int n);
	void Show(int a[]);
	const int LIM = 8;

	int main(void)
	{
	    // Because we're using cout
	    using namespace std;
	    int i = 10, j = 20;
	    cout << "i, j = " << i << ", " << j << ".\n";
	    cout << "Using compiler-generated int swapper:\n";
	    Swap(i, j);
	    cout << "Now i, j = " << i << ", " << j << ".\n";

	    int d1[LIM] = {0, 7, 0, 4, 1, 7, 7, 6};
	    int d2[LIM] = {0, 7, 2, 0, 1, 9, 6, 9};
	    cout << "Original arrays:\n";
	    Show(d1);
	    Show(d2);
	    Swap(d1, d2, LIM);
	    cout << "Swapped arrays:\n";
	    Show(d1);
	    Show(d2);

	    return 0;
	}

	template <typename T>
	void Swap(T &a, T &b)
	{
	    T temp;
	    temp = a;
	    a = b;
	    b = temp;
	}

	template <typename T>
	void Swap(T a[], T b[], int n)
	{
	    T temp;
	    for (int i = 0; i < n; i++)
	    {
	        temp = a[i];
	        a[i] = b[i];
	        b[i] = temp;
	    }
	}

	void Show(int a[])
	{
	    // We are using cout
	    using namespace std;
	    cout << a[0] << a[1] << "/";
	    cout << a[2] << a[3] << "/";
	    for (int i = 4; i < LIM; i++)
	        cout << a[i];
	    cout << endl;
	}

**The original template has the signature (T &, T &), whereas the new template has the signature (T [], T [], int);**

### Explicit Specialization

In example above, we assumed operation

	temp = a;
	a = b;
	b = temp;

is defined.

Suppose you define a structure like the following:

	struct job
	{
		char name[40];
		double salary;
		int floor;
	};

You cannot use "=".

You can supply a specialized function definition, called _explicit specialization_. **If the compiler finds a specilized definition that exactly matches a funtion call, it uses that defintion without looking for templates.**

An explicit specialization for the job type:

	template <> void Swap<job>(job &, job &);

Or

	template <> void Swap(job &, job &);

Where <job> is omitted.

In the following code, the first call uses the general template, and the second call uses the explicit specialization:

	...
	template <class T>
	void Swap(T &, T &);

	template <> void Swap<job>(job &, job &);
	int main(void)
	{
		double u, v;
		...
		Swap(u, v);
		job a, b;
		...
		Swap(a, b);
	}

Note you must precede a specialization with _template <>_, but you can omit <job> following Swap.

Like a template, an explicit specializtion needs a prototype and a definition.

### Initializations and Specilizations

When the compiler uses the template to generate a function definition for a particular type, the result is termed an _instantiation_ of the template.

Calling a function is called _implicit instantiation_.

You can create an _explicit instantiation_ by the following declaration:

	template void Swap<int>(int, int);

Contrast the explicit instantiation and explicit specialization, which uses declarations:

	template <> void Swap<int>(int &, int &);
	template <> void Swap(int &, int &);

The differences the last two means "**Don't use the Swap() template to generate a function definition**. Instead, use a separate, specialized function definition explicitly defined for the int type." **And explicit specialization prototype have to be coupled with their own definitions.**

**Explicit specialization did created a function definition, so it's an error to use another explicit instantiation.**

Another difference is one uses <> after template whereas the other omits it.

> **Caution**

> It's an error to try to use both an explicit instantiation and an explicit specialization for the same type in the same translation unit.

Explicit instantiation can also be created by using the function in a program like:

	Add<double>(x, m);

**The template would fail to match the function call Add(x, m) because the template expects both arguments to be same. But using Add<double>(x, m) forces the type double instantiation, and there's type cast.

Implicit instantiations, explicit instantiations, and explicit specializations collectively are termed _specilizations_. What they have in common is that they represent a function defintion that uses specific types rather that one that is a generic description.

### More twists on Explicit Specialization and Instantiation

Specialization is part of template defintion, **it specifies something.** But explicit instantiation is just a declaration of "using something".

## Which Function Version Does the Compiler Pick?

The process is called _overload resolution_.

* Phase 1: Assemble a list of function having the same name.

* Phase 2: Assemble a list of function having compatible signature (probably need some conversion)

* Phase 3: 
	
	* Exact match: of the same basic type and allows "trivial conversions"

	  Type to const Type
	  Type to const Type &;  
	  Type* to const Type*

	  and there is descriminations between const and non-const to data refererences and pointers. But for regular type and const type there's not such descrimination.

	  When two templates are exact match, we apply the _partial ordering rules._ That is template with more "basic" T will be chosen.


### Making Your Own Choices

You can lead the compiler to make the choice you want by suitably writing the function call.

	#include <iostream>

	template <class T>
	T lesser(T a, T b)
	{
	    return a < b ? a : b;
	}

	int lesser(int a, int b)
	{
	    a = a < 0 ? -a : a;
	    b = b < 0 ? -b : b;
	    return a < b ? a : b;
	}

	int main(void)
	{
	    using namespace std;
	    int m = 20;
	    int n = -30;
	    double x = 15.5;
	    double y = 25.9;

	    cout << lesser(m, n) << endl;
	    cout << lesser(x, y) << endl;
	    cout << lesser<>(m, n) << endl;
	    cout << lesser<int>(x, y) << end;

	    return 0;
	}

The angle brackets in lesser<>(m, n) indicates that the compiler should choose a template function. And lesser<int>(x, y) is a request for an explicit instantiation using int for T.

### Template Funcion Evolution

	?type? xpy = x + y;

The type of xpy is unknown. C++11 solution is a new keyword: decltype. It can be use this way:

	int x;
	decltype(x) y;

Then you can

	decltype(x + y) xpy = x + y;

The one in the parenthesis can be expression, function, variable.

() means reference.

## Chpater Review

















