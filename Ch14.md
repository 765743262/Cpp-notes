# Chapter 14 Reusing Code in C++

In this chapter you'll learn about the following:

* _Has-a_ realtionships
* Classes with member objects (containment)
* The `valarray` template class
* Private and protected inheritance
* Multiple inheritance
* Virtual base classes
* Creating class templates
* Using class templates
* Template specializations

One of the main goals of C++ is to facilitate the reuse of code. One technique is to use class members that are themselves objects of another class. This is referred to as **containment** or **composition** or **layering**. Another option is to use private or protected inheritance. Containment, private inheritance, and protected inheritance are typically used to implement **has-a** relationships.
## Classes with Object Members

What is a student? We give a definition: someone with an identifying name and a set of quiz scores. 

Both members can be implemented with a class object that is defined yourself or the standard library class.

### The `valarray` Class: A Quick Look

The `valarray` class is supported by the `valarray` header file. As its name suggests, the class is targeted to deal with numeric values, so it supports operations such as summing the contents and finding the largest and smallest values in an array.

`valarray` is defined as a template class. The template aspect means you have to provide a specific type when declaring an object. To do so when declaring an object, you follow the identifier `valarray` with angle brackets that contain the desired type:

```C++
valarray<int> q_values;		// an array of int
valarray<double> weights;	// an array of double
```

The class aspect means that to use `valarray` object, you need to know something about class constructors and other class methods. Here are some examples:

```C++
double gpa[5] = {3.1, 3.5, 3.8. 2.9. 3.3};
valarray<double> v1; 			// an array of double, size 0
valarray<int> v2(8);			// an array of 8 int elements
valarray<int> v3(10, 8);		// an array of 8 int elements, each set to 10
valarray<double> v4(gpa, 4);	// an array of 4 elements, initialized to the first 4 elements of gpa
```

As you can see, you can

* Create an empty array of zero size
* An empty array of a given size
* An array with all elements initialized to the same value
* An array initialized using the values from an ordinary array.

With C++11, you also can use an initializer list:

```C++
valarray<int> v5 = {20, 32, 17, 9};		// C++11
```

Here are a few of the methods:

* The `operator[] ()` method provides access to individual elements
* The `size()` method returns the number of elements
* The `sum()` method returns the sum of the elements
* The `max()` method returns the largest element
* The `min()` method returns the smallest element.

### The `Student` Class Design

At this point, the design plan for the `Student` class is to use a `string` object to represent the name and a `valarray<double>` object to represent the quiz scores. What you have here is a `has-a` relationship, and the usual C++ technique for modeling _has-a_ relationships is to use composition or containment. For example, you can begin a `Student` class declaration like this:

```C++
class Student
{
private:
	string name;				// use a string object for name
	valarray<double> scores;	// use a valarray<double> object for scores
	...
};
```

As usual, the class makes the data members private. This implies that the `Student` class member functions can use the public interfaces of the `string` and `valarray<double>` classes to access and modify the `name` and `scores` object, but the outside world cannot do so. The only access the outside world will have to `name` and `scores` is through the **public interface defined for the `Student` class**.

> **Interfaces and Implementations**

> With public interface, a class inherits an interface, and perhaps, an implementation. (Pure virtual functions in a base class can provide an interface without an implementation.) With composition, a class acquires the implementation without the interface. Not inheriting the interface is part of the _has-a_ relationship.

### The `Student` Class Example

Listing 14.1 defines several constructors and provides a few functions to provide an interface for the `Student` class. It also supplies some friends for input and output.

```C++
// Listing 14.1
#ifndef TEST_HPP_
#define TEST_HPP_

#include <iostream>
#include <string>
#include <valarray>
class Student
{
private:
	typedef std::valarray<double> ArrayDb;
	std::string name;	// contained object
	ArrayDb scores;		// contained object
	// private method for scores output
	std::ostream & arr_out(std::ostream & os) const;
public:
	Student() : name("Null Student"), scores() {}
	explicit Student(const std::string & s)
		: name(s), scores() {}
	explicit Student(int n) : name("Nully"), scores(n) {}
	Student(const std::string & s, int n)
		: name(s), scores(n) {}
	Student(const std::string & s, const ArrayDb & a)
		: name(s), scores(a) {}
	~Student() {}
	double Average() const;
	const std::string & Name() const;
	double & operator[](int i);
	double operator[](int i) const;
// friends
	// input
	friend std::istream & operator>>(std::istream & is,
									 Student & stu);  // 1 word
	friend std::istream & getline(std::istream & is,
								  Student & stu);    // 1 line
	// output
	friend std::ostream & operator<<(std::ostream & os,
									 const Student & stu);
};

#endif
```

In order to simplify notation, the `Student` class contains this `typedef`:

```C++
typedef std::valarray<double> ArrayDb;
```

This enables the remaining code to use the more convenient notation. Placing this `typedef` in the private portion of the class definition means that it can be use internally in the `Student` implementation but not by outside users of the `Student` class.

Note the use of the keyword `explicit`:

```C++
explicit Student(const std::string & s) 
	: name(s), scores() {}
explicti Student(int n) : name("Nully"), scores(n) {}
```

Recall that a constructor that can be called with one argument serves as an implicit converions function from the argument type to the class type. The second constructor, for instance, allows `int`-to-`Student` conversion, which does not make sense. Using `explicit` turns off implicit conversions.


#### Initializing Contained Objects

Note that constructors all use the by-now-familiar member initializer list syntax to initialize the `name` and `scores` member objects. Constructors from previous examples, such as the following, use a member initializer list to initialize the base-class portion of a derived object:

```C++
hasDMA::hasDMA(const hasDMA & hs) : baseDMA(hs) {...}
```

For _inherited_ objects, construcotors use the _class_ name in the member initializer list to invoke a specific base-class constructor. For _member_ objects, constructors use the _member_ name. For example, look at the last constructor in Listing 14.1:

```C++
Student(const char * str, const double * pd, int n) 
	: name(str), scores(pd, n) {}
```

Here, this constructor ues the member names, not the class names. Each item in this initialization list **invokes the matching constructor**. For example, `scores(pd, n)` invokes the `ArrayDb(const double *, int)` constructor.

As with inherited components, C++ requires that all member objects be constructed **before** the rest of an object is constructed. So if you omit the initialization list, C++ uses the **default constructors** defined for the member objects classes.

> **Initialization Order**

> When you have a member initializer list that initializes more than one item, the items are initialized in the order **in which they were declared**, not in the order in which they appear in the initializer list. For example, suppose you write a `Student` constructor this way:

```C++
Student(const char * str, const double * pd, int n) 
	: scores(pd, n), name(str) {}
```

The `name` member would still be intialized first because it is declared in the class definition.

#### Using an Interface for a Contained Object

The interface for a contained class isn't public, but it can be used within the class methods. For example, here is how you can define a function that returns the average of a student's scores:

```C++
double Student::Average() const
{
	if (scores.size() > 0)
		return scores.sum() / scores.size();
	else
		return 0;
}
```

Because `scores` is a `valarray` object, it can invoke the member funcions of the `valarray` class. In short, the `Student` object invokes a `Student` method, and the `Student` method uses the contained `valarray` object to invoke `valarray` methods.

Similarly, you can define a friend funciton that uses the `string` version of the `<<` operator:

```C++
ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << stu.name << ":\n";
	...
}
```

Because `stu.name` is a `string` object, it invokes the `operator<<(ostream &, const string &)` function, which is provided as part of the `string` class package. Note that the `operator<<(ostream & os, const Student & stu)` function has to be a friend to the `Student` class so that is can access the `name` member.

Similarly, the function could use the `valarray` implementation of `<<` for output; unfortunately, there is noe. Therefore, the class defines a private helper method to handle this task:

```C++
// private method
ostream & Student::arr_otu(ostream & os) const
{
	int i;
	int lim = scores.size()
	if (lim > 0)
	{
		for (i = 0; i < lim; i++)
		{
			os << scores[i] << " ";
			if (i % 5 == 4)
				os << std::endl;
		}
		if (i % 5)
			os << std::endl;
	}
	else
		os << " empty array ";
	return os;
}
```

Using a helper like this gathers the messy details together in one place and makes the coding of the friend function neater:

```
// use string version of operator<<()
std::ostream & operator<<(std::ostream & os, const Student & stu)
{
	os << "Scores for " << stu.name << ":\n";
	stu.arr_out(os);	// use private method for scores
	return os;
}
```

Listing 14.2 shows the class methods for the `Student` class. It includes methods that allow you to use the `[]` operator to access individual scores in a `Student` object.


```C++
// Listing 14.2
#include "test.hpp"

using std::ostream;
using std::endl;
using std::istream;
using std::string;

// public methods
double Student::Average() const
{
	if (scores.size() > 0)
		return scores.sum() / scores.size();
	else
		return 0;
}

const string & Student::Name() const
{
	return name;
}

double & Student::operator[](int i)
{
	return scores[i];
}

double Student::operator[](int i) const
{
	return scores[i];
}

// private method
ostream & Student::arr_out(ostream & os) const
{
	int i;
	int lim = scores.size();
	if (lim > 0)
	{
		for (i = 0; i < lim; i++)
		{
			os << scores[i] << " ";
			if (i % 5 == 4)
				os << endl;
		}
		if (i % 5)
			os << endl;
	}
	else
		os << " empty array ";
	return os;
}

// friends
// use string version of operator>>()
istream & operator>>(istream & is, Student & stu)
{
	is >> stu.name;
	return is;
}

// use string friend getline(ostream &, const string &)
istream & getline(istream & is, Student & stu)
{
	getline(is, stu.name);
	return is;
}

// use string version of operator<<()
ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << stu.name << ":\n";
	stu.arr_out(os);	// use private method for scores
	return os;
}
```

Note how this implementation implements the `[]` operator and `getline` friend for `Student` Class.

#### Using the New `Student` Class

Listint 14.3 presents the test program.

```C++
#include <iostream>
#include "test.hpp"
using std::cin;
using std::cout;
using std::endl;

void set(Student & sa, int n);
const int PUPILS = 3;
const int QUIZZES = 5;

int main(void)
{
	Student ada[PUPILS] =
		{ Student(QUIZZES), Student(QUIZZES), Student(QUIZZES)};
	for (int i = 0; i < PUPILS; i++)
		set(ada[i], QUIZZES);
	cout << "\nStudent List:\n";
	for (int i = 0; i < PUPILS; i++)
		cout << ada[i].Name() << endl;
	cout << "\nResults:";
	for (int i = 0; i < PUPILS; i++)
	{
		cout << endl << ada[i];
		cout << "average: " << ada[i].Average() << endl;
	}
	cout << "Done.\n";
	return 0;
}

void set(Student & sa, int n)
{
	cout << "Please enter the student's name: ";
	getline(cin, sa);
	cout << "Please enter " << n << " quiz scores:\n";
	for (int i = 0; i < n; i++)
		cin >> sa[i];
	while (cin.get() != '\n')
		continue;
}

```

## Private Inheritance

_Private inheritance_ is a second means of implementing the _has-a_ relationship. With _private inheritance_, **public and protected members of the base class become private members of the derived class.** This means the methods of the base class do not become part of the public interface of the derived object. The can be used, however, inside the member functions of the derived class.

With private inheritance, a class does inherit the implementation. For example, if you base a `Student` class on a `string` class, the `Student` class winds up with an inherited `string` class component that can used to store a string. Furthermore, the `Student` methods can use the `string` methods internally to access the `string` component.

Containment adds an object to a class as a named member object, whereas private inheritance adds an object to a class as an unnamed inherited object. This book uses the term _subobject_ to denote an object added by inheritance or by containment.

Private inheritance, then, provides the same features as containment: Acquire the implementation, dont't acquire the interface. Therefore it, too, can be used to implement a **has-a** relationship. You can produce a `Student` class that uses private inheritance and has the same public interface as the containment version. **Thus the difference between the two approaches affect the implementation, not the interface**.

### A New Version of the `Student` Class Example

To get private inheritance, use the keyword `private` instead of `public` when defining the class. (Actually, **private is the default**, so omitting an access qulifier also leads to private inheritance) The `Student` class should inherit from two classes, so the declaration should list both:

```C++
class Student : private std::string, private std::valarray<double>
{
public:
	...
};
```

Having more than one base class is called _multiple inheritance_ (MI).

Note that the new class doesn't need private data. The containment version of of this example provides two explicitly named objects as members. Private inheritance however, provides two **nameless subobjects as inherited members**. 

#### Initializing Base-Class Components

You can no longer use `name` and `scores` to describe the objects. Instead, you have to go back to the techniques you used for public inheritance. For example, consider constructors. Containment uses this constructor:

```C++
Student(const char * str, const double * pd, int n)
	: name(str), scores(pd, n) {}	// use object names for containment
```

The new version should use the member initializer list syntax for inherited classes, which uses the _class_ name instead of a _member_ name to identify a constructor:

```C++
Student(const char * str, const double * pd, int n) : std::string(str), ArrayDb(pd, n) {}	// use class names for inheritance
```


Listing 14.4 shows the new class declaration. The only changes are the omission of explicit object names and the use of class names instead of member names in the inline constructors.

```C++
// Listing 14.4
#ifndef TEST_HPP_
#define TEST_HPP_

#include <iostream>
#include <string>
#include <valarray>
class Student : private std::string, private std::valarray<double>
{
private:
	typedef std::valarray<double> ArrayDb;
	
	// private method for scores output
	std::ostream & arr_out(std::ostream & os) const;
public:
	Student() : std::string("Null Student"), ArrayDb() {}
	explicit Student(const std::string & s)
		: std::string(s), ArrayDb() {}
	explicit Student(int n) : std::string("Nully"), ArrayDb(n) {}
	Student(const std::string & s, int n)
		: std::string(s), ArrayDb(n) {}
	Student(const std::string & s, const ArrayDb & a)
		: std::string(s), ArrayDb(a) {}
	~Student() {}
	double Average() const;
	const std::string & Name() const;
	double & operator[](int i);
	double operator[](int i) const;
// friends
	// input
	friend std::istream & operator>>(std::istream & is,
									 Student & stu);  // 1 word
	friend std::istream & getline(std::istream & is,
								  Student & stu);    // 1 line
	// output
	friend std::ostream & operator<<(std::ostream & os,
									 const Student & stu);
};

#endif

```

#### Accessing Base-Class Methods

Private inheritance limits the use of base-class methods to within derived-class methods. Sometimes, however, you might like to make a base-class facility available publicly. For example, the `Student` class declaration suggests the ability to use an `Average()` functinos. As with containment, the technique for doing this is to use the `valarray` `size()` and `sum()` methods within a public `Student::Averga()` function. Containment invoked the methods with an object:

```C++
double Student::Average() const
{
	if (scores.size() > 0)
		return scores.sum() / scores.size();
	else
		return 0.0;
}
```


However, inheritance lets you use the **class name** and the **scope-resolution** operator to invoke base-class methods:

```C++
double Student::Average() const
{
	if (ArrayDb::size() > 0)
		return ArrayDb::sum() / ArrayDb::size();
	else
		return 0;
}
```

In short, the containment approach uses object names to invoke a method, whereas private inheritance uses the class name and the scope-resolutino operator instead.

#### Accessing Base-Class Objects

The scope-resolution operator allows you access to a base-class method, but what if you need the base-class object itself? For example, the containment version of the `Student` class implements the `Name()` method by having the method return the `name` member `string` object. But with private inheritance, the `string` object **has no name**. How, then, can `Student` code access the inner `string` object?

The answer is to use a type cast. Because `Student` is derived from `string`, it's possible to type cast a `Student` object to a `string` object. Recall that the `this` pointer points to the invoking object, so `*this` is the invoking object---in this case, a type `Student` object. **Use a type cast to create a reference avoids invoking constructors:**

```C++
const string & Student::Name() const
{
	return (const string &) *this;
}
```

This code returns a reference to the **inherited `string` object** residing in the invoking `Student` object.

#### Accessing Base-Class Friends

The technique of explicitly qualifying a functino name with its class name does **not** work for friend functions because a friend function **doesn't belong to a class**. However, you can use an explicit type cast to the base class to invoke the correct functions. This is basically the same technique used to access a base-class object in a class method, but with friends you have a name for the `Student` object, so the code **uses the name instead of `*this`**. For example, consider the following friend function definition:

```C++
ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << (const String &) stu << ":\n";
...
}
```

Consider the following line of code:

```C++
os << "Scores for " << (const String &) stu << ":\n";
```

The typecase explicitly converts `stu` to a reference to a type `string` object; that type, in turn, invokes the `operator<<(ostream &, const String &)` function. Without this type cast, this will, again, becomes a recursive function.

The reference doesn't get converted automatically to a `string` reference. The fundamental reason is that with private inheritance, a reference or pointer to a base class cannot be assigned a reference or pointer to a derived class without an explicit type cast. Otherwise, **it will be possible for the outside world to use private methods.**.

However, even if the example used public inheritance, it would have to use explicit type casts. Without a type cast, code like the following matches the friend function prototype, leading to a recursive call:

```C++
os << stu;
```

A second reason is that because the class uses MI, the compiler can't tell which base class to convert to if both base classes happen to provide an `operator<<()` function. 

Listing 14.5 shows all the `Student` class methods, other than those defined inline in the class declaration.


```C++
// Listing 14.5
#include "test.hpp"

using std::ostream;
using std::endl;
using std::istream;
using std::string;

// public methods
double Student::Average() const
{
	if (ArrayDb::size() > 0)
		return ArrayDb::sum() / ArrayDb::size();
	else
		return 0;
}

const string & Student::Name() const
{
	return (const string &) *this;
}

double & Student::operator[](int i)
{
	return ArrayDb::operator[](i);	// use ArrayDb::operator[]()
}

double Student::operator[](int i) const
{
	return ArrayDb::operator[](i);
}

// private method
ostream & Student::arr_out(ostream & os) const
{
	int i;
	int lim = ArrayDb::size();
	if (lim > 0)
	{
		for (i = 0; i < lim; i++)
		{
			os << ArrayDb::operator[](i) << " ";
			if (i % 5 == 4)
				os << endl;
		}
		if (i % 5 != 0)
			os << endl;
	}
	else
		os << " empty array ";
	return os;
}

// friends
// use String version of operator>>()
istream & operator>>(istream & is, Student & stu)
{
	is >> (string &) stu;
	return is;
}

// use string friend getline(ostream &, const string &)
istream & getline(istream & is, Student & stu)
{
    getline(is, (string &)stu);
    return is;
}

// use string version of operator<<()
ostream & operator<<(ostream & os, const Student & stu)
{
	os << "Scores for " << (const string &) stu << ":\n";
	stu.arr_out(os);	// use private method for scores
	return os;
}

```

#### Using the Revised `Student` Class

Because both approaches have the same interface, you can test the two verions with exactly the same program.

### Containment or Private Inheritance?

Given that you can model a _has-a_ relationship either with containment or with private inheritance, which should you use? Most C++ programmers prefer containment. First, it's easier to follow. When you look at the class declaration, you see explicitly named objects representing the contained classes, and your code can refer to these objects by name. Second, inheritance can raise problems, particularly if a class inherits from more than one base class. You may have to deal with issues such as separate base classes having methods with the same name or of separate base classes sharing a common ancestor. All in all, you're less likely to run into trouble using containment. Also containment allows you to include **more than one subobject** of the same class. If a class needs three `string` objects, you can declare three seperate `string` members by using the containment approach. But inheritance limits you to a single object. (It is difficult to tell objects apart when they are all nameless)

However, private inheritance does offer features beyond those provided by containment. Suppose, for example, that a class has protected members, which could either by data members or member functions. Such members are available to derived classes **but not to the world at large**. If you include such a class in another class by using composition, the new class is part of the world at large, not a derived class. Hence it can't access protected member.

Another situation that calls for using private inheritance is if you want to redefine virtual functions. However, with private inheritance, the redefined functions would be usable just within the class, not publicly.

> **Tip**

> In general, you should use containment to model a _has-a_ relationship. You should use private inheritance if the new class needs to access protected members in the original class or if it needs to redefine virtual functions.

### Protected Inheritance

Protected inheritance is a variation on private inheritance. It uses the keyword `protected` when listing a base class:

```C++
class Student : protected std::string, 
				protected std::valarray<double>
{...};
```

With protected inheritance, public and protected members of a base class become protected members of the derived class. As with private inheritance, the interface for the base class is available to the derived class but not the outside world. The main difference between private and protected inheritance occurs **when you derive another class from the derived class.** 

Table 14.1 summarizes public, private, and protected inheritance. The term _implicit upcasting_ means that you can have a base-class pointer or reference refer to a derived class object without using an explicit type cast:

See Page 807.

### Redefining Access with `using`

Suppose you want to make a particular base-class method available publicly in the derived class. One option is to redefine a derived-class method that uses the base-class method in the public section:

```C++
double Student::sum() const
{
	return std::valarray<double>::sum();
}
```

Then a `Student` object can invoke `Student::sum()`. 

There is an alternative to wrapping one function call in another: use a `using` declaration to announce that a particular base-class member can be used by the derived class, even though the derivation is private. For example, suppose you want to be able to use the `valarray` `min()` and `max()` with the `Student` class. In this case, you can add `using` declarations to the public section:

```C++
class Student : private std::string, private std::valarray<double>
{
...
public:
	using std::valarray<double>::min;
	using std::valarray<double>::max;
	...
};
```

The using declaration makes the `valarray<double>::min()` and `valarray<double>::max()` methods available as if they were public `Student` methods:

```C++
cout << "high scores: " << ada[i].max() << endl;
```

Note that the `using` declaration just uses the member name, **no parentheses, no function signatures, no return types**. If you use the following declaration:

```C++
using std::valarray<double>::operator[];
```

**This would make both versions (`const` and non-`const`) available.** The using declaration approach works only for inheritance and not for containment.

## Multiple Inheritance

MI describes a class that has more than one **immediate** base class. As with single inheritance, public MI should express an _is-a_ relationship. For example, if you have a `Waiter` class and a `Singer` class, you could derive a `SingingWaiter` class from the two:

```C++
class SingingWaiter : public Waiter, public Singer {...};
```

Note that you must qualify each base class with the keyword `public`. That's because the compiler **assumes private derivation unless instructed otherwise**:

```C++
class SingingWaiter : public Waiter, Singer {...};	// singer is a private base
```

As discussed earlier in this chapter, private and protected MI can express a _has-a_ relationship. We'll concentrate on public inheritance now.


MI can introduce new problems for programmers. The two chief problems are inheriting different methods with the same name from two different base classes and inheriting multiple instances of a class via two or more related immediate base class. Solving these problems involves introducing a few new rules and syntax variations. Thus using MI can be more difficult and problem-prone than using single inheritance. 

Let's explore a particular example and see that the problems and solutions are. For this example, we'll define an abstract `Worker` base class and derive a `Waiter` class and a `Singer` class from it. Then we can use MI to derive a `SingingWaiter` class from the `Waiter` and `Singer` classes. This is a case in which a base class is inherited via two seperate derivations, which is the circumstance that causes the most difficulties with MI. We start with declarations for the `Worker`, `Waiter` and `Singer` classes, as shown in Listing 14.7.

Listing 14.7

```C++
#ifndef TEST_HPP_
#define TEST_HPP_

#include <string>

class Worker	// an abstract base class
{
public:
	Worker() : fullname("no one"), id(0L) {}
	Worker(const std::string & s, long n)
		: fullname(s), id(n) {}
	virtual ~Worker() = 0;	// pure virtual destructor
	virtual void Set();
	virtual void Show() const;
private:
	std::string fullname;
	long id;
};

class Waiter : public Worker
{
public:
	Waiter() : Worker(), panache(0) {}
	Waiter(const std::string & s, long n, int p = 0)
		: Worker(s, n), panache(p) {}
	Waiter(const Worker & wk, int p = 0)
		: Worker(wk), panache(p) {}
	void Set();
	void Show() const;
private:
	int panache;
};

class Singer : public Worker
{
public:
	Singer() : Worker(), voice(other) {}
	Singer(const std::string & s, long n, int v = other)
		: Worker(s, n), voice(v) {}
	Singer(const Worker & wk, int v = other)
		: Worker(wk), voice(v) { }
	void Set();
	void Show() const;
protected:
	enum {other, alto, contralto, soprano, bass, baritone, tenor};
	enum {Vtypes = 7};
private:
	const static char * pv[Vtypes];
	int voice;
};

#endif
```

An enumeration makes `alto`, `contralto`, and so on symbolic constants for voice types, and the static array `pv` holds pointers to the C-style string equivalents. The implementation file, shown in Listing 14.8, initializes this array and provides method definitions.

```C++
#include "test.hpp"
#include <iostream>
using std::cout;
using std::cin;
using std::endl;
// Worker methods

// must implement virtual destructor, even if pure
Worker::~Worker() {}

void Worker::Set()
{
	cout << "Enter worker's name: ";
	getline(cin, fullname);
	cout << "Enter worker's ID: ";
	cin >> id;
	while (cin.get() != '\n')
		continue;
}

void Worker::Show() const
{
	cout << "Name: " << fullname << "\n";
	cout << "Employee ID: " << id << "\n";
}

// Waiter methods
void Waiter::Set()
{
	Worker::Set();
	cout << "Enter waiter's panache rating: ";
	cin >> panache;
	while (cin.get() != '\n')
		continue;
}

void Waiter::Show() const
{
	cout << "Category: waiter\n";
	Worker::Show();
	cout << "Panache rating: " << panache << "\n";
}

// Singer methods

const char * Singer::pv[Singer::Vtypes] = {"other", "alto", "contralto",
	"soprano", "bass", "baritone", "tenor"};

void Singer::Set()
{
	Worker::Set();
	cout << "Enter number for singer's vocal range:\n";
	int i;
	for (i = 0; i < Vtypes; i++)
	{
		cout << i << ": " << pv[i] << "	  ";
		if (i % 4 == 3)
			cout << endl;
	}
	if (i % 4 != 0)
		cout << endl;
	while (cin >> voice && (voice < 0 || voice >= Vtypes))
		cout << "Please enter a value >= 0 and < " << Vtypes << endl;
	while (cin.get() != '\n')
		continue;
}

void Singer::Show() const
{
	cout << "Category: singer\n";
	Worker::Show();
	cout << "Vocal range: " << pv[voice] << endl;
}

```

Listing 14.9 provides a brief test of the classes, using a polymorphic array of pointers.

```C++
// Listng 14.9
#include <iostream>
#include "test.hpp"
const int LIM = 4;
int main(void)
{
	Waiter bob("Bob Apple", 314L, 5);
	Singer bev("Beverly Hills", 522L, 3);
	Waiter w_temp;
	Singer s_temp;

	Worker * pw[LIM] = {&bob, &bev, &w_temp, &s_temp};

	int i;
	for (i = 2; i < LIM; i++)
		pw[i]->Set();
	for (i = 0; i < LIM; i++)
	{
		pw[i]->Show();
		std::cout << std::endl;
	}

	return 0;
}
```

The design seems to work, with pointers to `Waiter` invoking `Waiter::Show()` and `Waiter::Set()` and pointers to `Singer` invoking `Singer::Show()` and `Singer::Set()`. However, it leads to some problems if you add a `SingingWaiter` class derived from both the `Singer` and `Waiter` class. In particular, you'll need to face the following:

* How many workers?
* Which method?

### How Many Workers

Suppose you begin by publicly deriviing `SingingWaiter` from `Singer` and `Watier`:

```C++
class SingingWaiter : public Singer, public Waiter {...};
```

Because both base classes inherit a `Worker` component, `SingingWaiter` **winds up with two `Worker` components**.

As you might expect, this raises problem. For example, ordinarily, you can assign the address of a derived-class object to a base-class pointer, but this becomes ambiguous now:

```C++
SingingWaiter ed;
Worker * pw = &ed;
```

Normally, such an assignment sets a base-class pointer to the address of the base-class object withing the derived object. But `ed` contains two `Worker` objects, so there are two addresses from which to choose. You could specify which object by using a type cast:

```C++
Worker * pw1 = (Waiter *) &ed;	// the Worker in Waiter
Worker * pw2 = (Singer *) &ed;	// the Worker in Singer
```

This certainly complicates the technique of using an array of base-class pointers to refer to a variety of objects (polymorphism).

The real issue is why you have two copies of a `Worker` object at all? A singing waiter, like any other worker, should have just one name and one ID. When C++ added MI to its bag of tricks, it added a virtual base class to make this possible.

#### Virtual Base Classes

Virtual base classes allow an object derived from multiple bases that themselves share a common base to inherit just one object of that shared base class.

For this example, you would **make `Worker` a virtual base class to** `Singer` and `Waiter` by using the keyword `virtual` in the class declarations (`virtual` and `public` can appear in either order):

```C++
class Singer : virtual public Worker {...};
class Waiter : public virtual Worker {...};
```

Then you would define `SingerWaiter` as before:

```C++
class SingingWaiter : public Singer, public Waiter {...}
```

Now a `SingingWaiter` object will contain a single copy of a `Worker` object. In essence, the inherited `Singer` and `Waiter` objects share a common `Worker` object instead of each bringing in its own copy. Because `SingingWaiter` now contains one `Worker` subobject, you can use polymorphism again.

Let's look at some questions you might have:

* Why the term `virtual`?
* Why don't we dispense with declaring base classes virtual and make virtual behviour the norm for MI?
* Are there any catches?

First, C++ merely recycled the keyword `virtual` for new new facility.

Next, why don't we dispense with declaring base classes virtual and make virtual the norm? First, there are cases in which you might want multiple copies of a base. Second, making a base class virtual requires that a program do some additional accounting, and you shouldn't pay for that facility if you don't need it. Third, there are disadvantages presented in the next paragraph.

Finally, are there catches? Yes. Making virtual base classes work requires adjustments to C++ rules, and you have to code some things differently. Also using virtual base classes may involve changing existing code.

#### New Constructor Rules

Having virtual base classes requires a new approach to class constructors. With **nonvirtual** base classes, the _only_ constructors that can appear in an initialization list are constructors for the **immediate** base classes. These constructors can, in turn, pass information on to their bases. For example, you can have the following organization of constructors:

```C++
class A
{
	int a;
public:
	A(int a = 0) : a(n) {} 
	...	
};

class B : public A
{
	int b;
public:
	B(int m = 0, int n = 0) : A(n), b(m) { }
	...
}
class C : public B
{
	int c;
public:
	C(int q = 0, int m = 0, int n = 0) : B(m, n), c(q) { }
	...
};
```

A `C` constructor can invoke **only** constructors from the `B` class, and a `B` constructor can invoke only constructors from the `A` class. Here the `C` constructor uses the `q` value and passes the values of `m` and `n` back to the `B` constructor. The `B` constructor uses the value of `m` and passes the value of `n` back to the `A` constructor.

The automatic passing of information does **not** work if `Worker` is a virtual base class. For example, consider the following possible constructor for the MI example:

```C++
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
	: Waiter(wk, p), Singer(wk, v)	{}	// flawed
```

The problem is that automatic passing of information would pass `wk` to the `Worker` object via two separate paths (`Waiter` and `Singer`). To avoid this potential conflict, C++ disables the automatic passing of information through an intermediate class to a base class **if** the bae class is virtual. Thus, the previous constructor will initialize the `panache` and `voice` member, but the information in the `wk` argument **won't** get to the `Waiter` subobject. However, the compiler must construct a base object component before constructing derived object; in this case, it will use the default `Worker` constructor.

If you want to use something other that the default constructor for a virtual base class, you need to **invoke the appropiate base constructor explicitly**. Thus, the constructor should look like this

```C++
SingingWaiter(const Worker & wk, int p = 0, int v = Singer::other)
	: Worker(wk), Waiter(wk, p), Singer(wk, v) { }
```

Here the code explicitly invokes the `Worker(const Worker &)` constructor. Note that this usage is legal and often necessary for virtual base classes, and it is illegal for **nonvitual base classes**.



> **Caution**

> If a class has an indirect virtual base class, a constructor for that class should explicitly invoke a constructor for the virtual base class unless all that is needed is the default constructor for the virtual base classes.

### Which Method?

In addition to introducing changes in class constructor rules, MI often requires other coding adjustments. Consider the problem of extending the `Show()` method to the `SingingWaiter` class. Suppose you do omit a new version of `Show()` and try to use a `SingingWaiter` object to invoke an inherited `Show()` method:

```C++
SingingWaiter newhire("Elise Hawks", 2005, 6, soprano);
newhire.Show();		// ambiguous
```

With single inheritance, failing to redefine `Show()` results in using the most recent ancestral definition. In this case, each indirect ancestor has a `Show()` function, which makes this call ambiguous.

> **Caution**

> Multiple Inheritance can result in ambiguous function calls.

You can use the scope-resolution operator to clarify what you mean:

```C++
SingingWaiter newhire("Elise Hawks", 2005, 6, soprano);
newhire.Singer::Show();	// use Singer version
```

A better approach is to redefine `Show()` for `SingingWaiter` to have it specify which `Show()` to use:

```C++
void SingingWaiter::Show()
{
	Singer::Show();
}
```

But if you want to add the `Waiter` component, it will cause problems. This calls `Worker::Show()` twice.

The solution is to provide a method that displays only `Worker` components, another method that displays only `Waiter` components, and another that displays only `Singer` components. Then the `SingingWaiter::Show()` method can put those components together. For example, you could use this:

```C++
void Worker::Data() const
{
	cout << "Name: " << fullname << "\n";
	cout << "Employee ID: " << id << "\n";
}

void Waiter::Data() const
{
	cout << "Panache rating: " << panache << "\n";
}

void Singer::Data() const
{
	cout << "Vocal range: " << pv[voice] << "\n";
}

void SingingWaiter::Data() const
{
	Singer::Data();
	Waiter::Data();
}

void SingingWaiter::Show() const
{
	cout << "Category: singing waiter\n";
	Worker::Data();
	Data();
}
```

Similarly, the other `Show()` methods would be built from the appropriate `Data()` components.

With this approach, objects would still use the `Show()` method publicly. The `Data()` methods, on the other hand, should be internal to the classes, and also helper methods used to facilitate the public interface. Here is just the kind of situation for which the protected access class is useful. If the `Data()` methods are protected, they can be used internally by all the classes in the hierarchy while being kept hidden from the outside world.

The `Set()` methods, which solicit data for setting object values, present a similar problem. The same solution used for `Show()` works.

In short, introducing MI with a shared ancestor requires introducing virtual base classes, altering the rules for constructor initialization lists, and possbly recoding the classes if they were writeen with MI in mind.

Listing 14.10 shows the modified class declarations with these changes institutes, and Listing 14.11 shows the implementation.


```C++
// Listing 14.10
#ifndef TEST_HPP_
#define TEST_HPP_

#include <string>

class Worker // an abstract base class
{
public:
	Worker() : fullname("no one"), id(0L) {}
	Worker(const std::string & s, long n)
		: fullname(s), id(n) {}
	virtual ~Worker() = 0;	// pure virtual function
	virtual void Set() = 0;
	virtual void Show() const = 0;
protected:
	virtual void Data() const;
	virtual void Get();
private:
	std::string fullname;
	long id;
};

class Waiter : virtual public Worker
{
public:
	Waiter() : Worker(), panache(0) {}
	Waiter(const std::string & s, long n, int p = 0)
		: Worker(s, n), panache(p) {}
	Waiter(const Worker & wk, int p = 0)
		: Worker(wk), panache(p) {}
	void Set();
	void Show() const;
protected:
	void Data() const;
	void Get();
private:
	int panache;
};

class Singer : virtual public Worker
{
public:
	Singer() : Worker(), voice(other) {}
	Singer(const std::string & s, long n, int v = other)
		: Worker(s, n), voice(v) {}
	Singer(const Worker & wk, int v = other)
		: Worker(wk), voice(v) {}
	void Set();
	void Show() const;
protected:
	enum {other, alto, contralto, soprano,
		bass, bartitone, tenor};
	enum {Vtypes = 7};
	void Data() const;
	void Get();
private:
	static const char * pv[Vtypes];
	int voice;
};

class SingingWaiter : public Singer, public Waiter
{
public:
	SingingWaiter() {}
	SingingWaiter(const std::string & s, long n, int p = 0,
				  int v = other)
		: Worker(s, n), Waiter(s, n, p), Singer(s, n, v) {}
	SingingWaiter(const Worker & wk, int p = 0, int v = other)
		: Worker(wk), Waiter(wk, p), Singer(wk, v) {}
	SingingWaiter(const Waiter & wt, int v = other)
		: Worker(wt), Waiter(wt), Singer(wt, v) {}
	SingingWaiter(const Singer & wt, int p = 0)
		: Worker(wt), Waiter(wt, p), Singer(wt) {}
	void Set();
	void Show() const;
protected:
	void Data() const;
	void Get();

};

#endif
```


```C++
// Listing 14.11
#include "test.hpp"
#include <iostream>

using std::cout;
using std::cin;
using std::endl;

// Worker methods
Worker::~Worker() {}

// protected methods
void Worker::Data() const
{
	cout << "Name: " << fullname << endl;
	cout << "Employee ID: " << id << endl;
}

void Worker::Get()
{
	getline(cin, fullname);
	cout << "Enter worker's ID: ";
	cin >> id;
	while (cin.get() != '\n')
		continue;
}

// Waiter methods
void Waiter::Set()
{
	cout << "Enter waiter's name: ";
	Worker::Get();
	Get();
}

void Waiter::Show() const
{
	cout << "Category: waiter\n";
	Worker::Data();
	Data();
}

// protected methods
void Waiter::Data() const
{
	cout << "Panache rating: " << panache << endl;
}

void Waiter::Get()
{
	cout << "Enter waiter's panache rating: ";
	cin >> panache;
	while (cin.get() != '\n')
		continue;
}

// Singer methods

const char * Singer::pv[Singer::Vtypes] = {"other", "alto", "contralto", "soprano", "bass", "baritone", "tenor"};

void Singer::Set()
{
	cout << "Enter singer's name: ";
	Worker::Get();
	Get();
}

void Singer::Show() const
{
	cout << "Category: singer\n";
	Worker::Data();
	Data();
}

// protected methods
void Singer::Data() const
{
	cout << "Vocal range: " << pv[voice] << endl;
}

void Singer::Get()
{
	cout << "Enter number for singer's vocal range:\n";
	int i;
	for (i = 0; i < Vtypes; i++)
	{
		cout << i << ": " << pv[i] << "   ";
		if (i % 4 == 3)
			cout << endl;
	}
	if (i % 4 != 0)
		cout << '\n';
	cin >> voice;
	while (cin.get() != '\n')
		continue;
}

// SingerWaiter methods
void SingingWaiter::Data() const
{
	Singer::Data();
	Waiter::Data();
}

void SingingWaiter::Get()
{
	Waiter::Get();
	Singer::Get();
}

void SingingWaiter::Set()
{
	cout << "Enter singing waiter's name: ";
	Worker::Get();
	Get();
}

void SingingWaiter::Show() const
{
	cout << "Category: singing waiter\n";
	Worker::Data();
	Data();
}

```

Listing 14.12 provides code to test these. The program uses the C-style `string` library function to test the input:

```C++
while (strchr("wstq", choice) == NULL)
```


```C++
// Listing 14.12
#include <iostream>
#include <cstring>
#include "test.hpp"

const int SIZE = 5;

int main(void)
{
	using std::cin;
	using std::cout;
	using std::endl;
	using std::strchr;

	Worker * lolas[SIZE];

	int ct;
	for (ct = 0; ct < SIZE; ct++)
	{
        char choice;
		cout << "Enter the employee category:\n"
			 << "w: waiter	s: singer	"
			 << "t: singing waiter	q: quit\n";
		cin >> choice;
		while (strchr("wstq", choice) == nullptr)
		{
			cout << "Please enter a w, s, t, or q: ";
			cin >> choice;
		}
		if (choice == 'q')
			break;
		switch (choice)
		{
			case 'w':
				lolas[ct] = new Waiter;
				break;
			case 's':
				lolas[ct] = new SingingWaiter;
				break;
			case 't':
				lolas[ct] = new SingingWaiter;
				break;
		}
		cin.get();
		lolas[ct]->Set();
	}

	cout << "\nHere is your staff:\n";
	for (int i = 0; i < ct; i++)
	{
		cout << endl;
		lolas[i]->Show();
	}
	for (int i = 0; i < ct; i++)
		delete lolas[i];
	cout << "Bye.\n";
	return 0;
}

```

#### Mixed Virtual and Nonvirtual Bases

Let's consider the case of a derived class that inherits a base class by more than one route. For example, that class `B` is a virtual base class to classes `C` and `D` and a nonvirtual base class to classes `X` and `Y`. Furthermore, suppose class `M` is derived from `C`, `D`, `X` and `Y`. In this case, class `M` contains one class `B` subobject for all the virtually derived ancestors (that is, classes `C` and `D`) and a separate class `B` subject for each nonvirtual ancester (that is, classes `X` and `Y`). So, all told, it would contain three class `B` subobjects. 

This is, when a class inherits a particular base class through several paths and several non-virtual paths, the class has one base-class subobject to represent all the virtual paths and a separate base-class subobject to represent each nonvirtual path.

#### Virtual Base Classes and Dominance

Using virtual base classes alters how C++ resolve ambiguities. With **nonvirtual** base classes, the rules are simple. If a class inherits two or more members (data or methods) with the same name from different classes, using that name without qualifying it with a class name is ambiguous. If virtual base classes are involved, however, such a use **may or may not** be ambiguous. In this case, if one name _dominates_ all others, it can be used unambiguously without a qualifier. 

A name in a derived class dominates the same name in any ancestor class, whether direct or indirect. For example, consider the following definitions:

```C++
class B
{
public:
	short q();
	...
};

class C : virtual public B
{
public:
	long q();
	int omg();
	...
};

class D : public C
{
	...
};

class E : virtual public B
{
private:
	int omg();
	...
};

class F : public D, public E
{
	...
};
```

Here the definition of `q()` in class C dominates the definition in class `B` because `C` is derived from `B`. Thus, methods in `F` can use `q()` to denote `C::q()`. On the other hand, netther definition of `omg()` dominates the other because neither `C` nor `E` is a base class to the other. 

**But with nonvirtual base class, this is ambiguous. If you don't understand this, refers to "Dominance" Wiki in Wikipedia.**

An attempt by `F` to use an unqualified `omg()` would be ambiguous.

**The virtual ambiguity rules pay no attention to access rules.** That is, even though `E::omg` is private and hence not directly accessible to class `F`, using `omg()` is ambiguous. Similarly, even if `C::q()` were private, it would dominate `D::q()`. In that case, you could call `B::q()` in class F, but an unqualified `q()` for that would refer to the inaccessible `C::q()`.

**So even though there may be another path to the base-class method, because it's dominated, there is no ambiguity.** But in nonvirtual cases, another path means ambiguity.

### Multiple Inheritance Synopsis

First, let's review MI without virtual base classes. This form of MI imposes no new rules. However, if a class inherits two members with the same name but from different classes, you need to use class qualifiers in the derived class to distinguish between the two members. That is, methods in the `BadDude` class, derived from `Gunslinger` and `PokerPlayer`, would use `Gunslinger::draw` and `PokerPlayer::draw` to distinguish between `draw()` methods inherited from the two classes. Otherwise, the compiler should complain about ambiguous usage.

If one class inherits from a nonvirtual base class by more than one route, then the class inherits one base-class object for each nonvirtual instance of the base class. In some cases, this may be what you want. But more often, multiple instances of a base class are a problem.

Next, let's look at MI with virtual base classes. A class becomes a virtual base class when a derived class uses the keyword `virtual` when indicating derivation:

```C++
class marketing : public virtual reality { ... };
```

The main change, and the reason for virtual base classes, it that a class that inherits from one or more instances of a virtual base class inherits just one base-class object. Implementing this feature entails other requirements:

* A derived class with an indirect virtual base class should have its constructors invoke the indirect base-class constructor directly, **which is illegal for indirect non-virtual base classes**.
* **Name ambiguity is resolved via the dominance rule.**

As you can see, MI can introduce programming complexities. However, most of these complexities arise when a derived class inherits from the same base class by more than one route. If you avoid that situation, about the only thing you need to watch for is qualifying inherited names when necessary.

## Class Templates

Inheritance (public, private, or protected) and containment aren't always the solution when you want to reuse code. Consider, for example, the `Stack` class from Chapter 10 and the `Queue` class from Chapter 12. These are examples of **container classes**, which are classes designed to hold other objects or data types. It would be nice if you could define a staic in a generic (that is, type-independent) fashion and then provide a specific type as a parameter to the class.

In Chapter 10, the `Stack` example uses `typedef` as a first pass at dealing with this desire. However, that approach has a couple drawbacks. First, you have to edit the header file each time you chagne the type. Second, you can use the technique to generate just one kind of stack per program. That is, you can't have a `typedef` represent two different types simultaneously.

C++'s class templates provide a better way to generate generic class declarations. Templates provide _parameterized_ types. For example, by feeding the type name `int` to a `Queue` template, you can get the compiler to construct a `Queue` class for queuing `int`s.

### Defining a Class Template

Let's use the `Stack` class from Chapter 10 as a model from which to build a template. Here's the original class declaration:

```C++
typedef unsigned long Item;

class Stack
{
public:
	Stack();
	bool isempty() const;
	bool isfull() const;
	bool push(const Item & item);
	bool pop(Item & item);
private:
	enum {MAX = 10};
	Item items[MAX];
	int top;
};
```

The template approach will replace the `Stack` definition with a template definition and the `Stack` member functions with template member functions. As with template functions, you preface a template class with code that has the following form:

```C++
template <class Type>
```

When a template is invoked, `Type` will be replaced with a specific type, such as `int` or `string`. Within the template definition, you can use the generic type name to identify the type to be stored in the stack. For the `Stack` case, that would mean using `Type` whenever the old declaration formerly used the `typedef` identifier `Item`. For example,

```C++
Item items[MAX];
```

bcomes the following:

```C++
Type items[MAX];
```

Similarly, you can replace the class methods of the original class with template member functions, Each function heading will be prefaced with the same template annoucement:

```C++
template <class Type>
```

Again, you should replace the `typedef` identifier `Item` with the generic type name `Type`. One more change is that you need to change the class qualifier from `Stack::` to `Stack<Type>::`. For example,

```C++
bool Stack::push(const Item & item)
{
	...
}
```

becomes the following+

```C++
template <class Type>
bool Stack<Type>::push(const Type & item)
{
	...
}
```

If you define a methods within the class declaration (an inline definition), you can omit the template preface and the class qualifier.

Listing 14.13 shows the combined class and member function templates. It's important to realize that these templates are not class and member definitions. Rather, they are instructions to the C++ compiler about how to generate class and member function definitions. Placing the template member function in a separate implementation file **won't** work. Because templates aren't functions, they can't be compiled separately. Templates have to be used in conjunction with requests for particular instantiations of templates. The simplest way to make this work is to place all the template information in a header file and to include the header file in the file that will use the templates.

```C++
#ifndef TEST_HPP_
#define TEST_HPP_

template <class Type>
class Stack
{
public:
	Stack();
	bool isempty();
	bool isfull();
	bool push(const Type & item);
	bool pop(Type & item);
private:
	enum {MAX = 10};
	Type items[MAX];
	int top;	
};

template <class Type>
Stack<Type>::Stack()
{
	top = 0;
}

template <class Type>
bool Stack<Type>::isempty()
{
	return top == 0;
}

template <class Type>
bool Stack<Type>::isfull()
{
	return top == MAX;
}

template <class Type>
bool Stack<Type>::push(const Type & item)
{
	if (top < MAX)
	{
		items[top++] = item;
		return true;
	}
	else
		return false;
}

template <class Type>
bool Stack<Type>::pop(Type & item)
{
	if (top > 0)
	{
		item = items[--top];
		return true;
	}
	else
		return false;
}

#endif
```

### Using a Template Class

To ask for an instantiation, you declare an object of the template class type, replacing the generic type name with the particular type you want. For example, here's how you would create two stacks, one for stacking `int`s and one for stacking `string` objects:

```C++
Stack<int> kernels;		// create a stack of ints
Stack<string> colonels;	// create a stack of string objects
```

Seeing these two declarations, the compiler will follow the `Stack<Type>` template to generate two separate class declarations and two separate sets of methods. Of course, the algorithms you use have to be consistent with types. The `Stack` class, for example, assumes that you can assign one item to another. This assumption is true for basic types, structures and classes (unless you make the assignment operator private) but not for arrays.

Generic type identifiers such as `Type` in the example are called _type parameters_, meaning that they act something like variables, but instead  of assigning a numeric value to a type parameter, you assign a type to it.

Notice that you have to provide the desired type explicitly. This is different from ordinary function templates, for which the compiler can use the argument types to a function to figure out what kind of function to generate.

Listing 14.14 modifies the original stack-testing program (Listing 10.12) to use string purchase order IDs instead of `unsigned long` values.

```C++
// Listing 14.14
#include <iostream>
#include <string>
#include <cctype>
#include "test.hpp"

int main(void)
{
	using std::cin;
	using std::cout;
	Stack<std::string> st;	// create an empty stack
	char ch;
	std::string po;
	cout << "Please enter A to add a purchase order,\n"
		 << "P to process a PO, or Q to quit.\n";
	while (cin >> ch && std::toupper(ch) != 'Q')
	{
		while (cin.get() != '\n')
			continue;
		if (!std::isalpha(ch))
		{
			cout << '\a';
			continue;
		}
		switch(ch)
		{
			case 'A':
			case 'a':
				cout << "Enter a PO number to add: ";
				cin >> po;
				if (st.isfull())
					cout << "stack already full\n";
				else
					st.push(po);
				break;
			case 'P':
			case 'p':
				if (st.isempty())
					cout << "stack already empty\n";
				else
				{
					st.pop(po);
					cout << "PO #" << po << " popped\n";
					break;
				}
		}
		cout << "Please enter A to add a purchase order,\n"
			 << "P to process a PO, or Q to quit.\n";
	}
	cout << "Bye\n";
	return 0;
}
```

### A Closer Look at the Template Class

Can you use a pointer-to-`char` instead of a`string` object in Listing 14.14? The answer is that you can create a stack of pointers, but it won't work very well without major modifications in the program. The compiler can create the class, but it's your task to see that it's used sensibly. 

#### Using a Stack of Pointers Incorrectly.

Let's quickly look at three simple, but flaed attempts to adapt Listing 14.14 to use a stack of pointers. All three examples begin with this perfectly valid invocation of the `Stack<Type>` template:

```C++
Stack<char *> st;	// create a stack for pointers-to-char
```

Version 1 then replaces

```C++
string po;
```

in Listing 14.14 with

```C++
char * po;
```

This approach fails immediately because merely creating a pointer doesn't create space to hold the input strings.

Version 2 replaces

```C++
string po;
```

with

```C++
char po[40];
```

But an array is fundamentally at odds with the assumptions made for the `pop()` method:

```C++
template <class Type>
bool Stack<Type>::pop(Type & item)
{
	if (top > 0)
	{
		item = items[--top];
		return true;
	}
	else
		return false;
}
```

First, the reference variable `item` has to refer to an lvalue of some sort, **not to an array name**. Second, the code assumes that you can assign to `item` Even if `item` could refer to an array, you can't assign to an array name. So this approach fails, too.

Version 3 replaces

```C++
string po;
```

with

```C++
char * po = new char[40];
```

This allocates space for an input string. Furthermore, `po` is variable and hence compatible with the code for `pop()`. Here, however, you come up with the most fundamental problem: There is only one `po` variable, and it always points to the same memory location. True, the contents of the memory change each time a new string is read, but every push operation pushes exactly the same address onto the stack. In particular, the stack is not storing each new string separately as it comes in, and it serves no useful purpose.

#### Using a Stack of Pointers Correctly

One way to use a stack of pointers is to have the calling program provide an array of pointers, with each pointer pointing to a different string. Note that it is the reponsibility of the calling program, not the stack, to create the separate pointers. The stack's job is to manage the pointers, not create them.

For example, suppose you have to simulate the following situation. Someone has delivered a cart of folders to Plodson. If Plodson’s in-basket is empty, he removes the top folder from the cart and places it in his in-basket. If his in-basket is full, Plodson removes the top file from the basket, processes it, and places it in his out-basket. If the in-basket is neither empty nor full, Plodson may process the top file in the in-basket, or he may take the next file from the cart and put it into his in-basket. In what he secretly regards as a bit of madcap self-expression, he flips a coin to decide which of these actions to take. You’d like to investigate the effects of his method on the original file order.

You can model this with an array of pointers to strings representing the files on the cart. Each string will contain the name of the person described by the file. You can use a stack to present the in-basket, and you can use a second array of pointers to represent the out-basket.

Listing 14.15 redefines the `Stack<Type>` class slightly so that the `Stack` constructor accepts an optional size argument. This involes using a dynamic array internally, so the class now needs a destructor, a copy constructor, and an assignemnt operator. Also the definition shortens the code by making several of the methods inline.

```C++
// Listing 14.15
#ifndef TEST_HPP_
#define TEST_HPP_

template <class Type>
class Stack
{
public:
	explicit Stack(int ss = SIZE);
	Stack(const Stack & st);
	~Stack() { delete [] items; }
	bool isempty() { return top == 0; }
	bool isfull() { return top == stacksize; }
	bool push(const Type & item);	// add item to stack
	bool pop(Type & item);
	Stack & operator=(const Stack & st);
private:
	enum {SIZE = 10}; 	// default size
	int stacksize;
	Type * items;	// holds stack items
	int top;
};

template <class Type>
Stack<Type>::Stack(int ss) : stacksize(ss), top(0)
{
	items = new Type [stacksize];
}

template <class Type>
Stack<Type>::Stack(const Stack & st)
{
	stacksize = st.stacksize;
	top = st.top;
	items = new Type [stacksize];
	for (int i = 0; i < top; i++)
        items[i] = st.items[i];
}

template <class Type>
bool Stack<Type>::push(const Type & item)
{
	if (top < stacksize)
	{
		items[top++] = item;
		return true;
	}
	else
		return false;
}

template <class Type>
bool Stack<Type>::pop(Type & item)
{
	if (top > 0)
	{
		item = items[--top];
		return true;
	}
	else
		return false;
}

template <class Type>
Stack<Type> & Stack<Type>::operator=(const Stack<Type> & st)
{
	auto tempItems = new Type [st.stacksize];
	for (int i = 0; i < top; i++)
		tempItems[i] = st.items[i];
	delete [] items;
	items = tempItems;
	stacksize = st.stacksize;
	top = st.top;
	return *this;
}

#endif
```

Notice that the prototype declares the return type for the assignment operator function to be a reference to `Stack`, and the actual template function definition identifies the type as `Stack<Type>`. The former is an abbreviation for the latter, but it can be used **only** within the class scope. That is, you can use `Stack` inside the template declaration and inside the template function definitinons, but outside the class, when identifying return types and when using the scope-resolution operator, you need to use the full `Stack<Type>` form.

The program in Listing 14.16 uses the new stack template to implement the Plodson simulation.

```C++
#include <iostream>
#include <cstdlib>
#include <ctime>
#include "test.hpp"
const int Num = 10;
int main()
{
	std::srand(std::time(0));
	std::cout << "Please enter stack size: ";
	int stacksize;
	std::cin >> stacksize;
// create an empty stack with stacksize slots
	Stack<const char *> st(stacksize);

// in basket
	const char * in[Num] =
	{
		" 1: Hank Gilgamesh", " 2: Kiki Ishtar",
		" 3: Betty Rocker", " 4: Ian Flagranti",
		" 5: Wolfgang Kibble", " 6: Portia Koop",
		" 7: Joy Almondo", " 8: Xaverie Paprika",
		" 9: Juan Moore", " 10: Misha Mache"
	};
// out basket
	const char * out[Num];

	int processed = 0;
	int nextin = 0;
	while (processed < Num)
	{
		if (st.isempty())
			st.push(in[nextin++]);
		else if (st.isfull())
			st.pop(out[processed++]);
		else if (std::rand() % 2 && nextin < Num)
            st.push(in[nextin++]);
		else
            st.pop(out[processed++]);
	}
	for (int i = 0; i < Num; i++)
		std::cout << out[i] << std::endl;
	std::cout << "Bye\n";
	return 0;
}
```

The strings in Listing 14.16 never move. Pushing a string onto the stack really creates a new pointer to an existing string. The program uses `const char *` as a type because the array of pointers is initialized to a set of string constants.

What effect does the stack destructor have on the strings? None. The class constructor uses `new` to create an array for holding pointers. The class destructor eliminates that array, not the strings to which the array elements pointed.

### An Array Template Example and Non-Type Arguments

Let's look at another example and explore a few more facets of template design and use. In particular, let's look at non-type, or expression, arguments and at using an array to handle an inheritance family.

Let's begin with a simple array template that lets you specify an array size. One technique, which the last version of the `Stack` template uses, is to use a dynamic array within the class and a constructor argument to provide the number of elements. Another approach is to use a template argument to provide the size for a regular array. That is what the new C++11 `array` templates does. Listing 14.17 shows a more modest version of how this can be done.

```C++
// Listing 14.17
#ifndef TEST_HPP_
#define TEST_HPP_

#include <iostream>
#include <cstdlib>

template <class T, int n>
class ArrayTP
{
public:
	ArrayTP() {}
	explicit ArrayTP(const T & v);
	virtual T & operator[](int i);
	virtual T operator[](int i) const;
private:
	T ar[n];
};

template <class T, int n>
ArrayTP<T, n>::ArrayTP(const T & v)
{
	for (int i = 0; i < n; i++)
		ar[i] = v;
}

template <class T, int n>
T & ArrayTP<T, n>::operator[](int i)
{
	if (i < 0 || i >= n)
	{
		std::cerr << "Error in array limits: " << i
				  << " is out of range\n";
		std::exit(EXIT_FAILURE);
	}
	return ar[i];
}

template <class T, int n>
T ArrayTP<T, n>::operator[](int i) const
{
	if (i < 0 || i >= n)
	{
		std::cerr << "Error in array limits: " << i
				  << " is out of range\n";
		std::exit(EXIT_FAILURE);
	}
	return ar[i];
}

#endif
```

Note the template heading in Listing 14.17:

```C++
template <class T, int n>
```

The keyword `class` identifies `T` as a type parameter, or type argument. `int` identifies `n` as being an `int` type. This second parameter, one that specifies a particular type instead of acting as a generic name for a type, is called a **non-type**, or **expression**, **argument**. Suppose you have the following declaration:

```C++
ArrayTP<double, 12> eggweights;
```

This causes the compiler to define a class called `ArrayTP<double, 12>` and to create an `eggweights` object of that class. When defining the class, the compiler replaces `T` with `double` and `n` with `12`.

Expression arguments have some restrictions. An expresssion argument can be an integer type, an enumeration type, a reference, or a pointer. Thus, **`double m` is ruled out, but `double & rm` and `double * pm` are allowed**. Also the template can't alter the value fo the argument or take its address. Thus, in the `ArrayTP` template, expressions such as `n++` or `&n` would not be allowed. Also when you instantiate a template, the value used for the expresssion argument should be a constant expression.

This approach for sizing an array has one advantage over the constructor approach used in `Stack`. The constructor approach uses heap memory managed by `new` and `delete`, whereas the expresssion argument approach uses the memory stack maintained for automatic variables. This provides faster executino time, particularly, if you have a lot of small arrays.

The main drawback to the expression arugment approach is that each array size generates its own template. This is, the following declarations generate two separate class declarations:

```C++
ArrayTP<double, 12> eggweights;
ArrayTP<double 13> donuts;
```

But the following declarations generate just one class declarations, and the size information is passed to the constructor for that class:

```C++
Stack<int> eggs(12);
Stack<int> dunkers(13);
```

Another difference is that the constructor approach is more versatile because the array size is stored as a class member rather than being hard-coded into the definition. This makes it possible, for example, to define assignmen from an array of one size to an array of another size or to build a class that allows resizable arrays.

### Template Versatility

You can apply the same techniques to template classes as you do to regular classes. Template classes can serve as base classes, and they can be component classes. They can themselves be type arguments to other templates. For example, you can implement a stack template by using an array template. Or you can have an array template that is used to construct an array whose elements are stacks based on a stack template. That is, you can have code along the following lines:

```C++
template <typename T>	// or <class T>
class Array
{
private:
	T entry;
	...	
};

template <typename Type>
class GrowArray : public Array<Type>  {...}; 	// inheritance

template <typename Tp>
class Stack
{
	Array<Tp> ar;	// use an Array<> as a component
	...
};
...
ArrayT<Stack<int>> asi;	// an array of stacks of int
```

#### Using a Template Recursively

Another example of template versatility is that you can use templates recursively. For example, given the earlier definitino of an array template, you can use ti as follows:

```C++
ArrayTP<ArrayTP<int, 5>, 10> twodee;
```

This makes `twodee` an array of 10 elements, each of which is an array of five `int`s. The program in Listing 14.18 tries this idea.

```C++
// Listing 14.18
#include <iostream>
#include "test.hpp"
int main(void)
{
    using std::cout;
    using std::endl;
    ArrayTP<int, 10> sums;
    ArrayTP<double, 10> aves;
    ArrayTP<ArrayTP<int, 5>, 10> twodee;
    
    for (int i = 0; i < 10; i++)
    {
        sums[i] = 0;
        for (int j = 0; j < 5; j++)
        {
            twodee[i][j] = (i + 1) * (j + 1);
            sums[i] += twodee[i][j];
        }
        aves[i] = (double) sums[i] / 10;
    }
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 5; j++)
        {
            cout.width(2);
            cout << twodee[i][j] << ' ';
        }
        cout << ": sum = ";
        cout.width(3);
        cout << sums[i] << ", average = " << aves[i] << endl;
    }
    
    cout << "Done.\n";
    return 0;
}
```

#### Using More Than One Type Parameter

You can have a template with more than one type parameter. For example, you can create and use a `Pair` template class for holding two kinds of values. (Incidentally, the STL provides  a similar template called `pair`.) the short program in Listing 14.19 shows an example.

```C++
// Listing 14.19
#include <iostream>
#include <string>
template <class T1, class T2>
class Pair
{
public:
	T1 & first();
	T2 & second();
	T1 first() const { return a; }
	T2 second() const { return b; }
	Pair(const T1 & aval, const T2 & bval) : a(aval), b(bval) {}
	Pair() {}
private:
	T1 a;
	T2 b;
};

template <class T1, class T2>
T1 & Pair<T1, T2>::first()
{
	return a;
}

template <class T1, class T2>
T2 & Pair<T1, T2>::second()
{
	return b;
}

int main(void)
{
	using std::cout;
	using std::endl;
	using std::string;
	Pair<string, int> ratings[4] =
	{
		Pair<string, int>("The Purpled Duck", 5),
		Pair<string, int>("Jaquie's Frisco Al Fresco", 4),
		Pair<string, int>("Cafe Souffle", 5),
		Pair<string, int>("Bertie's Eats", 3)
	};

	int joints = sizeof(ratings) / sizeof(Pair<string, int>);
	cout << "Rating:\t Eatery\n";
	for (int i = 0; i < joints; i++)
		cout << ratings[i].second() << ":\t"
			 << ratings[i].first() << endl;
		cout << "Oops! Revised rating:\n";
		ratings[3].first() = "Bertie's Fab Eats";
		ratings[3].second() = 6;
		cout << ratings[3].second() << ":\t "
			 << ratings[3].first() << endl;
		return 0;
}
```

One thing to note about Listing 14.19 is that in `main()`, you have to use `Pair<string, int>` to invoke the constructors and as an argument for `sizeof` That's because `Pair<string, int>` but not `Pair` is the class name.

#### Default Type Template Parameters

Another new class template feature is that you can provide default values for type parameters:

```C++
template <class T1, class T2 = int> class Topo {...};
```

This causes the compiler to use `int` for the type `T2` if a value for `T2` is omitted:

```C++
Topo<double, double> m1;	// T1 is double, T2 is double
Topo<double> m2;			// T1 is double, T2 is int
```

The STL often uses this feature, with the default type being a class.

Although you can provide default values for class template type parameters, **you can do so for function template parameters**. However, you can provide default values for non-type parameters for both class and function templates.

### Template Specializations

Class templates are like function templates in that you can have implicit instantiations, explicit instantiations, and explicit specializations, collectively known as **specializations**. 

#### Implicit Instantiations

The template examples you have seen so far in this chapter use _implicit instantiations_. That is, they declare one or more objects indicating the desired type, and the compiler generates a speicialized class definition, using the recipe provided by the general template:

```C++
ArrayTP<int, 100> stuff;	// implicit instantiation
```

The compiler doesn't generate an implicit instantiation of the class until it needs an object:

```C++
ArrayTP<double, 30> * pt;		// a pointer, no object needed yet
pt = new ArrayTP<double, 30>;	// now an object is neede.
```

The second statement causes the compiler to generate a class definition and also an object that is created according to that definition.

#### Explicit Instantiations

The compiler generates an _explicit instantiation_ of a class declaration when you declare a class by using the keywork `template` and indicating the desired type or types. The declaration should by in the same namespace as the template definition. For example, the following declaration declares `ArrayTP<string, 100>` to be a class:

```C++
template class ArrayTP<string, 100>;	// generate ArrayTP<string, 100> class
```

In this case, the compiler generates the class definition, including methods definitions, even though no object of the class has yet been created or mentioned.

#### Explicit Specializations

An _explicit specialization_ is a definition for a particular type or types that is to be used instead of the general template. Suppose, for, example, that you've defined a template for a class that represents s sorted array for which items are sorted as they are added to the array:

```C++
template <typename T>
class SortedArray
{
	...
};
```

Also suppose the template uses the `>` operator to compare values. It won't work if `T` is a atring represented by type `const char *`. What is needed is a class definition that uses `strcmp()` instead of `>`. In such a case, you can provide an explicit template specialization. When faced with the choice of a speicialized template and a general template that both match an instantiation request, the compiler uses the speicialized version.

A specialized class template definition has the following form:

```C++
template <> 
class Classname<specialized-type-name> { ... };
```

To provide a `SortedArray` template specialized for the `const char *` type, you would use code like the following:

```C++
template <>
class SortedArray<const char *>
{
	...
};
```

Now, requests for a `SortedArray` template of `const char *` will use this specialized definition instead of the more general template definition:

```C++
SortedArray<int> scores;			// use general definition
SortedArray<const char *> dates;	// use specialized definition
```


#### Partial Speicializations

C++ allows for _partial specializations_. For example, a partial specialization can provide a specific type for one of the type parameters:

```C++
// general template
template <class T1, class T2> 
class Pair {...};
// specialization with T2 set to int
template <class T1> 
class Pair<T1, int> {...};
```

Note that specifying all the types leads to an empty bracket pair and a complete explicit specialization:

```C++
// specialization with T1 and T2 set to int
template <> class Pair<int, int> { ... };
```

The compiler uses the most speicialized template if there is a choice. Here's what happens given the preceding three templates:

```C++
Pair<double, double> p1;	// use general Pair template
Pair<double, int> p2;		// use Pair<T1, int> partial specialization
Pair<int, int> p3;			// use Pair<int, int> explicit specialization
```

Or you can partially specialize an existing template by providing a speicial version for pointers:

```C++
template <class T>		// general version
class Feeb { ... };
template <class T *>	// pointer partial specialization
class Feeb { ... };
```

If you provide non-pointer type, the compiler uses the general version; if you provide a pointer, the compiler uses the pointer specialization:

```C++
Feeb<char> fb1;		// use general Feeb template, T is char
Feeb<char *> fb2;	// use Feeb T* specialization, T is char
```

Without the partial specialization, the second declaration would use the general template,. With the partial specialization, it uses the specialized template, interpreting `T` as `char`.

A partial specialization feature allows for making a variety of restrictions. For example, you can use the following:

```C++
// general template
template <class T1, class T2, class T3> 
class Trio{...};
// specialization with T3 set to T2
template <class T1, class T2>
class Trio<T1, T2, T3> { ... };
// specialization with T3 and T2 set to T1*
template <class T1> class<T1, T1*, T1*> {...};
```

Given these declarations, the compiler would make the following choices:

```C++
Trio<int, short, char *> t1;	// use general template
Trio<int, short> t2;			// use Trio<T1, T2, T2>
Trio<char, char *, char *> t3;	// use Trio<T1, T1*, T1*>
```

### Member Templates

A template can be a member of a structure, class, or template class. The STL requires this feature to fully implement its design. Listing 14.20 provides a short example of a template class with a nested template class and a template function as members.

```C++
// Listing 14.20
#include <iostream>
using std::cout;
using std::endl;
template <typename T>
class beta
{
private:
	template <typename V>	// nested template class member
	class hold
	{
	private:
		V val;
	public:
		hold(V v = 0) : val(v) {}
		void show() const { cout << val << endl; }
		V Value() const { return val; }
	};
	hold<T> q;		// template object
	hold<int> n;	// template object
public:
	beta(T t, int i) : q(t), n(i) {}
	template <typename U>	// template method
	U blab(U u, T t) { return (n.Value() + q.Value()) * u / t; }
	void Show() const { q.show(); n.show(); }
};

int main(void)
{
	beta<double> guy(3.5, 3);
	cout << "T was set to double\n";
	guy.Show();
	cout << "V was set to T, which is double, then V was set to int\n";
	cout << guy.blab(10, 2.3) << endl;
	cout << "U was set to int\n";
	cout << guy.blab(10.0, 2.3) << endl;
	cout << "U was set to double\n";
	cout << "Done\n";
}
```

The `hold` template is declared in the private section in Listing 14.20, so it is accessible only within the `beta` class scope. The `beta` class uses the `hold` template to declare two data members:

```C++
hold<T> q;		// template object
hold<int> n;	// template object
```

`n` is a `hold` object based on the `int` type, and the `q` member is a `hold` object based on the `T` type (the `beta` template parameter). In `main()`, the following declaration makes `T` represent `double`, making `q` type `hold<double>`:

```C++
beta<double> guy(3.5, 3);
```

The `blab()` method has one type `U` that is determined implicitly by the argument value **when the method is called** and one type `T` that is determined by the instantiation type of the object. In this example, the declaration for `guy` sets `T` to type `double`, and the first argument in the method call in the following sets `U` to type `int`, matching the value `10`:

```C++
cout << guy.blab(10, 2.5) << endl;
```

Note that replacing `10` with `10.0` in the call to `guy.blab()` causes `U` to be set to `double`, making the return type `double`.

As mentioned previously, the type of the second parameter is set to `double` by the declaration of the `guy` object. Unlike the first parameter, then, the type of the second parameter is **not** set by the function call. For instance, the following statement would still implement `blab()` as `blab(int, double)`, and `3` would be converted to type `double` by the usual function prototype rules:

```C++
cout << guy.blab(10, 3) << endl;
```

You can declare the `hold` class and `blah` method in the `beta` template and define them outside the `beta` template. Here's how defining the template methods outsdie the `beta` template would look:

```C++
template <typename T>
class beta
{
private:
	template <typename V>	// declaration
	class hold;
	hold<T> q;
	hold<int> n;
public:
	beta(T t, int i) : q(t), n(i)	{}
	template <typename U>	// declaration
	U blab(U u, T t);
	void Show() const { q.show(); n.show();}
};

// member definition
template <typename T>
template <typename V>
class beta<T>::hold
{
private:
	V val;
public:
	hold(V v = 0) : val(v) {}
	void show() const { std::cout << val << std::endl; }
	V Value() const { return val; }
};

template <typename T>
template <typename U>
U beta<T>::blab(U u, T t)
{
	return (n.Value() + q.Value()) * u / t;
}
```

The definitions have to identify `T`, `V` and `U` as template parameters. Because the templates are nested, you have to use the

```C++
template <typename T>
template <typename V>
```

syntax instead of this syntax:

```C++
template <typename T, typename V>
```

The definitions also must indicate that `hold` and `blab` are members of the `beta<T>` class, and they use the scope-resolution operator to do so.

### Templates As Parameters

You've seen that a template can have type parameters, such as `typename T`, and non-type parameters, such as `int n`. A template can also have a parameter that is itself a template. Such parameters are yet another feature addition that is used to implement the STL.

Listing 14.21 shows an example that begins with these lines:

```C++
template <template <typename T> class Thing>
class Crab
```

The template parameter is `template <typename T> class Thing`. Here `template <typename T> class` is the type, and `Thing` is the parameter. What does this imply? Suppose you have this declaration:

```C++
Crab<King> legs;
```

For this to be accepted, the template argument `King` has to be a template class whose declaration matches that of the template parameter `Thing`:

```C++
template <typename T>
class King {...};
```

The `Crab` declaration in Listing 14.21 declares two objects:

```C++
Thing<int> s1;
Thing<double> s2;
```

The previous declaration for `legs` would then result in substituting `King<int>` for `Thing<int>` and `King<double>` for `Thing<double>`. However, Listing 14.21 has this declaration:

```C++
Crab<Stack> nebula;
```

Hence, in this case, `Thing<int>` is instantiated as `Stack<int>` and `Thing<double>` is instantiated as `Stack<double>`. In short, the template parameter `Thing` is replaced by whatever template type is used as a template argument in declaring a `Crab` object.

The `Crab` class declaration makes three further assumptions about the template class represented by `Thing`. The class should have a `push()` method, the class should have a `pop()` method, and these methods should have a particular interface. The `Crab` class can use any template class that matches the `Thing` type declaration and that has the prerequisite `push()` and `pop()` methods. 

```C++
// Listing 14.21
#include <iostream>
#include "test.hpp"

template <template <typename T> class Thing>
class Crab
{
public:
	Crab() {};
	// assumes the thing class has push() and pop() memebers
	bool push(int a, double x) { return s1.push(a) && s2.push(x); }
	bool pop(int & a, double & x) { return s1.pop(a) && s2.pop(x); }
private:
	Thing<int> s1;
	Thing<double> s2;
};

int main()
{
	using std::cout;
	using std::cin;
	using std::endl;
	Crab<Stack> nebula;
// Stack must match template <typename T> class Thing
	int ni;
	double nb;
	cout << "Enter int double pairs, such as 4 3.5 (0 0 to end):\n";
	while (cin >> ni >> nb && ni > 0 && nb > 0)
	{
		if (!nebula.push(ni, nb))
			break;
	}

	while (nebula.pop(ni, nb))
		cout << ni << ", " << nb << endl;
	cout << "Done.\n";
	return 0;
}
```

You can mix template parameters with regular parameters. For example, the `Crab` class declaration could start out like this:

```C++
template <template <typename T> class Thing, typename U, typename V>
class Crab
{
private:
	Thing<U> s1;
	Thing<V> s2;
...
}
```

Now the types to be stored in the members `s1` and `s2` are generic types instead of hard-coded types. This would require the declaration of `nebula` in the program to be changed to this:

```C++
Crab<Stack, int, double> nebula;	// T=Stack, U=int, V=double
```

The `template` parameter `T` represents a template type, and the type parameters `U` and `V` represent non-template types.

### Template Classes and Friends

Template class declarations can have friends, too. You can classify friends of templates into three categories:

* Non-template friends
* Bound template friends, meaning the type of the friend is determined by the type of the class **when a class is instantiated**
* Unbound template friends, meaning that all specializations of the friend are friends to each specialization of the class

Let's look at examples of each.

### Not-Template Friend Functions to Template Classes

Let's declare an ordinary function in a template class as a friend:

```C++
template <class T>
class HasFriend
{
public:
	friend void counts();	// friend to all HasFriend instantiations
	...
};
```

This declaration makes the `counts()` function a friend to **all** possible instantiations of the template. For example, it would be a friend to the `HasFriend<int>` class and the `HasFriend<string>` class.

The `counts()` function is not invoked by an object, and it has no object parameters, so how does it access a `HasFriend` object? There are several possibilities. It could access a global object; it could access nonglobal objests by using a global pointer; it could create its own objects; and it could access static data members of a template class, which exist separately from an object.

Suppose you want to provide a template class argument to a friend function. Can you have a friend declaration like this, for example?

```C++
friend void report(HasFriend &);	// possible?
```

The answer is no. The reason is that there is **no such thing as a `HasFriend` object.** There are only particular specializations, such as `HasFriend<short>`. To provide a template class argument, you have to indicate a specialization. For example. you can use this:

```C++
template <class T>
class HasFriend
{
	friend void report(HasFriend<T> &);	// bound template friend
	...
};
```

To understand what this does, imaging the specialization produced if you declare an object of a particular type:

```C++
HasFriend<int> hf;
```

The compiler would replace the template parameter `T` with `int`, giving the friend declaration this form:

```C++
class HasFriend<int>
{
	friend void report(HasFriend<int> &);	// bound template friend
	...
};
```

This is, **`report()` with a `HasFriend<int>` parameter becomes a friend to the `HasFriend<int>` class**. Similarly, `report()` with a `HasFriend<double>` parameter would be an overloaded version of `report()` that is a friend to the `HasFriend<double>` class.

**Note that `report()` is not itself a template function**; it just has a parameter that is a template. This means you have to define explicit specializations for the friends you plan to use:

```C++
void report(HasFriend<short> &) { ... } 	// explicit specialization for short
void report(HasFriend<int> &) {...};	// explicit specialization for int
```

Listing 14.22 illustrate these points. The `HasFriend` template has a static member `ct`. Note that this means that **each particular specialization of the class has its own static member**. The program also provides two `report()` funcitons, each of which is a friend to one particular `HasFriend` specialization.

```C++
// Listing 14.22
#include <iostream>
using std::cout;
using std::endl;

template <typename T>
class HasFriend
{
private:
	T item;
	static int ct;
public:
	HasFriend(const T & i) : item(i) {ct++;}
	~HasFriend() {ct--; }
	friend void counts();
	friend void reports(HasFriend<T> &); // template parameter
};

// each specialization has its own static data member
template <typename T>
int HasFriend<T>::ct = 0;

// non-template friend to all HasFriend<T> classes
void counts()
{
	cout << "int count: " << HasFriend<int>::ct << "; ";
	cout << "double count: " << HasFriend<double>::ct << endl;
}

// non-template friend to the HasFriend<int> class
void reports(HasFriend<int> & hf)
{
	cout << "HasFriend<int>: " << hf.item << endl;
}

// non-template friend to HasFriend<double> class
void reports(HasFriend<double> & hf)
{
	cout << "HasFriend<double>: " << hf.item << endl;
}

int main(void)
{
	cout << "No object declared: ";
	counts();
	HasFriend<int> hfi1(10);
	cout << "After hfi1 declared: ";
	counts();
	HasFriend<int> hfi2(20);
	cout << "After hfi2 declared: ";
	counts();
	HasFriend<double> hfdb(10.5);
	cout << "After hfdb declared: ";
	counts();
	reports(hfi1);
	reports(hfi2);
	reports(hfdb);

	return 0;
}
```

#### Bound Template Friend Functions to Template Classes

You can modify the preceding example by making the friend functions templates themselves. In particular, you can set things up for bound template friends, so each specializationg of a class **gets a matching specialization for a friend**. The technique is a bit more complex than for non-template friends and involves three steps.

For the fist step, you declare each template function before the class definition:

```C++
template <typename T> void counts();
template <typename T> void report(T &);
```

Next, you declare the templates again as friends inside the function. These statements declare sepecialization based on the class template parameter type:

```C++
template <typename TT>
class HasFriendT
{
...
	friend void counts<TT>();
	friend void report<>(HasFriendT<TT> &);
};
```

The `<>` in the declarations identifies these as template specializations. In the case of `report()`, the `<>` can be left empty because the following template type argument can be deduced from the function argument:

```C++
HasFriendT<TT>
```

You could, however, use this instead:

```C++
report<HasFriend<TT>>(HasFriend<TT> &)
```

However, the `counts` function has no parameters, so you have to use the template argument syntax (`<TT>`) to indicate its specialization. Note, too, that `TT` is the parameter type for the `HasFriendT` class.

Again, the best way to understand these declarations is to imagine whay they become when you declare an object of a particular specialization. For example, suppose you declare this object:

```C++
HasFriend<int> squack;
```

Then the compiler substitutes `int` for `TT` and generates the following definition:

```C++
class HasFriendTT<int>
{
...
	friend void counts<int>();
	friend void report<>(HasFriendT<int> &);
}
```

One specialization is based on `TT`, which becomes `int`, and the other is based on `HasFriendT<TT>`, which becomes `HasFriendT<int>`. Thus, the template specializations `counts<int>` and `report<HasFriendT<int>>()` are declared as friends to the `HasFriendT<int>` class.

The third requirement the program must meet is to provide template definitions for the friends. Listing 14.23 illustrates these three aspects.

```C++
// Listing 14.23
#include <iostream>
using std::cout;
using std::endl;

// template prototypes
template <typename T> void counts();
template <typename T> void report(T &);

// template class
template <typename TT>
class HasFriendT
{
private:
	TT item;
	static int ct;
public:
	HasFriendT(const TT & i) : item(i) {ct++;}
	~HasFriendT() { ct--; }
	friend void counts<TT>();
	friend void report<>(HasFriendT<TT> &);
};

template <typename T>
int HasFriendT<T>::ct = 0;

// template friend functions definitions
template <typename T>
void counts()
{
	cout << "template size: " << sizeof(HasFriendT<T>) << "; ";
	cout << "template counts(): " << HasFriendT<T>::ct << endl;
}

template <typename T>
void report(T & hf)
{
	cout << hf.item << endl;
}

int main(void)
{
	counts<int>();
	HasFriendT<int> hfi1(10);
	HasFriendT<int> hfi2(20);
	HasFriendT<double> hfdb(10.5);
	report(hfi1);	// generate report(HasFriendT<int> &)
	report(hfi2);	// generate report(HasFriendT<int> &)
	report(hfdb); 	// generate report(HasFriendT<double> &)
	cout << "counts<int>() output:\n";
	counts<int>();
	cout << "counts<double>() output:\n";
	counts<double>();

	return 0;
}
```

#### Unbound Template Friend Functions to Template Classes

By declaring a template inside a class, you can create unbound friend functions for which every function specialization is a friend to every class specialization. For unbound friends, the friend template ype parameters are different from the template type parameters:

```C++
template <typename T>
class ManyFriend
{
...
	template <typename C, typename D> friend void show2(C &, D &);
};
```

Listing 14.24 shows an example that uses an unbound friend. In it, the function call `show2(hfi1, hfi2)` gets matched to the following specialization:

```C++
void show2<ManyFriend<int> &, ManyFriend<int> &>(Many Friend<int> & c, ManyFriend<int> & d);
```

Because it is a friend to all specializations of `ManyFriend`, this function has access to the `item` members of all specializations. But it only uses access to `ManyFriend<int>` objects.

```C++
#include <iostream>
using std::cout;
using std::endl;

template <typename T>
class ManyFriend
{
private:
	T item;
public:
	ManyFriend(const T & i) : item(i) {}
	template <typename C, typename D> friend void show2(C &, D &);
};

template <typename C, typename D> void show2(C & c, D & d)
{
	cout << c.item << ", " << d.item << endl;
}

int main(void)
{
	ManyFriend<int> hfi1(10);
	ManyFriend<int> hfi2(20);
	ManyFriend<double> hfdb(10.5);
	cout << "hfi1, hfi2: ";
	show2(hfi1, hfi2);
	cout << "hfdb, hfi2: ";
	show2(hfdb, hfi2);

	return 0;
}
```

### Template Aliases (C++11)

C++ provides a feature to use a template to provide a family of aliases. Here's what the approach looks like:

```C++
template <typename T>
using arrtype = std::array<T, 12>	// template to create multiple aliases
```

This makes `arrtype` a template alias that can be used as a type, as follows:

```C++
arrtype<double> gallons;
arrtype<int> days;
arrtype<std::string> monthds;
```

In short, `arrtype<T>` means type `std::array<T, 12>`.

C++11 extends the `using =` syntax to non-templates too. In that case, it becomes equivalent to an ordinary `typedef`:

```C++
using pc2 = const char *;
```



