# Chapter 17 Input, Output, and Files

In this chapter you'll learn about the following:

* The C++ view of input and output
* The `iostream` family of classes
* Redirection
* `ostream` class methods
* Formatting output
* `istream` class methods
* Stream states
* File I/O
* Using the `ifstream` class for input from files
* Uisng the `ofstream` class for output to files
* Using the `fstream` class file input and output
* Command-line processing
* Binary files
* Random file access
* Incore formatting

## An Overview of C++ Input and Output

### Streams, Buffers, and the `iostream` File

* The `streambuf` class provides memory for a buffer, along with class methods for filling the buffer, accessing buffer contents, flushing the buffer, and managing the buffer memory.

* The `ios_base` class represents general properties of a stream, such as whether it’s open for reading and whether it’s a binary or a text stream.

* The `ios` class is based on `ios_base`, and it includes a pointer member to a `streambuf` object.

* The `ostream` class derives from the `ios` class and provides output methods.

* The `istream` class derives from the `ios` class and provides input methods.

* The `iostream` class is based on the `istream` and `ostream` classes and thus inherits both input and output methods.

To use these facilities, you use objects of the appropriate classes. For example, you use an `ostream` object such as cout to handle output. Creating such an object opens a stream, automatically creates a buffer, and associates it with the stream. It also makes the class member functions available to you.

The C++ `iostream` class library takes care of many details for you.  For example, including the `iostream` file in a program creates eight stream objects (four for narrow character streams and four for wide character streams) automatically:

* The `cin` object corresponds to the standard input stream. By default, this stream is associated with the standard input device, typically a keyboard. The `wcin` object is similar but works with the `wchar_t` type.

* The `cout` object corresponds to the standard output stream. By default, this stream is associated with the standard output device, typically a monitor. The wcout object is similar but works with the `wchar_t` type.

* The `cerr` object corresponds to the standard error stream, which you can use for displaying error messages. By default, this stream is associated with the standard output device, typically a monitor, and the stream is unbuffered. This means that information is sent directly to the screen, without waiting for a buffer to fill or for a newline character. The `wcerr` object is similar but works with the `wchar_t` type.

* The `clog` object also corresponds to the standard error stream. By default, this stream is associated with the standard output device, typically a monitor, and the stream is buffered.The wclog object is similar but works with the `wchar_t` type.

Redirecting the standard output doesn’t affect `cerr` or `clog`.

## Output with `cout`

One of the most important tasks facing the `ostream` class is converting numeric types, such as `int` or `float`, into a stream of characters that represents the values in text form. That is, the `ostream` class translates the internal representation of data as binary bit patterns to an output stream of character bytes.

### The Overloaded `<<` Operator

The `ostream` class redefines the `<<` operator through overloading to output for the `ostream` class. In this guise, the `<<` operator is called the insertion operator instead of the left-shift operator. The insertion operator is overloaded to recognize all the basic C++ types.

For example, the expression `cout << 88` matches the following method prototype:

```C++
ostream & operator<<(int);
```

The prototype also indicates that the function returns a reference to an `ostream` object. That property makes it possible to concatenate output.

#### Output and Pointers

The `ostream` class defines insertion operator functions for the following pointer types:

```C++
const signed char *
const unsigned char *
const char *
void *
```

All the following `cout` statements display strings:

```C++
char name[20] = "Dudly Diddlemore"; 
char * pn = "Violet D'Amore";
cout << "Hello!";
cout << name;
cout << pn;
```

C++ matches a pointer of any other type with type `void *` and prints a numeric representation of the address. If you want the address of the string, you have to type cast it to another type, as shown in the following code fragment:

```C++
int eggs = 12;
char * amount = "dozen";
cout << &eggs;				// prints address of eggs variable
cout << amount;				// prints the string "dozen"
cout << (void *) amount;	// prints the address of the "dozen" string
```

#### Output Concatenation

### The Other `ostream` Methods

Besides the various `operator<<()` functions, the `ostream` class provides the `put()` method for displaying characters and the `write()` method for displaying strings.

Originally, the `put()` method had the following prototype:

```C++
ostream & put(char);
```

The current standard is equivalent, except it’s templated to allow for `wchar_t`. You invoke it by using the usual class method notation:

```C++
cout.put('W');	// display the W character
```

Like the `<<` operator functions, this function returns a reference to the invoking object, so you can concatenate output with it:

```C++
cout.put('I').put('t');
```

Given the proper prototype, you can use `put()` with arguments of numeric types other than char, such as `int`, and let function prototyping automatically convert the argument to the correct type char value. For example, you could use the following:

```C++
cout.put(65);		// display the A character
cout.put(66.3);		// display the B character
```

The `write()` method writes an entire string and has the following template prototype:

```C++
basic_ostream<charT, traits> & write(const char_type * s, streamsize n);
```


The first argument to `write()` provides the address of the string to be displayed, and the second argument indicates how many characters to display. Using `cout` to invoke `write()` invokes the char specialization, so the return type is `ostream &`. Listing 17.1 shows how the `write()` method works.

```C++
// Listing 17.1
#include <iostream>
#include <cstring>

int main()
{
	using std::cout;
	using std::endl;
	const char * state1 = "Florida";
	const char * state2 = "Kansas";
	const char * state3 = "Euphoria";
	int len = std::strlen(state2);
	cout << "Increasing loop index:\n";
	for (int i = 1; i <= len; i++)
	{
		cout.write(state2, i);
		cout << endl;
	}
// concatenate output
	cout << "Decreasing loop index:\n";
	for (int i = len; i > 0; i--)
		cout.write(state2, i) << endl;
// exceed string length
	cout << "Exceeding string length:\n";
	cout.write(state2, len + 5) << endl;

	return 0;
}
```

Note that the `cout.write()` call returns the `cout` object. This makes it possible to concatenate output because `cout.write()` is replaced by its return value, `cout`:

```C++
cout.write(state2, i) << endl;
```

Also, note that the `write()` method doesn’t stop printing characters automatically when it reaches the null character. It simply prints how many characters you tell it to, even if that goes beyond the bounds of a particular string.

The `write()` method can also be used with numeric data. You would pass it the address of a number, type cast to `char *`:

```C++
long val = 560031841;
cout.write((char *) &val, sizeof(long));
```

A 4-byte `long` value such as `560031841` would be transmitted as 4 separate bytes. An output device such as a monitor would then try to interpret each byte as if it were ASCII (or whatever) code.

`write()` provide a compact, accurate way to store numeric data in a file. We’ll return to this possibility later in this chapter.

### Flushing the Output Buffer

The `ostream` class buffers output handled by the `cout` object, output isn’t sent to its destination immediately. Instead, it accumulates in the buffer until the buffer is full. Then the program flushes the buffer, sending the contents on and clearing the buffer for new data.

In the case of screen output, the program doesn’t necessarily wait until the buffer is full. Sending a newline character to the buffer, for example, normally flushes the buffer. Also as mentioned before, most C++ implementations flush the buffer when input is pending. That is, suppose you have the following code:

```C++
cout << "Enter a number: ";
float num;
cin >> num;
```

The fact that the program expects input causes it to display the `cout` message (that is, flush the `"Enter a number: "` message) immediately, even though the output string lacks a newline character

If your implementation doesn’t flush output when you want it to, you can force flushing by using one of two manipulators. The `flush` manipulator flushes the buffer, and the `endl` manipulator flushes the buffer and inserts a newline character. You use these manipu-
lators the way you would use a variable name:

```C++
cout << "Hello, good-looking! " << flush;
cout << "Wait just a moment, please." << endl;
```

Manipulators are, in fact, functions. For example, you can flush the cout buffer by calling the `flush()` function directly:

```C++
flush(cout);
```

However, the `ostream` class overloads the `<<` insertion operator in such a way that the
following expression gets replaced with the `flush(cout)` function call:

```C++
cout << flush;
```

### Formatting with `cout`

The `ostream` insertion operators convert values to text form. By default, they format values as follows:

* A type `char` value, if it represents a printable character, is displayed as a character in a field one character wide.
* Numeric integer types are displayed as decimal integers in a field just wide enough to hold the number and, if present, a minus sign.
* Strings are displayed in a field equal in width to the length of the string.
* Floating-point types are displayed with a total of six digits, except that trailing zeros aren’t displayed. (Note that the number of digits displayed has no connection with the precision to which the number is stored.) The number is displayed in fixed-point notation or else in E notation, depending on the value of the number. In particular, E notation is used if the exponent is 6 or larger or -5 or smaller. Again, the field is just wide enough to hold the number and, if present, a minus sign. The default behavior corresponds to using the standard C library function `fprintf()` with a `%g` specifier.

Listing 17.2 illustrates the output defaults. It displays a colon (`:`) after each value so you can see the width of the field used in each case.

```C++
//Listing 17.2
#include <iostream>

int main()
{
	using std::cout;
	cout << "12345678901234567890\n";
	char ch = 'K';
	int t = 273;
	cout << ch << ":\n";
	cout << t << ":\n";
	cout << -t << ":\n";

	double f1 = 1.200;
	cout << f1 << ":\n";
	cout << (f1 + 1.0 / 9.0) << ":\n";

	double f2 = 1.67E2;
	cout << f2 << ":\n";
	f2 += 1.0 / 9.0;
	cout << f2 << ":\n";
	cout << (f2 * 1.0e4) << ":\n";

	double f3 = 2.3e-4;
	cout << f3 << ":\n";
	cout << f3 / 10 << ":\n";

	return 0;
}
```

#### Changing the Number Base Used for Display

The `ostream` class inherits from the `ios` class, which inherits from the `ios_base` class. The `ios_base` class stores information that describes the format state. For example, certain bits in one class member determine the number base used, whereas another member determines the field width. By using manipulators, you can control the number base used to display integers. By using `ios_base` member functions, you can control the field width and the number of places displayed to the right of the decimal. Because the `ios_base` class is an indirect base class for `ostream`, you can use its methods with `ostream` objects (or descendants), such as `cout`.

To control whether integers are displayed in base 10, base 16, or base 8, you can use the `dec`, `hex`, and `oct` manipulators. For example, the following function call sets the number base format state for the cout object to hexadecimal:

```C++
hex(cout);
```

Note that the manipulators are not member functions, hence they don’t have to be invoked by an object. Although the manipulators really are functions, you normally see them used this way:

```C++
cout << hex;
```

The `ostream` class overloads the `<<` operator to make this usage equivalent to the function call `hex(cout)`. The manipulators are in the `std` namespace. Listing 17.3 illustrates using these manipulators. 

```C++
// Listing 17.3
#include <iostream>
int main()
{
	using namespace std;
	cout << "Enter an integer: ";
	int n;
	cin >> n;

	cout << "n\tn*n\n";
	cout << n << "\t" << n * n << " (decimal)\n";
// set to hex mode
	cout << hex;
	cout << n << "\t";
	cout << n * n << " (hexadecimal)\n";
// set to octal mode
	cout << oct << n << "\t" << n * n << " (octal)\n";

// alternative way to call a manipulator
	dec(cout);
	cout << n << "\t" << n * n << " (decimal)\n";
	return 0;
}
```

#### Adjusting Field Widths

You can use the `width` member function to place differently sized numbers in fields that have equal widths. The method has these prototypes:

```C++
int width();
int width(int i);
```

The first form returns the current setting for field width. The second sets the field width to `i` spaces and returns the previous field width value.

The `width()` method affects **only** the next item displayed, and the field width reverts to the default value afterward. For example, consider the following statements:

```C++
cout << '#';
cout.width(12);
cout << 12 << "#" << 24 << "#\n";
```

Because `width()` is a member function, you have to use an object (`cout`, in this case) to invoke it. The output statement produces the following display:

```
#          12#24#
```

The `12` is placed in a field 12 characters wide at the right end of the field. This is called right-justification. After that, the field width reverts to the default, and the two `#` charac- ters and the `24` are printed in fields equal to their own size.

> **Caution**

> The `width()` method affects only the next item displayed, and the field width reverts to the default value afterward.

C++ never truncates data, so if you attempt to print a seven-digit value in a field with a width of two, C++ expands the field to fit the data. Listing 17.4 shows how the `width()` member function works.

```C++
// Listing 17.4
#include <iostream>

int main()
{
	using std::cout;
	int w = cout.width(30);
	cout << "default field width = " << w << ":\n";
	cout.width(5);
	cout << "N" << ':';
	cout.width(8);
	cout << "N * N" << ":\n";

	for (long i = 1; i <= 100; i *= 10)
	{
		cout.width(5);
		cout << i << ':';
		cout.width(8);
		cout << i * i << ":\n";
	}
	return 0;
}
```

With right-justification, the spaces are inserted to the left of the values. The character used for padding is termed the _fill character_. Right-justification is the default.

#### Fill Characters

By default, `cout` fills unused parts of a field with spaces. You can use the `fill()` member function to change that. For example, the following call changes the fill character to an asterisk:

```C++
cout.fill('*');
```

Listing 17.5 illustrates using this member function.

```C++
// Listing 17.5
// Listing 17.5
#include <iostream>

int main()
{
	using std::cout;
	cout.fill('*');
	const char * staff[2] = {"Waldo Whipsnade", "Wilmarie Wooper"};
	long bonus[2] = {900, 1350};

	for (int i = 0; i < 2; i++)
	{
		cout << staff[i] << ": $";
		cout.width(7);
		cout << bonus[i] << "\n";
	}

	return 0;
}
```

#### Setting Floating-Point Display Precision

The meaning of floating-point precision depends on the output mode. In the default mode, it means the total number of digits displayed. In the fixed and scientific modes, to be discussed soon, precision means the number of digits displayed to the right of the decimal place. The precision default for C++, as you’ve seen, is 6. (Recall, however, that trailing zeros are dropped.) The `precision()` member function lets you select other values. For example, the following statement causes cout to set the precision to 2:

```C++
cout.precision(2);
```

Unlike the case with `width()`, but like the case for `fill()`, a new precision setting
stays in effect until it is reset. Listing 17.6 demonstrates precisely this point.

```C++
// Listing 17.6
#include <iostream>

int main()
{
	using std::cout;
	float price1 = 20.40;
	float price2 = 1.9 + 8.0 / 9.0;

	cout << "\"Furry Friends\" is $" << price1 << "!\n";
	cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

	cout.precision(2);
	cout << "\"Furry Friends\" is $" << price1 << "!\n";
	cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

	return 0;
}
```

Here is the output of the program in Listing 17.6:

```
"Furry Friends" is $20.4! 
"Fiery Fiends" is $2.78889! 
"Furry Friends" is $20! 
"Fiery Fiends" is $2.8!
```

Note that the third line of this output doesn’t include a trailing decimal point. Also the fourth line displays a total of two digits.

#### Printing Trailing Zeros and Decimal Points

The `ios_base` class provides a `setf()` (for _set flag_) function that controls several formatting features. The class also defines several constants that can be used as arguments to this function. For example, the following function call causes `cout` to display trailing decimal points:

```C++
cout.setf(ios_base::showpoint);
```

In the default floating-point format, **it also causes trailing zeros to be displayed**. That is, instead of displaying `2.00` as `2`, cout will display it as `2.00000` if the default precision of 6 is in effect. Listing 17.7 adds this statement to Listing 17.6.

```C++
// Listing 17.7

#include <iostream>

int main()
{
	using std::cout;
	using std::ios_base;

	float price1 = 20.40;
	float price2 = 1.0 * 8.0 / 9.0;

	cout.setf(ios_base::showpoint);
	cout << "\"Furry Friends\" is $" << price1 << "!\n";
	cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

	cout.precision(2);
	cout << "\"Furry Friends\" is $" << price1 << "!\n";
	cout << "\"Fiery Fiends\" is $" << price2 << "!\n";

	return 0;
}
```

Here is the output of the program in Listing 17.7, using the current C++ formatting:

```
"Furry Friends" is $20.4000! 
"Fiery Fiends" is $2.78889! 
"Furry Friends" is $20.! 
"Fiery Fiends" is $2.8!
```

This output shows the trailing zeros for the first line. The third line shows the decimal point but no trailing zeros because the precision has been set to 2 and two digits already have been displayed.

#### More About `setf()`

The `ios_base` class has a protected data member in which individual bits (called _flags_ in this context) control different formatting aspects, such as the number base and whether trailing zeros are displayed. Turning a flag on is called _setting the flag_ (or bit) and means setting the bit to 1. The `hex`, `dec`, and `oct` manipulators, for example, adjust the three flag bits that control the number base. The `setf()` function provides another means of adjusting flag bits.

The `setf()` function has two prototypes. The first is this:

```C++
fmtflags setf(fmtflags);
```

Here `fmtflags` is a typedef name for a bitmask type (see the following Note) used to hold the format flags. This version of `setf()` is used for setting format information controlled by **a single bit**.The argument is a `fmtflags` value that indicates which bit to set. The return value is a type `fmtflags` number that indicates the former settings of all the flags. The `ios_base` class defines constants that represent the bit values.Table 17.1 shows some of these definitions.

![T17-1](\Pics\T17-1.png)

Listing 17.8 illustrates using some of these constants.


```C++
// Listing 17.8
#include <iostream>

int main()
{
	using std::cout;
	using std::endl;
	using std::ios_base;

	int temperature = 63;

	cout << "Today's water temperature: ";
	cout.setf(ios_base::showpos);	// show plus sign
	cout << temperature << endl;

	cout << "For our programming friends, that's\n";
	cout << std::hex << temperature << endl;	// use hex
	cout.setf(ios_base::uppercase);	// use uppercase in hex
	cout.setf(ios_base::showbase);	// use 0X prefix for hex
	cout << "or\n";
	cout << temperature << endl;
	cout << "How " << true << "!  oops -- How ";
	cout.setf(ios_base::boolalpha);
	cout << true << "!\n";

	return 0;
}
```

Note that the plus sign is used only with the base 10 version. C++ treats hexadecimal and octal values as unsigned; therefore no sign is needed for them.

The second `setf()` prototype takes two arguments and returns the prior setting:

```C++
fmtflags setf(fmtflags, fmtflags);
```

This overloaded form of the function is used for format choices controlled by more than 1 bit. The first argument, as before, is a `fmtflags` value that contains the desired setting.The second argument is a value that first clears the appropriate bits. 

The clever `hex` manipulator does both tasks automatically. Using the `setf()` function requires a bit more work because you use the second argument to indicate which bits to clear and then use the first argument to indicate which bit to set. The `ios_base` class defines constants (shown in Table 17.2) for this purpose.

![T17-2](\Pics\T17-2.png)

In particular, you should use the constant `ios_base::basefield` as the second argument and `ios_base::hex` as the first argument is you're changing bases. That is, the following function call has the same effect as using the hex manipulator:

```C++
cout.setf(ios_base::hex, ios_base::basefield);
```

The `ios_base` class defines three sets of formatting flags that can be handled this way. Each set consists of one constant to be used as the second argument and two to three constants to be used as a first argument. **The second argument clears a batch of related bits; then the first argument sets one of those bits to 1.**

Under the C++ Standard, both fixed and scientific notation have the following two properties:

* _Precision_ means the number of digits to the right of the decimal rather than the total number of digits.
* Trailing zeros are displayed.

The `setf()` function is a member function of the `ios_base` class. Because that’s a base class for the `ostream` class, you can invoke the function by using the cout object. For example, to request left-justification, you use this call:

```C++
ios_base::fmtflags old = cout.setf(ios_base::left, ios_base::adjustfield);
```

To restore the previous setting, you use this:

```C++
cout.setf(old, ios::adjustfield);
```

Listing 17.9 illustrates further examples of using `setf()` with two arguments.

```C++
// Listing 17.9
#include <iostream>
#include <cmath>

int main()
{
	using namespace std;
// use left justifiction, show the plus sign, show trailing
// zeros, with a precision of 3
	cout.setf(ios_base::left, ios_base::adjustfield);
	cout.setf(ios_base::showpos);
	cout.setf(ios_base::showpoint);
	cout.precision(3);
	// use e-notation and save old format setting
	ios_base::fmtflags old = cout.setf(ios_base::scientific,
			ios_base::floatfield);
	cout << "Left Justifiction:\n";
	long n;
	for (n = 1; n <= 41; n += 10)
	{
		cout.width(4);
		cout << n << "|";
		cout.width(12);
		cout << sqrt(double(n)) << "|\n";
	}

	// change to internal justification
	cout.setf(ios_base::internal, ios_base::adjustfield);
	// restore default floating-point display style
	cout.setf(old, ios_base::floatfield);

	cout << "Internal Justification:\n";
	for (n = 1; n <= 41; n += 10)
	{
		cout.width(4);
		cout << n << "|";
		cout.width(12);
		cout << sqrt(double(n)) << "|\n";
	}

	// use right justification, fixed notation
	cout.setf(ios_base::right, ios_base::adjustfield);
	cout.setf(ios_base::fixed, ios_base::floatfield);
	cout << "Right Justification:\n";
	for (n = 1; n <= 41; n += 10)
	{
		cout.width(4);
		cout << n << "|";
		cout.width(12);
		cout << sqrt(double(n)) << "|\n";
	}
	return 0;
}
```

Note how a precision of 3 causes the default floating-point display (used for internal justification in this program) to display a total of three digits, while the fixed and scientific modes display three digits to the right of the decimal. 

The effects of calling `setf()` can be undone with `unsetf()`, which has the following prototype:

```C++
void unsetf(fmtflags mask);
```

Here mask is a bit pattern. All bits set to `1` in `mask` cause the corresponding bits to be
unset. That is, `setf()` sets bits to `1`, and `unsetf()` sets bits back to `0`. Here’s an example:

```C++
cout.setf(ios_base::showpoint);			// show trailing decimal point
cout.unsetf(ios_base::showpoint);		// don't show trailing decimal point
cout.setf(ios_base::boolalpha);			// display true, false
cout.unsetf(ios_base::boolalpha);		// display 1, 0
```


You may have noticed that there is no special flag to indicate the default mode for displaying floating-point numbers. Here’s how the system works. Fixed notation is used if the fixed bit, and only the fixed bit is set. Scientific notation is used if the scientific bit and only the scientific bit is set. Any other combination, such as no bits set or both bits set, results in the default mode being used. So one way to invoke the default mode is this:

```C++
cout.setf(0, ios_base::floatfield);	// go to default mode
```

The second argument turns both bits off, and the first argument doesn’t set any bits. A shorter way to accomplish the same end is to use `unsetf()` with `ios_base::floatfield`:

```C++
cout.unsetf(ios_base::floatfield);	// go to default mode
```

#### Standard Manipulators

C++ offers several manipulators to invoke `setf()` for you, automatically supplying the right arguments. You’ve already seen `dec`, `hex`, and `oct`. For example, the following statement turns on left-justification and the fixed decimal point option:

```C++
cout << left << fixed;
```

Table 17.3 lists these along with several other manipulatrs.

![T17-3a](\Pics\T17-3a.png)
![T17-3b](\Pics\T17-3b.png)

#### The `iomanip` Header File

C++ supplies additional manipulators in the `iomanip` header file. The three most commonly used are `setprecision()` for setting the precision, `setfill()` for setting the fill character, and `setw()` for setting the field width. The `setprecision()` manipulator takes an integer argument that specifies the precision, the `setfill()` manipulator takes a `char` argument that indicates the fill character, and the `setw()` manipulator takes an integer argument that specifies the field width. Because they are manipulators, they can be concatenated in a `cout` statement.  Listing 17.10 illustrates this by changing the field width and fill character several times for one output line. It also uses some of the newer standard manipulators.

```C++
// Listing 17.10
#include <iostream>
#include <iomanip>
#include <cmath>

int main()
{
	using namespace std;
	// use new standard manipulators
	cout << fixed << right;

	// use iomanip manipulators
	cout << setw(6) << "N" << setw(14) << "square root"
		 << setw(15) << "fourth root\n";

	double root;
	for (int n = 10; n <= 100; n += 10)
	{
		root = sqrt(double(n));
		cout << setw(6) << setfill('.') << n << setfill(' ')
			 << setw(12) << setprecision(3) << root
			 << setw(14) << setprecision(4) << sqrt(root)
			 << endl;
	}

	return 0;
}
```

## Input with `cin`

The `cin` object represents the standard input as a stream of bytes. Typically, you use `cin` as follows:

```C++
cin >> value_holder;
```

The `istream` class, defined in the `iostream` header file, overloads the `>>` extraction operator to recognize the following basic types:

```C++
signed char &
unsigned char &
char &
short &
unsigned short &
int &
unsigned int &
long &
unsigned long &
long long & // (C++11)
unsigned long long & // (C++11)
float &
double &
long double &
```


These are referred to as _formatted input functions_ because they convert the input data to the format indicated by the target.

Because the argument type is a reference, `cin` is able to directly modify the value of a variable used as an argument.

Incidentally, you can use the `hex`, `oct`, and `dec` manipulators with `cin` to specify that integer input is to be interpreted as hexadecimal, octal, or decimal format. For example, the following statement causes an input of `12` or `0x12` to be read as hexadecimal `12`, or decimal `18`, and it causes `ff` or `FF` to be read as decimal `255`:

```C++
cin >> hex;
```

The `istream` class also overloads the `>>` extraction operator for character pointer types:

```C++
signed char *
char *
unsigned char *
```

For this type of argument, the extraction operator reads the next word from input and places it at the indicated address, adding a null character to make a string. The fact that each extraction operator returns a reference to the invoking object lets you concatenate input, just as you can concatenate output:

```C++
char name[20];
float fee;
int group;
cin >> name >> fee >> group;
```

### How `cin >>` Views Input

The various versions of the extraction operator share a common way of looking at the input stream. They skip over white space (blanks, newlines, and tabs) until they encounter a non-white-space character. This is true even for the single-character modes. It reads everything from the initial non-white-space character up to the first character that doesn’t match the destination type.

For example, consider the following code:

```C++
int elevation;
cin >> elevation;
```

Suppose you type the following characters:

```C++
-123Z
```

The operator will read the `-,` `1`, `2`, and `3` characters because they are all valid parts of an integer. But the `Z` character isn’t valid, so the last character accepted for input is the `3`. The `Z` remains in the input stream, and the next `cin` statement will start reading at that point.

It can happen that input fails to meet a program’s expectation. For example, suppose you enter `Zcar` instead of `-`123Z. In that case, the extraction operator leaves the value of elevation unchanged and returns the value `0`. (More technically, an `if` or `while` statement evaluates an `istream` object as `false`). The false return value allows a program to check whether input meets the program requirements, as Listing 17.11 shows.

```C++// Listing 17.11
#include <iostream>

int main()
{
	using namespace std;
	cout << "Enter numbers: ";

	int sum = 0;
	int input;
	while (cin >> input)
	{
		sum += input;
	}

	cout << "Last value entered = " << input << endl;
	cout << "Sum = " << sum << endl;
	return 0;
}
```

### Stream States

A `cin` or `cout` object contains a data member (inherited from the `ios_base` class) that describes the _stream state_. A stream state (defined as type _iostate_, which, in turn, is a bitmask type, such as described earlier) consists of the three `ios_base` elements: `eofbit`, `badbit`, and `failbit`. Each element is a single bit that can be `1` (set) or `0` (cleared). When a `cin` operation reaches the end of a file, it sets `eofbit`. When a `cin` operation fails to read the expected characters, as in the earlier example, it sets `failbit`. I/O failures, such as trying to read a non-accessible file or trying to write to a write-protected disk, also can set `failbit` to 1. The `badbit` element is set when some undiagnosed failure may have corrupted the stream. When all three of these state bits are set to `0`, everything is fine.

Table 17.4 lists these bits, along with some `ios_base` methods that report or alter the stream state.

![T17-4a](\Pics\T17-4a.png)
![T17-4b](\Pics\T17-4b.png)

#### Setting States

Two of the methods in Table 17.4, `clear()` and `setstate()`, are similar. Both reset the state, but they do so in a different fashion. The `clear()` method sets the state to its argument. Thus, the following call uses the default argument of `0`, which clears all three state bits (`eofbit`, `badbit`, and `failbit`):

```C++
clear();
```

Similarly, the following call makes the state equal to `eofbit`; that is, `eofbit` is set, and the other two state bits are cleared:

```C++
clear(eofbit);
```

The `setstate()` method, however, affects only those bits that are set in its argument. Thus, the following call sets `eofbit` without affecting the other bits:

```C++
setstate(eofbit);
```

So if `failbit` was already set, it stays set.

For a program writer, the most common reason is to use `clear()` with no argument to reopen input after encountering mismatched input or end-of-file. The main purpose for `setstate()` is to provide a means for input and output functions to change the state. For example, if `num` is an `int`, the following call can result in `operator>>(int &)` using `setstate()` to set `failbit` or `eofbit`:

```C++
cin >> num;	// read an int
```

#### I/O and Exceptions

Suppose that an input function sets `eofbit`. By default, this doesn't cause an exception to be thrown. However, you can use the `exceptions()` method to control how exceptions are handled.

The `exceptions()` method returns a bitfield with three bits corresponding to `eofbit`, `failbit`, and `badbit`. Changing the stream state involves either `clear()` or `setstate()`, which uses `clear()`. After changing the stream state, the `clear()` method compares the current stream state to the value returned by `exceptions()`. If a bit is set in the return value and the corresponding bit is set in the current state, `clear()` throws an `ios_base::failure` exception. This would happen, for example, if both values had `badbit` set. It follows that if `exceptions()` returns `goodbit`, no exceptions are thrown. The `ios_base::failure` exception class derives from the `std::exception` class and thus has a `what()` method.

The default setting for `exceptions()` is `goodbit`--—that is, no exceptions thrown. However, the overloaded `exceptions(iostate)` function gives you control over the behavior:

```C++
cin.exceptions(badbit);	// setting badbit causes exception to be thrown
```

The bitwise OR operator (`|`), as discussed in Appendix E, allows you to specify more than one bit. For example, the following statement results in an exception being thrown if either `badbit` or `eofbit` is subsequently set:

```C++
cin.exceptions(badbit | eofbit);
```

Listing 17.12 modifies Listing 17.11 so that the program throws and catches an exception if `failbit` is set.

```C++
// Listing 17.12
#include <iostream>
#include <exception>

int main()
{
	using namespace std;
	// have failure cause an exception to be thrown
	cin.exceptions(ios_base::failbit);
	cout << "Enter numbers: ";
	int sum = 0;
	int input;

	try
	{
		while (cin >> input)
			sum += input;
	}
	catch(ios_base::failure & bf)
	{
		cout << bf.what() << endl;
		cout << "O! the horro!\n";
	}
	cout << "Last value entered = " << input << endl;
	cout << "Sum = " << sum << endl;
	return 0;
}
```

So that’s how you can use exceptions for input. But should you use them? It depends on the context. For this example, the answer is no. An exception should catch an unusual, unexpected occurrence, but this particular program uses a type mismatch as the intended way to exit the loop. It might make sense, however, for this program to throw an exception for `badbit` because that circumstance would be unexpected. Or if the program were designed to read numbers from a data file up to end-of-file, it might make sense to throw an exception for `failbit` because that would represent a problem with the data file.

#### Stream State Effects

An `if` or `while` test such as the following tests as true only if the stream state is good (all bits cleared):

```C++
while (cin >> input)
```

If a test fails, you can use the member functions in Table 17.4 to discriminate among possible causes. For example, you could modify the central part of Listing 17.11 to look like this:

```C++
while (cin >> input)
{
	sum += input;
}
```

Setting a stream state bit has a very important consequence: The stream is closed for further input or output until the bit is cleared. For example, the following code won’t work:

```C++
while (cin >> input)
{
	sum += input;
}
cout << "Last value entered = " << input << endl;
cout << "Sum = " << sum << endl;
cout << "Now enter a new number: ";
cin >> input;	// won't work
```

If you want a program to read further input after a stream state bit has been set, you have to reset the stream state to good. This can be done by calling the `clear()` method:

```C++
while (cin >> input)
{
	sum += input;
}
cout << "Last value entered = " << input << endl;
cout << "Sum = " << sum << endl;
cout << "Now enter a new number: ";
cin.clear();		// reset stream state
while (!isspace(cin.get()))
	continue;		// get rid of bad input
cin >> input;		// will work now
```

Note that it is not enough to reset the stream state. The mismatched input that termi- nated the input loop is still in the input queue, and the program has to get past it. You can discard the rest of the line instead of just the next word:

```
while (cin.get() != '\n')
	continue;	// get rest of line
```

This example assumes that the loop terminated because of inappropriate input. Suppose, instead, that the loop terminated because of end-of-file or because of a hardware failure. Then the new code disposing of bad input makes no sense. You can fix matters by using the `fail()` method to test whether the assumption was correct. Because for histori- cal reasons, `fail()` returns `true` if either `failbit` or `eofbit` is set, the code has to exclude the latter case. The following code shows an example of such exclusion:

```C++
while (cin >> input)
	sum += input;
cout << "Last value entered = " << input << endl;
cout << "Sum = " << sum << endl;
if (cin.fail() && !cin.eof())	// failed because of mismatched input
{
	cin.clear();	// reset stream state
	while (!isspace(cin.get()))
		continue;	// get rid of bad input
}
else 	// else bail out
{
	cout << "I cannot go on!\n";
	exit(EXIT_FAILIURE);
}
cout << "Now enter a new number: ";
cin >> input;	// will work now
```

### Other `istream` Class Methods

Chapters 3 through 5 discuss the `get()` and `getline()` methods. As you may recall, they provide the following additional input capabilities:

* The `get(char &)` and `get(void)` methods provide single-character input that **doesn’t skip over white space**.
* The `get(char *, int, char)` and `getline(char *, int, char)` functions by default read entire lines rather than single words.

These are termed _unformatted input functions_ because they simply read character input as it is, without skipping over white space and without performing data conversions.

#### Single-Character Input

##### The `get(char &)` Member Function

The `get(char &)` member function returns a reference to the `istream` object used to invoke it. This means you can concatenate other extractions following `get(char &)`:

```C++
char c1, c2, c3;
cin.get(c1).get(c2) >> c3;
```


If `cin.get(char &)` encounters the end of a file, it does not assign a value to its argument. Further, the method calls `setstate(failbit)`, which causes `cin` to test as `false`.

Typically, `cin.get(char &)` can be used as the following:

```C++
char ch;
while (cin.get(ch))
{
	// process input
}
```

##### The `get()` Member Function

The `get(void)` member function returns type `int` (or some larger integer type, depending on the character set and locale). This makes the following invalid:

```C++
char c1, c2, c3;
cin.get().get() >> c3;	// not valid
```

Upon reaching the end-of-file, real or simulated, `cin.get(void)` returns the value `EOF`, which is a symbolic constant provided by the `iostream` header file. This design feature allows the following construction for reading input:

```C++
int ch;
while ((cin = cin.get()) != EOF)
{
	// process input
}
```

**You should use type `int` for `ch` instead of type char here because the value `EOF` may not be expressed as a `char` type.**

Table 17.5 summarizes the features of the single-character input functions.

![T17-5](\Pics\T17-5.png)

#### String Input: `getline()`, `get()` and `ignore()`

The `getline()` member function and the string-reading version of `get()` both read strings, and both have the same function signatures (here simplified from the more general template declaration):

```C++
istream & get(char *, int, char);
istream & get(char *, int);
istream & getline(char *, int, char);
istream & getline(char *, int);
```

The third argument specifies a character to act as a delimiter to input. The versions with just two arguments use the newline character as a delimiter. Each function reads up to the maximum characters or until it encounters the delimiter character, whichever comes first.

The chief difference between `get()` and `getline()` is that `get()` leaves the newline character in the input stream, making it the first character seen by the next input operation, whereas `getline()` extracts and discards the newline character from the input stream.

Listing 17.13 demonstrates how `getline()` and `get()` work. It also introduces the `ignore()` member function. `ignore()` takes two arguments: a number specifying a maximum number of characters to read and a character that acts as a delimiter character for input. For example, the following function call reads and discards the next 255 characters or up through the first newline character, whichever comes first:

```C++
cin.ignore(255, '\n');
```

The prototype provides defaults of `1` and `EOF` for the two arguments, and the function return type is `istream &`:

```C++
istream & ignore(int = 1, int = EOF);
```

```C++
// Listing 17.13

#include <iostream>
const int Limit = 255;

int main()
{
	using std::cout;
	using std::cin;
	using std::endl;

	char input[Limit];

	cout << "Enter a stirng for getline() processing:\n";
	cin.getline(input, Limit, '#');
	cout << "Here is your input:\n";
	cout << input << "\nDone with phase 1\n";

	char ch;
	cin.get(ch);
	cout << "The next input character is " << ch << endl;

	if (ch != '\n')
		cin.ignore(Limit, '\n');	// discard rest of line

	cout << "Enter a string for get() processing:\n";
	cin.get(input, Limit, '#');
	cout << "Here is your input:\n";
	cout << input << "\nDone with phase 2\n";

	cin.get(ch);
	cout << "The next input character is " << ch << endl;

	return 0;
}
```

Note that the `getline()` function discards the `#` termination character in the input, and the `get()` function does not.

##### Unexpected String Input

Both version set the `eofbit` if the end-of-file is encountered. Besides, their behavior is summarized in Table 17.6

![T17-6](\Pics\T17-6.png)

Note that an empty line does not cause `getline()` to set `failbit`. If you want a `getline()` loop to terminate on an empty line, you can write it this way:

```C++
char temp[80];
while (cin.getline(temp, 80) && temp[0] != '\0')
```

### Other `istream` Methods

Other istream methods besides the ones discussed so far include `read()`, `peek()`, `gcount()`, and `putback()`. The `read()` function reads a given number of bytes and stores them in the specified location. For example, the following statements read 144 characters from the standard input and place them in the `gross` array:

```C++
char gross[144];
cin.read(gross, 144);
```

Unlike `getline()` and `get()`, `read()` does not append a null character to input, so it doesn’t convert input to string form. The `read()` method is not intended for keyboard input. Instead, it is most often used in conjunction with the `ostream` `write()` function for file input and output. The method’s return type is `istream &`, so it can be concatenated as follows:

```C++
char gross[144];
char score[20];
cin.read(gross, 144).read(score, 20);
```

The `peek()` function returns the next character from input **without extracting from the input stream**. You can use `peek()` to peek at the next character in the input stream in order to judge whether to continue:

```C++
char great_input[80];
char ch;
int i = 0;
while ((ch = cin.peek()) != '.' && ch != '\n')
	cin.get(great_input[i++]);
great_input[i] = '\0';
```

When the loop terminates, the period or newline character remains in the input stream, positioned to be the first character read by the next input operation.

The `gcount()` method returns the number of characters read by the last unformatted extraction method. That means characters read by a `get()`, `getline()`, `ignore()`, or `read()` method but not by the extraction operator (`>>`), which formats input to fit partic- ular data types.

The `putback()` function inserts a character back in the input string. The inserted character then becomes the first character read by the next input statement. The `putback()` method takes one `char` argument, which is the character to be inserted, and it returns type `istream &`, which allows the call to be concatenated with other `istream` methods. Using `peek()` is like using `get()` to read a character and then using `putback()` to place the character back in the input stream. However, `putback()` gives you the option of putting back a character that is different from the one just read.

Listing 17.14 uses two approaches to read and echo input up to, but **not including**, a `#` character. The first approach reads through the `#` character and then uses `putback()` to insert the character back into the input. The second approach uses `peek()` to look ahead before reading input.

```C++
// Listing 17.14
#include <iostream>

int main()
{
	using std::cout;
	using std::cin;
	using std::endl;

// read and echo input up to a # character
	char ch;
	while (cin.get(ch))
	{
		if (ch != '#')
			cout << ch;
		else
		{
			cin.putback(ch);	// reinsert character
			break;
		}
	}
	if (!cin.eof())
	{
		cin.get(ch);
		cout << endl << ch << " is next input character.\n";
	}
	else
	{
		cout << "End of file reached.\n";
		std::exit(EXIT_FAILURE);
	}

	while (cin.peek() != '#')		// look ahead
	{
		cin.get(ch);
		cout << ch;
	}
	if (!cin.eof())
	{
		cin.get(ch);
		cout << endl << ch << " is next input character.\n";
	}
	else
		cout << "End of file reached.\n";

	return 0;
}
```

Now let’s look, as promised, at an example--—Listing 17.15--—that uses `peek()` to determine whether an entire line has been read. If only part of a line fits in the input array, the program discards the rest of the line.

```C++
// Listing 17.15
#include <iostream>
const int SLEN = 10;
inline void eatline() { while (std::cin.get() != '\n') continue; }
int main()
{
	using std::cin;
	using std::cout;
	using std::endl;

	char name[SLEN];
	char title[SLEN];
	cout << "Enter your name: ";
	cin.get(name, SLEN);
	if (cin.peek() != '\n')
		cout << "Sorry, we only have enough room for "
		 	 << name << endl;
	eatline();
	cout << "Dear " << name << ", enter your title: \n";
	cin.get(title, SLEN);
	if (cin.peek() != '\n')
		cout << "We were forced to truncate your title.\n";
	eatline();
	cout << " Name: " << name
		 << "\nTitle: " << title << endl;

	return 0;
}
```

No matter whether `get()` reads the whole line, one newline character will be left in the input stream. Thus, the following code makes sense:

```C++
while (cin.get() != '\n') continue;
```

## File Input and Output

### Simple File I/O

Suppose you want a program to write to a file.You must do the following:

1. Create an `ofstream` object to manage the output stream.
2. Associate that object with a particular file.
3. Use the object the same way you would use `cout`; the only difference is that output goes to the file instead of to the screen.

First, you declare an `ofstream` object:

```C++
ofstream fout;
```

Next, you must associate this object with a particular file. Suppose, for example, that you want to open the `jar.txt` file for output. You would do the following:

```C++
fout.open("jar.txt");
```

You can combine these two steps (creating the object and associating a file) into a single statement by using a different constructor:

```C++
ofstream fout("jar.txt");
```

When you’ve gotten this far, you use `fout` (or whatever name you choose) in the same manner as `cout`.

> **Caution**

> Opening a file for output in the default mode automatically truncates the file to zero size, in effect disposing of the prior contents.

The requirements for reading a file are much like those for writing to a file: 
1. Create an `ifstream` object to manage the input stream.
2. Associate that object with a particular file.
3. Use the object the same way you would use `cin`.

The connections with a file are closed automatically when the input and output stream objects expire—for example, when the program terminates. Also you can close a connection with a file explicitly by using the `close()` method:

```C++
fout.close();	// close output connection to file
fin.close();	// close input connection to file
```

As you’ll see later, you can reconnect the stream to the same file or to another file.

Let’s look at a short example. The program in Listing 17.16 asks for a filename. It creates a file that has that name, writes some information to it, and closes the file. Closing the file flushes the buffer, guaranteeing that the file is updated. Then the program opens the same file for reading and displays its contents. Also, the program reads the filename into a string object and then uses the `c_str()` method to provide C-style string arguments for the ofstream and ifstream constructors.

```C++
// Listing 17.16
#include <iostream>
#include <fstream>
#include <string>

int main()
{
    using namespace std;
    string filename;

    cout << "Enter name for new file: ";
    cin >> filename;

// create output stream object for new file and call it fout
    ofstream fout(filename.c_str());

    fout << "for your eyes only!\n";        // write to file
    cout << "Enter your secret number: ";   // write to screen
    float secret;
    cin >> secret;
    fout << "Your secret number is " << secret << endl;
    fout.close();                           // close file

// create input stream object for new file and call it fin
    ifstream fin(filename.c_str());
    cout << "Here are the contents of " << filename << ":\n";
    char ch;
    while (fin.get(ch))     // read characters from file and
        cout << ch;         // write it to screen
    cout << "Done\n";
    fin.close();

    return 0;
}
```

### Stream Checking and `is_open()`

The C++ file stream classes inherit a stream-state member from the `ios_base` class.This member, as discussed earlier, stores information that reflects the stream status: All is well, end-of-file has been reached, I/O operation failed, and so on. You can check the stream state to find whether the most recent stream operation succeeded or failed. For file streams, this includes checking the success of an attempt to open a file. For example, attempting to open a non-existent file for input sets `failbit`. So you could check this way:

```C++
fin.open(argv[file]);
if (fin.fail())
{
	...
}
```

or

```C++
fin.open(argv[file])
if (!fin)
{
	...
}
```

However, newer C++ implementations have a better way to check whether a file has been opened—--the `is_open()` method:

```C++
if (!fin.is_open())
{
	...
}
```

The `fin` object, when used in a test condition, is converted to `false` if `fin.good()` is `false` and to `true` otherwise, so the two forms are equivalent. However, these tests fail to detect one circumstance, which is attempting to open a file by using an inappropriate file mode (see the “File Modes” section, later in this chapter). The `is_open()` method catches this form of error, along with those caught by the `good()` method. 

### Opening Multiple Files

If you need two files open simultaneously, you must create a separate stream for each file.

However, you may plan to process a group of files sequentially. In this case, you can open a single stream and associate it with each file in turn. For example, this is how you could handle reading two files in succession:

```C++
ifstream fin;			// create stream using default constructor
fin.open("fat.txt");	// associate stream with fat.txt file
...
fin.close();			// terminate association with fat.txt
fin.clear();			// reset fin (may not by needed)
fin.open("rat.txt");	// associate stream with rat.txt file
...
fin.close();
```

We’ll look at an example shortly, but first, let’s examine a technique for feeding a list of files to a program in a manner that allows the program to use a loop to process them.

### Command-Line Processing

_Command-line_ are arguments that appear on the command line when you type a command. C++ has a mechanism for letting a program running in a command-line environment access the command-line arguments. You can use the following alternative function heading for `main()`:

```C++
int main(int argc, char * argv[])
```

The `argc` argument represents the number of arguments on the command line. The count includes the command name itself. That is, argv[0] is the first string from the command line, and so on. For example, suppose you have the following command line:

```
wc report1 report2 report3
```

In this case, `argc` would be `4`, `argv[0]` would be `wc`, `argv[1]` would be `report1`, and so on. The following loop would print each command-line argument on a separate line:

```C++
for (int i = 1; i < argc; i++)
	cout << argv[i] << endl;
```

Listing 17.17 combines the command-line technique with file stream techniques to count characters in files listed on the command line.

```C++
// Listing 17.17
#include <iostream>
#include <fstream>
#include <cstdlib>  // for exit()
int main(int argc, char * argv[])
{
    using namespace std;
    if (argc == 1)
    {
        cerr << "Usage: " << argv[0] << " filename[s]\n";
        exit(EXIT_FAILURE);
    }

    ifstream fin;       // open stream
    long count;
    long total = 0;
    char ch;
    for (int file = 1; file < argc; file++)
    {
        fin.open(argv[file]);   // connect stream to argv[file]
        if (!fin.is_open())
        {
            cerr << "Could not open " << argv[file] << endl;
            fin.clear();
            continue;
        }
        count = 0;
        while (fin.get(ch))
            count++;
        cout << count << " characters in " << argv[file] << endl;
        total += count;
        fin.clear();        // needed for some implementations
        fin.close();        // disconnect file
    }
    cout << total << " characters in all files\n";

    return 0;
}
```

> **Note**

> Some C++ implementations require using `fin.clear()` at the end of the program, and others do not. It depends on whether associating a new file with the `ifstream` object automatically resets the stream state. In does no harm to use `fin.clear()` even if it isn’t needed.

### File Modes

When you associate a stream with a file, either by initializing a file stream object with a filename or by using the `open()` method, you can provide a second argument that specifies the file mode:

```C++
ifstream fin("banjo", mode1);	// constructor with mode argument
ofstream fout();
fout.open("harp", mode2);		// open() with mode arguments
```

The `ios_base` class defines an `openmode` type to represent the mode; like the `fmtflags` and `iostate` types, it is a `bitmask` type. Table 17.7 lists the constants and their meanings.

![T17-7](\Pics\T17-7.png)

The prototypes for the `open()` methods of the `ifstream` and `oftream` classesprovide default values for the second argument (the file mode argument). For example, the `ifstream` `open()` method and constructor use `ios_base::in` (open for reading) as the default value for the mode argument, and the `ofstream` `open()` method and constructor use `ios_base::out | ios_base::trunc` (open for writing and truncate the file) as the default. The `fstream` class doesn’t provide a mode default, so you have to provide a mode explicitly when creating an object of that class. If, for example, you want to preserve the file con-tents and add (append) new material to the end of the file, you can use the `ios_base::app` mode:

```C++
ofstream fout("bagels", ios_base::out | ios_base::app);
```

Table 17.8 shows the correspondence between C++ modes and C modes. Note that `ios_base::out` by itself causes truncation but that it doesn’t cause truncation when combined with `ios_base::in`. Unlisted combinations, such as `ios_base::in | ios_base::trunc`, prevent the file from being opened. The `is_open()` method detects this failure.

![T17-8](\Pics\T17-8.png)

Note that both `ios_base::ate` and `ios_base::app` place you (or, more precisely, a file pointer) at the end of the file just opened. The difference between the two is that the `ios_base::app` mode allows you to add data to the end of the file only, while the `ios_base::ate` mode merely positions the pointer at the end of the file.

#### Appending to a File

Let’s look at a program that appends data to the end of a file. Listing 17.18 illustrates how to accomplish these goals. Note how the program uses the `is_open()` method to test whether the file has been opened successfully.

```C++
// Listing 17.18
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>      // for exit()

const char * file = "guests.txt";
int main()
{
    using namespace std;
    char ch;
// show initial contents
    ifstream fin;
    fin.open(file);

    if (fin.is_open())
    {
        cout << "Here are the current contents of the "
             << file << " file:\n";
        while (fin.get(ch))
            cout << ch;
        fin.close();
    }

// add new names
    ofstream fout(file, ios::out | ios::app);
    if (!fout.is_open())
    {
        cerr << "Can't open " << file << " file for output.\n";
        exit(EXIT_FAILURE);
    }

    cout << "Enter guest names (enter a blank line to quit):\n";
    string name;
    while (getline(cin, name) && name.size() > 0)
        fout << name << endl;
    fout.close();

// show revised file
    fin.clear();    // not necessary for some compilers
    fin.open(file);
    if (fin.is_open())
    {
        cout << "Here are the new contents of the "
             << file << " file:\n";
        while (fin.get(ch))
            cout << ch;
        fin.close();
    }
    cout << "Done.\n";
    return 0;
}
```

#### Binary Files

Consider the following structure definition and declaration:

```C++
const int LIM = 20;
struct planet
{
	char name[LIM];
	double population;
	double g;
};
planet pl;
```

To save the contents of the structure `pl` in text form, you can use this:

```C++
ofstream fout("planet.dat", ios_base::out | ios_base::app);
fout << pl.name << " " << pl.population << " " << pl.g << "\n";
```

To save the same information in binary format, you can use this:

```C++
ofstream fout("planets.dat",
	ios_base::out | ios_base::app | ios_base::binary);
fout.write((char *) &pl, sizeof pl);
```

This code saves the entire structure as a single unit, using the computer’s internal representation of data. This approach makes two changes:

* It uses a binary file mode
* It uses the `write()` member function

To save data in binary form instead of text form, you can use the `write()` member function. This method, recall, copies a specified number of bytes from memory to a file. This chapter used it earlier to copy text, but it will copy any type of data byte-by-byte with no conversion. If you pass to it the address of a `long` variable and tell it to copy 4 bytes, it will copy the 4 bytes constituting the `long` value verbatim to a file and not convert it to text. The only awkwardness is that **you have to type cast the address to type pointer-to-`char`.** You can use the same approach to copy an entire `planet` structure. To get the number of bytes, you use the `sizeof` operator:

```C++
fout.write((char *) &pl, sizeof pl);
```

To recover the information from a file, you use the corresponding `read()` method with an `ifstream` object:

```C++
ifstream fin("plannets.dat", ios_base::in | ios_base::binary);
fin.read((char *) &pl, sizeof pl);
```


This same approach can be used with classes that **don’t use virtual functions**. In that case, just the data members are saved, not the methods. If the class does have virtual methods, then a hidden pointer to a table of pointers to virtual functions is also copied. Because the next time you run the program it might locate the virtual function table at a different location, copying old pointer information into objects from a file can create havoc. 

Listing 17.19 uses these methods to create and read a binary file. In form, the program is similar to Listing 17.18, but it uses `write()` and `read()` instead of the insertion operator and the `get()` method. It also uses manipulators to format the screen output.

```C++
// Listing 17.19
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>

inline void eatline() { while (std::cin.get() != '\n') continue; }
struct planet
{
    char name[20];      // name of planet
    double population;  // its population
    double g;           // its acceleration of gravity
};

const char * file = "planets.dat";

int main()
{
    using namespace std;
    planet pl;
    cout << fixed << right;

// show initial contents
    ifstream fin;
    fin.open(file, ios_base::in | ios_base::binary);    // binary file
    if (fin.is_open())
    {
        cout << "Here are the current contents of the "
             << file << " file:\n";
        while (fin.read((char *) & pl, sizeof pl))
        {
            cout << setw(20) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        fin.close();
    }
// add new data
    ofstream fout(file,
        ios_base::out | ios_base::app | ios_base::binary);
    if (!fout.is_open())
    {
        cerr << "Can't open " << file << " file for output:\n";
        exit(EXIT_FAILURE);
    }

    cout << "Enter planet name (enter a blank line to quit):\n";
    cin.get(pl.name, 20);
    while (pl.name[0] != '\0')
    {
        eatline();
        cout << "Enter planetary population: ";
        cin >> pl.population;
        cout << "Enter planet's accelaration of gravity: ";
        cin >> pl.g;
        eatline();
        fout.write((char *) &pl, sizeof pl);
        cout << "Enter planet name (enter a blank line to quit):\n";
        cin.get(pl.name, 20);
    }
    fout.close();
// show revised file
    fin.clear(); 
    fin.open(file, ios_base::in | ios_base::binary);
    if (fin.is_open())
    {
        cout << "Here are the new contents of the "
             << file << " file:\n";
        while (fin.read((char *) &pl, sizeof pl))
        {
            cout << setw(20) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        fin.close();
    }
    cout << "Done.\n";
    return 0;
}
```

You might wonder if this program could use a `string` object instead of a character array for the `name` member of the `planet` structure. The answer is no--—at least not without major changes in design. The problem is that a `string` object doesn’t actually contain the `string` within itself; instead, it contains a pointer to the memory location where the string is stored. So if you copy the structure to a file, you don’t copy the string data, you just copy the address of where the string was stored. When you run the program again, that address is meaningless.

### Random Access

Random access means moving directly to any location in the file instead of moving through it sequentially.

This example is based on the binary file program in Listing 17.19, to take advantage of the fact that the `planet` structure provides a pattern for a file record. To add to the creative tension of programming, the example opens the file in a read-and-write mode so that it can both read and modify a record. You can do this by creating an `fstream` object. The `fstream` class derives from the `iostream` class, which, in turn, is based on both the `istream` and `ostream` classes, so **it inherits the methods of both**. It also inherits two buffers, one for input and one for output, and synchronizes the handling of the two buffers. That is, as the program reads the file or writes to it, **it moves both an input pointer in the input buffer and an output pointer in the output buffer in tandem**.

The example does the following:

1. Displays the current contents of the `planets.dat` file. 
2. Asks which record you want to modify.
3. Modifies that record.
4. Shows the revised file

First, you need the following statement to set up business:

```C++
finout.open(file, ios_base::in | ios_base::out | ios_base::binary);
```

Next, you need a way to move through a file. The `fstream` class inherits two methods for this: `seekg()` moves the input pointer to a given file location, and `seekp()` moves the output pointer to a given file location. Here are the `seekg()` prototypes:

```C++
basic_istream<charT, traits> & seekg(off_type, ios_base::seekdir);
basic_istream<charT, traits> & seekg(pos_type);
```

As you can see, they are templates. This chapter uses a template specialization for the `char` type. For the `char` specialization, the two prototypes are equivalent to the following:

```C++
istream & seekg(streamoff, ios_base::seekdir);
istream & seekg(streampos);
```

The first prototype represents locating a file position measured, in bytes, as an offset from a file location specified by the second argument. The second prototype represents locating a file position measured, in bytes, from the beginning of a file.

The `streamoff` argument represents the file position, in bytes, measured as an offset from one of three locations. (The type may be defined as an integer type or as a class.) The `seek_dir` argument is another integer type that is defined, along with three possible values, in the `ios_base` class. The constant `ios_base::beg` means measure the offset from the beginning of the file. The constant `ios_base::cur` means measure the offset from the current position. The constant `ios_base::end` means measure the offset from the end of the file. Here are some sample calls, assuming that `fin` is an `ifstream` object:

```C++
fin.seekg(20, ios_base::beg);	// 30 bytes beyond the beginning
fin.seeg(-1, ios_base::cur);	// back up one byte
fin.seekg(0, ios_base::end);	// go to the end of the file
```

Now let’s look at the second prototype. You can treat a `streampos` position as if it measures a file location in bytes from the beginning of a file, with the first byte being byte 0. So the following statement locates the file pointer at byte 112, which would be the 113th byte in the file:

```C++
fin.seekg(112);
```

If you want to check the current position of a file pointer, you can use the `tellg()` method for input streams and the `tellp()` methods for output streams. Each returns a `streampos` value representing the current position, in bytes, measured from the beginning of the file. When you create an `fstream` object, the input and output pointers move in tandem, so `tellg()` and `tellp()` return the same value. But if you use an `istream` object to manage the input stream and an `ostream` object to manage the output stream to the same file, the input and output pointers move independently of one another, and `tellg()` and `tellp()` can return different values.

You can then use `seekg()` to go to the file beginning. Here is a section of code that opens a file, goes to the beginning, and displays the file contents:

```C++
fstream finout;		// read and write streams
finout.open(file, ios::in | ios::out | ios::binary);
int ct = 0;
if (finout.is_open())
{
	finout.seekg(0);	// go to beginning
	cout << "Here are the current contents of the "
		 << file << " file:\n";
	while (finout.read(char *) &pl, sizeof pl)
	{
		cout << ct++ << ": " << setw(LIM) << pl.name << ": "
			 << setprecision(0) << setw(12) << pl.population
			 << setprecision(2) << setw(6) << pl.g << endl;
	}
	if (finout.eof())
		finout.clear();		// clear eof flag
	else
	{
		cerr << "Error in reading " << file << ".\n";
		exit(EXIT_FAILURE);
	}
}
else
{
	cerr << file << " could not be opened -- bye.\n";
	exit(EXIT_FAILURE);
}
```

The next step is to identify the record to be changed and then change it. To do this, the program asks the user to enter a record number. Multiplying the number by the number of bytes in a record yields the byte number for the beginning of the record. If `record` is the record number, the desired byte number is `record * sizeof pl`:

```C++
cout << "Enter the record number you wish to change: ";
long rec;
cin >> rec;
eatline();		// get rid of newline
if (rec < 0 || rec >= ct)
{
	cerr << "Invalid record number -- bye\n";
	exit(EXIT_FAILURE);
}
streampos place = rec * sizeof pl;	// convert to streampos type
finout.seekg(place);	// random access
```

Next, the program displays the current record:

```C++
finout.read((char *) &pl, sizeof pl);
cout << "Your selection:\n";
cout << rec << ": " << setw(LIM) << pl.name << ": "
	 << setprecision(0) << setw(12) << pl.population
	 << setprecision(2) << setw(6) << endl;
if (finout.eof())
	finout.clear();	// clear eof flag
```

After displaying the record, the program lets you change the record:

```C++
cout << "Enter the planet name: ";
cin.get(pl.name, LIM);
eatline();
cout << "Enter planetary population: ";
cin >> pl.population;
cout << "Enter planet's acceleration of gravity: ";
cin >> pl.g;
finout.seekp(place);	// go back
finout.write((char *) &pl, sizeof pl) << flush;

if (finout.fail())
{
	cerr << "Error on attempted write\n";
	exit(EXIT_FAILURE);
}
```

To display the revised file, the program **uses `seekg()` to reset the file pointer to the beginning**. Listing 17.20 shows the complete program. Don’t forget that it assumes that a `planets.dat` file created using the `binary.cpp` program is available.

```C++
// Listing 17.20
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdlib>
const int LIM = 20;
struct planet
{
    char name[LIM];     // name of planet
    double population;  // its population
    double g;           // its acceleration of gravity
};

const char * file = "planets.dat";  // ASSUMED TO EXIST
inline void eatline() { while (std::cin.get() != '\n') continue; }

int main()
{
    using namespace std;
    planet pl;
    cout << fixed;

// show initial contents
    fstream finout;     // read and write streams
    finout.open(file,
        ios_base::in | ios_base::out | ios_base::binary);
    int ct = 0;
    if (finout.is_open())
    {
        finout.seekg(0);    // go to beginning
        cout << "Here are the current contents of the "
             << file << " file:\n";
        while (finout.read((char *) &pl, sizeof pl))
        {
            cout << ct++ << ": " << setw(LIM) << pl.name << ": "
                 << setprecision(0) << setw(12) << pl.population
                 << setprecision(2) << setw(6) << pl.g << endl;
        }
        if (finout.eof())
            finout.clear(); // clear eof flag
        else
        {
            cerr << "Error in reading " << file << ".\n";
            exit(EXIT_FAILURE);
        }
    }
    else
    {
        cerr << file << " could not be opened -- bye.\n";
        exit(EXIT_FAILURE);
    }

// change a record
    cout << "Enter the record number you wish to change: ";
    long rec;
    cin >> rec;
    eatline();      // get rid of newline
    if (rec < 0 || rec >= ct)
    {
        cerr << "Invalid record number -- bye\n";
        exit(EXIT_FAILURE);
    }
    streampos place = rec * sizeof pl;  // convert to streampos type
    finout.seekg(place);    // random access
    if (finout.fail())
    {
        cerr << "Error on attempted seek\n";
        exit(EXIT_FAILURE);
    }

    finout.read((char *) &pl, sizeof pl);
    cout << "Your selection:\n";
    cout << rec << ": " << setw(LIM) << pl.name << ": "
         << setprecision(0) << setw(12) << pl.population
         << setprecision(2) << setw(6) << pl.g << endl;
    if (finout.eof())
        finout.clear(); // clear eof flag

    cout << "Enter planet name: ";
    cin.get(pl.name, LIM);
    eatline();
    cout << "Enter planetary population: ";
    cin >> pl.population;
    cout << "Enter planet's acceleration of gravity: ";
    cin >> pl.g;
    finout.seekp(place);    // go back
    finout.write((char *) &pl, sizeof pl) << flush;
    if (finout.fail())
    {
        cerr << "Error on attempted write\n";
        exit(EXIT_FAILURE);
    }

// show revised file
    ct = 0;
    finout.seekg(0);    // go to beginning of file
    cout << "Here are the new contents of the " << file
         << "file:\n";
    while (finout.read((char *) &pl, sizeof pl))
    {
        cout << ct++ << ": " << setw(LIM) << pl.name << ": "
             << setprecision(0) << setw(12) << pl.population
             << setprecision(2) << setw(6) << pl.g << endl;
    }
    finout.close();
    cout << "Done.\n";
    return 0;
}
```

## Incore Formatting

The C++ library also provides an `sstream` family, which uses the same interface to provide I/O between a program and a `string` object. That is, you can use the same `ostream` methods you’ve used with `cout` to write formatted information into a `string` object, and you can use `istream` methods such as `getline()` to read information from a `string` object. The process of reading formatted information from a `string` object or of writing formatted information to a `string` object is termed _incore formatting_.

The `sstream` header file defines an `ostringstream` class that is derived from the `ostream` class. If you create an `ostringstream` object, you can write information to it, which it stores. You can use the same methods with an `ostringstream` object that you can with `cout`. That is, you can do something like the following:

```C++
ostringstream outstr;
double price = 380.0;
char * ps = " for a copy of the ISO/EIC C++ standard!";
outstr.precision(2);
outstr << fixed;
outstr << "Pay only CHF " << price << ps << end;
```

The formatted text goes into a buffer, and the object uses dynamic memory allocation to expand the buffer size as needed. The `ostringstream` class has a member function, called `str()`, that returns a `string` object initialized to the buffer’s contents:

```C++
string mesg = outstr.str();	// returns string with formatted information
```

Using the `str()` method “freezes” the object, and **you can no longer write to it**.

Listing 17.21 provides a short example of incore formatting.

```C++
// Listing 17.21
#include <iostream>
#include <sstream>
#include <string>

int main()
{
	using namespace std;
	ostringstream outstr;		// manages a string stream

	string hdisk;
	cout << "What's the name of your hard disck? ";
	getline(cin, hdisk);
	int cap;
	cout << "What's its capcity in GB? ";
	cin >> cap;
	// write formatted information to string stream
	outstr << "The harddisk " << hdisk << " has a capacity of "
		   << cap << " gigabytes.\n";
	string result = outstr.str();	// save results
	cout << result;					// show contents

	return 0;
}
```

The `istringstream` class lets you use the `istream` family of methods to read data from an `istringstream` object, which can be initialized from a `string` object.

Suppose `facts` is a `string` object. To create an `istringstream` object associated with this
string, you can use the following:

```C++
istringstream instr(facts);		// use facts to initialize stream
```

Then you use `istream` methods to read data from `instr`. For example, if instr contained a bunch of integers in character format, you could read them as follows:

```C++
int n;
int sum = 0;
while (instr >> n)
	sum += n;
```

Listing 17.22 uses the overloaded `>>` operator to read the contents of a string one word
at a time.

```C++
// Listing 17.22
#include <iostream>
#include <sstream>
#include <string>

int main()
{
	using namespace std;
	string lit = "It was a dark and stormy day, and "
		  		 " the full moon glowed brilliantly. ";
	istringstream instr(lit);	// use buf for input
	string word;
	while (instr >> word)		// read a word a time
		cout << word << endl;

	return 0;
}
```





